/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkcommunity = self.webpackChunkcommunity || []).push([
  [3863],
  {
    87228: (e) => {
      e.exports = {
        Dummy: "gamerecordingmarkers_Dummy_COUpR",
        Selected: "gamerecordingmarkers_Selected_o4ujS",
        HighlightIcon: "gamerecordingmarkers_HighlightIcon_2HB5V",
        CustomMarker: "gamerecordingmarkers_CustomMarker_1rrTH",
        MarkerBacking: "gamerecordingmarkers_MarkerBacking_3VL7B",
        HighlightIconSVG: "gamerecordingmarkers_HighlightIconSVG_3gFi3",
        Faded: "gamerecordingmarkers_Faded_cPJMu",
        MarkerCtn: "gamerecordingmarkers_MarkerCtn_1Nuyi",
        MarkerElt: "gamerecordingmarkers_MarkerElt_2hqDH",
      };
    },
    71488: (e) => {
      e.exports = {
        GameRecordingPlayer: "gamerecordingplayer_GameRecordingPlayer_3jI6y",
        NoVideo: "gamerecordingplayer_NoVideo_23VPl",
        PlayerError: "gamerecordingplayer_PlayerError_3U5hK",
        Text: "gamerecordingplayer_Text_RAmBa",
        PerfCtnVideo: "gamerecordingplayer_PerfCtnVideo_1dj9T",
        PerfCtnThumbnails: "gamerecordingplayer_PerfCtnThumbnails_2OYmS",
      };
    },
    81768: (e) => {
      e.exports = {
        GoLiveButtonCtn: "golivebutton_GoLiveButtonCtn_2yilN",
        GoLiveButton: "golivebutton_GoLiveButton_34wWG",
        IsLive: "golivebutton_IsLive_3LAZF",
      };
    },
    25733: (e) => {
      e.exports = {
        PlaybackControls: "playbackcontrols_PlaybackControls_ohJRT",
        Show: "playbackcontrols_Show_3NIQX",
        PlaybackControlsBar: "playbackcontrols_PlaybackControlsBar_33Kac",
        PlaybackButton: "playbackcontrols_PlaybackButton_2W5Kg",
        PlaybackButtonContents: "playbackcontrols_PlaybackButtonContents_3OnFL",
        JumpButton: "playbackcontrols_JumpButton_2dKFb",
        JumpLegend: "playbackcontrols_JumpLegend_pqvN-",
        CircleButtonLarge: "playbackcontrols_CircleButtonLarge_2RnUQ",
        CircleButtonMedium: "playbackcontrols_CircleButtonMedium_25OY9",
        SpeedDrop: "playbackcontrols_SpeedDrop_3WHcx",
        PlaybackControlsStyles: "playbackcontrols_PlaybackControlsStyles_3dGyK",
        DialogTextInputBase: "playbackcontrols_DialogTextInputBase_N8wgs",
        MuteMaxButtons: "playbackcontrols_MuteMaxButtons_3Ye2F",
        UserSelectionControls: "playbackcontrols_UserSelectionControls_2P3vw",
      };
    },
    33337: (e) => {
      e.exports = {
        TimeBar: "playbackelapsedtime_TimeBar_8-UPu",
        RangeSelection: "playbackelapsedtime_RangeSelection_1AqPD",
      };
    },
    7610: (e) => {
      e.exports = {
        LoadingTimeline: "horizontalscrollbar_LoadingTimeline_1D-So",
        ScrollAndControlsCtn: "horizontalscrollbar_ScrollAndControlsCtn_1fKRe",
        Controls: "horizontalscrollbar_Controls_38yPH",
        TimelineScrollContainer:
          "horizontalscrollbar_TimelineScrollContainer_xRa-T",
        ContentContainer: "horizontalscrollbar_ContentContainer_vgmXO",
        AbsoluteLayer: "horizontalscrollbar_AbsoluteLayer_3G_ex",
        HideOverflow: "horizontalscrollbar_HideOverflow_3D4u3",
        RelativeLayer: "horizontalscrollbar_RelativeLayer_1m9da",
        WithPointerEvents: "horizontalscrollbar_WithPointerEvents_a4CUE",
        RecordingDecorators: "horizontalscrollbar_RecordingDecorators_15gQK",
        ClipDecorators: "horizontalscrollbar_ClipDecorators_7Kw7g",
        GameModes: "horizontalscrollbar_GameModes_27tZ7",
        DateDecorator: "horizontalscrollbar_DateDecorator_3rA50",
        BackgroundTicks: "horizontalscrollbar_BackgroundTicks_30NkC",
        Highlights: "horizontalscrollbar_Highlights_33gT4",
        Timestamps: "horizontalscrollbar_Timestamps_YbTgd",
        RangeSelector: "horizontalscrollbar_RangeSelector_1t9Pg",
        SeekScrubber: "horizontalscrollbar_SeekScrubber_27y0R",
        PlayHead: "horizontalscrollbar_PlayHead_1jPrR",
        ContentAndGradient: "horizontalscrollbar_ContentAndGradient_1dDu2",
        LeftControlsAndContent:
          "horizontalscrollbar_LeftControlsAndContent_3yc4q",
        ScrollGradientCtn: "horizontalscrollbar_ScrollGradientCtn_3fqpl",
        FrontGradient: "horizontalscrollbar_FrontGradient_1hkgv",
        HideGradient: "horizontalscrollbar_HideGradient_qhlja",
        EndGradient: "horizontalscrollbar_EndGradient_2JQjg",
        StartClipRangeButton: "horizontalscrollbar_StartClipRangeButton_w2UDC",
        ScrollbarAndSiblings: "horizontalscrollbar_ScrollbarAndSiblings_3W7zz",
        ScrollBarCtn: "horizontalscrollbar_ScrollBarCtn_13PY_",
        HideScrollBar: "horizontalscrollbar_HideScrollBar_1twVP",
        ScrollTrack: "horizontalscrollbar_ScrollTrack_1Vd-p",
        PlayHeadAnnotation: "horizontalscrollbar_PlayHeadAnnotation_2cNai",
        RangeAnnotation: "horizontalscrollbar_RangeAnnotation_2vBrC",
        ScrollThumb: "horizontalscrollbar_ScrollThumb_302_7",
      };
    },
    53643: (e) => {
      e.exports = {
        MouseListenerContainer:
          "mouselistenercontext_MouseListenerContainer_lXJ5r",
      };
    },
    11426: (e) => {
      e.exports = {
        LoadingTimeline: "timeline_LoadingTimeline_104yw",
        ScrollAndControlsCtn: "timeline_ScrollAndControlsCtn_1w0s0",
        Controls: "timeline_Controls_1-2MV",
        TimelineScrollContainer: "timeline_TimelineScrollContainer_16HSK",
        ContentContainer: "timeline_ContentContainer_Heach",
        AbsoluteLayer: "timeline_AbsoluteLayer_31ugB",
        HideOverflow: "timeline_HideOverflow_RIvxG",
        RelativeLayer: "timeline_RelativeLayer_3KbHI",
        WithPointerEvents: "timeline_WithPointerEvents_epSRg",
        RecordingDecorators: "timeline_RecordingDecorators_2YjCV",
        ClipDecorators: "timeline_ClipDecorators_1jwHn",
        GameModes: "timeline_GameModes_1FyW2",
        DateDecorator: "timeline_DateDecorator_3gxdx",
        BackgroundTicks: "timeline_BackgroundTicks_3VSuB",
        Highlights: "timeline_Highlights_17PaA",
        Timestamps: "timeline_Timestamps_2iQC-",
        RangeSelector: "timeline_RangeSelector_1LdSo",
        SeekScrubber: "timeline_SeekScrubber_1kifR",
        PlayHead: "timeline_PlayHead_1edPX",
      };
    },
    48203: (e) => {
      e.exports = {
        LoadingTimeline: "backgroundticks_LoadingTimeline_1nhyp",
        ScrollAndControlsCtn: "backgroundticks_ScrollAndControlsCtn_2jMxR",
        Controls: "backgroundticks_Controls_1akwd",
        TimelineScrollContainer:
          "backgroundticks_TimelineScrollContainer_1J3s3",
        ContentContainer: "backgroundticks_ContentContainer_AhkWT",
        AbsoluteLayer: "backgroundticks_AbsoluteLayer_BzbH8",
        HideOverflow: "backgroundticks_HideOverflow_3-Piz",
        RelativeLayer: "backgroundticks_RelativeLayer_3L5Lq",
        WithPointerEvents: "backgroundticks_WithPointerEvents_1yz9f",
        RecordingDecorators: "backgroundticks_RecordingDecorators_39-GX",
        ClipDecorators: "backgroundticks_ClipDecorators_VVE9n",
        GameModes: "backgroundticks_GameModes_1vjnV",
        DateDecorator: "backgroundticks_DateDecorator_2FJv6",
        BackgroundTicks: "backgroundticks_BackgroundTicks_3xCy4",
        Highlights: "backgroundticks_Highlights_3d76O",
        Timestamps: "backgroundticks_Timestamps_1XD0r",
        RangeSelector: "backgroundticks_RangeSelector_32HZT",
        SeekScrubber: "backgroundticks_SeekScrubber_33GBk",
        PlayHead: "backgroundticks_PlayHead_2Vpra",
        TimeTick: "backgroundticks_TimeTick_wC1Hp",
        TickLine: "backgroundticks_TickLine_123yn",
        Whole: "backgroundticks_Whole_2ZgId",
        TickStamp: "backgroundticks_TickStamp_1Roio",
        timelineFadeIn: "backgroundticks_timelineFadeIn_28Avs",
      };
    },
    88068: (e) => {
      e.exports = {
        LoadingTimeline: "clipdecorators_LoadingTimeline_2bY2S",
        ScrollAndControlsCtn: "clipdecorators_ScrollAndControlsCtn_1xMEz",
        Controls: "clipdecorators_Controls_4lBIa",
        TimelineScrollContainer: "clipdecorators_TimelineScrollContainer_3a6K_",
        ContentContainer: "clipdecorators_ContentContainer_1u95L",
        AbsoluteLayer: "clipdecorators_AbsoluteLayer_2_sGi",
        HideOverflow: "clipdecorators_HideOverflow_3SCxg",
        RelativeLayer: "clipdecorators_RelativeLayer_3qNMl",
        WithPointerEvents: "clipdecorators_WithPointerEvents_2Efl8",
        RecordingDecorators: "clipdecorators_RecordingDecorators_2-j8G",
        ClipDecorators: "clipdecorators_ClipDecorators_1a1y2",
        GameModes: "clipdecorators_GameModes_Va-lx",
        DateDecorator: "clipdecorators_DateDecorator_3Qm_f",
        BackgroundTicks: "clipdecorators_BackgroundTicks_AQyTU",
        Highlights: "clipdecorators_Highlights_19_CN",
        Timestamps: "clipdecorators_Timestamps_3eeJo",
        RangeSelector: "clipdecorators_RangeSelector_2rR88",
        SeekScrubber: "clipdecorators_SeekScrubber_1RkKY",
        PlayHead: "clipdecorators_PlayHead_2C0ir",
        ClipDecorator: "clipdecorators_ClipDecorator_25Sue",
        gradient: "clipdecorators_gradient_8rwKt",
      };
    },
    7023: (e) => {
      e.exports = {
        LoadingTimeline: "datedecorator_LoadingTimeline_3khna",
        ScrollAndControlsCtn: "datedecorator_ScrollAndControlsCtn_p0F5H",
        Controls: "datedecorator_Controls_3EWZM",
        TimelineScrollContainer: "datedecorator_TimelineScrollContainer_2nj1y",
        ContentContainer: "datedecorator_ContentContainer_K0sdF",
        AbsoluteLayer: "datedecorator_AbsoluteLayer_3lb95",
        HideOverflow: "datedecorator_HideOverflow_1F1t_",
        RelativeLayer: "datedecorator_RelativeLayer_2Pthd",
        WithPointerEvents: "datedecorator_WithPointerEvents_J2gfp",
        RecordingDecorators: "datedecorator_RecordingDecorators_1sNRj",
        ClipDecorators: "datedecorator_ClipDecorators_3Oi0q",
        GameModes: "datedecorator_GameModes_2q2sI",
        DateDecorator: "datedecorator_DateDecorator_1QlrO",
        BackgroundTicks: "datedecorator_BackgroundTicks_21N75",
        Highlights: "datedecorator_Highlights_1YYhG",
        Timestamps: "datedecorator_Timestamps_2RiSJ",
        RangeSelector: "datedecorator_RangeSelector_2qFLl",
        SeekScrubber: "datedecorator_SeekScrubber_GMVvU",
        PlayHead: "datedecorator_PlayHead_3N85p",
        TimelineRelativeDate: "datedecorator_TimelineRelativeDate_1D9m_",
        Overlay: "datedecorator_Overlay_RZAFF",
      };
    },
    22334: (e) => {
      e.exports = {
        LoadingTimeline: "gamemodes_LoadingTimeline_1IVkG",
        ScrollAndControlsCtn: "gamemodes_ScrollAndControlsCtn_3_Qj1",
        Controls: "gamemodes_Controls_3mb2k",
        TimelineScrollContainer: "gamemodes_TimelineScrollContainer_2AO8D",
        ContentContainer: "gamemodes_ContentContainer_1RqXh",
        AbsoluteLayer: "gamemodes_AbsoluteLayer_3QmvO",
        HideOverflow: "gamemodes_HideOverflow_1goyR",
        RelativeLayer: "gamemodes_RelativeLayer_3jSxE",
        WithPointerEvents: "gamemodes_WithPointerEvents_szEfh",
        RecordingDecorators: "gamemodes_RecordingDecorators_3P6oP",
        ClipDecorators: "gamemodes_ClipDecorators_2XyFM",
        GameModes: "gamemodes_GameModes_3Ut9P",
        DateDecorator: "gamemodes_DateDecorator_3YVVo",
        BackgroundTicks: "gamemodes_BackgroundTicks_tBpGy",
        Highlights: "gamemodes_Highlights_YTgZZ",
        Timestamps: "gamemodes_Timestamps_2ZW-4",
        RangeSelector: "gamemodes_RangeSelector_3CzcB",
        SeekScrubber: "gamemodes_SeekScrubber_2ze2f",
        PlayHead: "gamemodes_PlayHead_1NeZL",
        GameModeMarker: "gamemodes_GameModeMarker_2axJa",
        Playing: "gamemodes_Playing_2xUFa",
        Staging: "gamemodes_Staging_2Sw_C",
        Menus: "gamemodes_Menus_1x_n7",
        Unspecified: "gamemodes_Unspecified_MPJuS",
      };
    },
    85540: (e) => {
      e.exports = {
        LoadingTimeline: "highlights_LoadingTimeline_sb7yY",
        ScrollAndControlsCtn: "highlights_ScrollAndControlsCtn_1RtbZ",
        Controls: "highlights_Controls_3aQw3",
        TimelineScrollContainer: "highlights_TimelineScrollContainer_1DYx0",
        ContentContainer: "highlights_ContentContainer_3bI7o",
        AbsoluteLayer: "highlights_AbsoluteLayer_My3fU",
        HideOverflow: "highlights_HideOverflow_8_D6v",
        RelativeLayer: "highlights_RelativeLayer_1jOZC",
        WithPointerEvents: "highlights_WithPointerEvents_151i5",
        RecordingDecorators: "highlights_RecordingDecorators_2ljWd",
        ClipDecorators: "highlights_ClipDecorators_w7v-G",
        GameModes: "highlights_GameModes_1B9gv",
        DateDecorator: "highlights_DateDecorator_7JUrE",
        BackgroundTicks: "highlights_BackgroundTicks_1EkxN",
        Highlights: "highlights_Highlights_3tKtB",
        Timestamps: "highlights_Timestamps_1xidT",
        RangeSelector: "highlights_RangeSelector_3lOkM",
        SeekScrubber: "highlights_SeekScrubber_PoPV5",
        PlayHead: "highlights_PlayHead_1i_vM",
        RangeCtn: "highlights_RangeCtn_283NJ",
        RangeControls: "highlights_RangeControls_35TYa",
        InactiveRangeCtn: "highlights_InactiveRangeCtn_y_aFD",
        RangeControl: "highlights_RangeControl_rg9-W",
        RangeIcon: "highlights_RangeIcon_3iIaT",
        RangeSelectorCtn: "highlights_RangeSelectorCtn_1cuH_",
        Active: "highlights_Active_ahpcF",
        InactiveSelectedRangeControl:
          "highlights_InactiveSelectedRangeControl_1IiJm",
        SelectedRangeMask: "highlights_SelectedRangeMask_1Ukhf",
        HoverRangePreviewCtn: "highlights_HoverRangePreviewCtn_1_DFf",
        Show: "highlights_Show_15hXc",
        RangePreview: "highlights_RangePreview_5PJkh",
        TrackRangeControls: "highlights_TrackRangeControls_11g6H",
        Left: "highlights_Left_1fuwA",
        RangeMask: "highlights_RangeMask_6B4TJ",
        FullMask: "highlights_FullMask_1vdKH",
        RangeSelectionFloatingControls:
          "highlights_RangeSelectionFloatingControls_1rzkJ",
        FloatingControlsButton: "highlights_FloatingControlsButton_30PBr",
        Disabled: "highlights_Disabled_2yg9d",
        TimelineMarkerCtn: "highlights_TimelineMarkerCtn_29Mte",
        TimelineMarker: "highlights_TimelineMarker_1PIad",
        TimelineMarkerDropLine: "highlights_TimelineMarkerDropLine_3Vhs4",
        TimelineMarkerRangeMarker: "highlights_TimelineMarkerRangeMarker_23IIP",
        ToolTipSource: "highlights_ToolTipSource_3wrKj",
        TooltipContainer: "highlights_TooltipContainer_1KdnX",
        Timestamp: "highlights_Timestamp_35fXc",
        TooltipHighlight: "highlights_TooltipHighlight_24dSV",
        HighlightIcon: "highlights_HighlightIcon_9j13W",
        HighlightInfoBlock: "highlights_HighlightInfoBlock_V1fsH",
        HighlightTitle: "highlights_HighlightTitle_2EFGh",
        HighlightDesc: "highlights_HighlightDesc_16ny8",
        ThumbnailContainer: "highlights_ThumbnailContainer_1thNt",
      };
    },
    58422: (e) => {
      e.exports = {
        PlayheadInteractionCtn: "playhead_PlayheadInteractionCtn_RDoh7",
        ActiveCtn: "playhead_ActiveCtn_mRa9P",
        PlayHeadContainer: "playhead_PlayHeadContainer_PDJC8",
        Active: "playhead_Active_1C7Oa",
        PlayHeadContent: "playhead_PlayHeadContent_3Hv8o",
        PlayHeadCurrentTimeContainer:
          "playhead_PlayHeadCurrentTimeContainer_3vMod",
        Show: "playhead_Show_zd20V",
        PlayHead: "playhead_PlayHead_QEZCb",
      };
    },
    83047: (e) => {
      e.exports = {
        LoadingTimeline: "rangeselector_LoadingTimeline_1jZyX",
        ScrollAndControlsCtn: "rangeselector_ScrollAndControlsCtn_3BMP0",
        Controls: "rangeselector_Controls_3bo-v",
        TimelineScrollContainer: "rangeselector_TimelineScrollContainer_3fj6B",
        ContentContainer: "rangeselector_ContentContainer_3WodS",
        AbsoluteLayer: "rangeselector_AbsoluteLayer_1Q33W",
        HideOverflow: "rangeselector_HideOverflow_22Yk1",
        RelativeLayer: "rangeselector_RelativeLayer_3lWuc",
        WithPointerEvents: "rangeselector_WithPointerEvents_2x9rK",
        RecordingDecorators: "rangeselector_RecordingDecorators_2Ri1V",
        ClipDecorators: "rangeselector_ClipDecorators_1s80y",
        GameModes: "rangeselector_GameModes_ebeBY",
        DateDecorator: "rangeselector_DateDecorator_eYEfF",
        BackgroundTicks: "rangeselector_BackgroundTicks_YsZlm",
        Highlights: "rangeselector_Highlights_2fRvO",
        Timestamps: "rangeselector_Timestamps_27RGd",
        RangeSelector: "rangeselector_RangeSelector_162QY",
        SeekScrubber: "rangeselector_SeekScrubber_1VmX4",
        PlayHead: "rangeselector_PlayHead_23Doj",
        RangeCtn: "rangeselector_RangeCtn_3f_8F",
        RangeControls: "rangeselector_RangeControls_1eWoh",
        InactiveRangeCtn: "rangeselector_InactiveRangeCtn_1hSVa",
        RangeControl: "rangeselector_RangeControl_2mPhA",
        RangeIcon: "rangeselector_RangeIcon_H6D9V",
        RangeSelectorCtn: "rangeselector_RangeSelectorCtn_1-ZAa",
        Active: "rangeselector_Active_3Cmth",
        InactiveSelectedRangeControl:
          "rangeselector_InactiveSelectedRangeControl_35iQJ",
        SelectedRangeMask: "rangeselector_SelectedRangeMask_e5WBn",
        HoverRangePreviewCtn: "rangeselector_HoverRangePreviewCtn_SP1zJ",
        Show: "rangeselector_Show_1v0p-",
        RangePreview: "rangeselector_RangePreview_3xBB_",
        TrackRangeControls: "rangeselector_TrackRangeControls_2GUCw",
        Left: "rangeselector_Left_1wCmX",
        RangeMask: "rangeselector_RangeMask_A951h",
        FullMask: "rangeselector_FullMask_EAr6M",
        RangeSelectionFloatingControls:
          "rangeselector_RangeSelectionFloatingControls_3b6gC",
        FloatingControlsButton: "rangeselector_FloatingControlsButton_20ufi",
        Disabled: "rangeselector_Disabled_1h3Sz",
      };
    },
    90722: (e) => {
      e.exports = {
        LoadingTimeline: "recordingdecorator_LoadingTimeline_2UnYK",
        ScrollAndControlsCtn: "recordingdecorator_ScrollAndControlsCtn_OiNEg",
        Controls: "recordingdecorator_Controls_3Rmgs",
        TimelineScrollContainer:
          "recordingdecorator_TimelineScrollContainer_ObEiF",
        ContentContainer: "recordingdecorator_ContentContainer_2PJ5K",
        AbsoluteLayer: "recordingdecorator_AbsoluteLayer_2s8Of",
        HideOverflow: "recordingdecorator_HideOverflow_2jvQn",
        RelativeLayer: "recordingdecorator_RelativeLayer_2p_iP",
        WithPointerEvents: "recordingdecorator_WithPointerEvents_2V9SP",
        RecordingDecorators: "recordingdecorator_RecordingDecorators_3FIfp",
        ClipDecorators: "recordingdecorator_ClipDecorators_3CDC9",
        GameModes: "recordingdecorator_GameModes_1MGXg",
        DateDecorator: "recordingdecorator_DateDecorator_29slA",
        BackgroundTicks: "recordingdecorator_BackgroundTicks_1qBhc",
        Highlights: "recordingdecorator_Highlights_3ztWs",
        Timestamps: "recordingdecorator_Timestamps_1kRHw",
        RangeSelector: "recordingdecorator_RangeSelector_NdYLh",
        SeekScrubber: "recordingdecorator_SeekScrubber_AUPyQ",
        PlayHead: "recordingdecorator_PlayHead_3rm6B",
        RecordingDecorator: "recordingdecorator_RecordingDecorator_QLJH4",
      };
    },
    92310: (e) => {
      e.exports = {
        thumbnailWidth: "200",
        LoadingTimeline: "seekscrubber_LoadingTimeline_dGjnj",
        ScrollAndControlsCtn: "seekscrubber_ScrollAndControlsCtn_fHO8b",
        Controls: "seekscrubber_Controls_2Gtqj",
        TimelineScrollContainer: "seekscrubber_TimelineScrollContainer_2qTzJ",
        ContentContainer: "seekscrubber_ContentContainer_29wfn",
        AbsoluteLayer: "seekscrubber_AbsoluteLayer_SvhOc",
        HideOverflow: "seekscrubber_HideOverflow_1cd0L",
        RelativeLayer: "seekscrubber_RelativeLayer_1DNZ_",
        WithPointerEvents: "seekscrubber_WithPointerEvents_J4Q3f",
        RecordingDecorators: "seekscrubber_RecordingDecorators_1Hicx",
        ClipDecorators: "seekscrubber_ClipDecorators_2eEzj",
        GameModes: "seekscrubber_GameModes_oyZ_y",
        DateDecorator: "seekscrubber_DateDecorator_VJPXr",
        BackgroundTicks: "seekscrubber_BackgroundTicks_3Fdr3",
        Highlights: "seekscrubber_Highlights_2f-WJ",
        Timestamps: "seekscrubber_Timestamps_2jJ78",
        RangeSelector: "seekscrubber_RangeSelector_1ED6u",
        SeekScrubber: "seekscrubber_SeekScrubber_1_oM_",
        PlayHead: "seekscrubber_PlayHead_ykSFj",
        PlayheadInteractionCtn: "seekscrubber_PlayheadInteractionCtn_1oH3S",
        ActiveCtn: "seekscrubber_ActiveCtn_3oet5",
        PlayHeadContainer: "seekscrubber_PlayHeadContainer_17PRn",
        Active: "seekscrubber_Active_2KcgL",
        PlayHeadContent: "seekscrubber_PlayHeadContent_36jZY",
        PlayHeadCurrentTimeContainer:
          "seekscrubber_PlayHeadCurrentTimeContainer_184R3",
        Show: "seekscrubber_Show_20CY0",
        RangeCtn: "seekscrubber_RangeCtn_1-9u5",
        RangeControls: "seekscrubber_RangeControls_FzAnV",
        InactiveRangeCtn: "seekscrubber_InactiveRangeCtn_3vxTR",
        RangeControl: "seekscrubber_RangeControl_27Uqd",
        RangeIcon: "seekscrubber_RangeIcon_1pb95",
        RangeSelectorCtn: "seekscrubber_RangeSelectorCtn_3bdm3",
        InactiveSelectedRangeControl:
          "seekscrubber_InactiveSelectedRangeControl_2byyh",
        SelectedRangeMask: "seekscrubber_SelectedRangeMask_1TpL9",
        HoverRangePreviewCtn: "seekscrubber_HoverRangePreviewCtn_2n27d",
        RangePreview: "seekscrubber_RangePreview_1ELS0",
        TrackRangeControls: "seekscrubber_TrackRangeControls_33ooe",
        Left: "seekscrubber_Left_12LBv",
        RangeMask: "seekscrubber_RangeMask_1WtTn",
        FullMask: "seekscrubber_FullMask_2Nu8Y",
        RangeSelectionFloatingControls:
          "seekscrubber_RangeSelectionFloatingControls_n4r_h",
        FloatingControlsButton: "seekscrubber_FloatingControlsButton_TvO6P",
        Disabled: "seekscrubber_Disabled_2GkLo",
        ZoomRangePreview: "seekscrubber_ZoomRangePreview_1DHUL",
        Hidden: "seekscrubber_Hidden_3JE0U",
        GhostPlayheadCtn: "seekscrubber_GhostPlayheadCtn_efeV_",
        GhostPlayheadContent: "seekscrubber_GhostPlayheadContent_1JmPz",
        GhostPlayhead: "seekscrubber_GhostPlayhead_2TbCq",
        GhostPlayheadTooltip: "seekscrubber_GhostPlayheadTooltip_2eqfw",
        SeekTimeContainer: "seekscrubber_SeekTimeContainer_6-9F-",
        timelineFadeIn: "seekscrubber_timelineFadeIn_2eLFd",
      };
    },
    84174: (e) => {
      e.exports = {
        MenuItem: "timelinecontextmenu_MenuItem_3kdHy",
        AddUserMarker: "timelinecontextmenu_AddUserMarker_E9Gc9",
        StartEndClip: "timelinecontextmenu_StartEndClip_x_Xf0",
      };
    },
    15352: (e) => {
      e.exports = {
        LoadingTimeline: "timestamps_LoadingTimeline_I8lCT",
        ScrollAndControlsCtn: "timestamps_ScrollAndControlsCtn_2csgI",
        Controls: "timestamps_Controls_2dCGB",
        TimelineScrollContainer: "timestamps_TimelineScrollContainer_37S_R",
        ContentContainer: "timestamps_ContentContainer_2YtcD",
        AbsoluteLayer: "timestamps_AbsoluteLayer_SCBbw",
        HideOverflow: "timestamps_HideOverflow_3R5sC",
        RelativeLayer: "timestamps_RelativeLayer_1aN6X",
        WithPointerEvents: "timestamps_WithPointerEvents_3Pm2m",
        RecordingDecorators: "timestamps_RecordingDecorators_1NIuI",
        ClipDecorators: "timestamps_ClipDecorators_14X6e",
        GameModes: "timestamps_GameModes_3Eki-",
        DateDecorator: "timestamps_DateDecorator_1Em4P",
        BackgroundTicks: "timestamps_BackgroundTicks_z1eZI",
        Highlights: "timestamps_Highlights_1wVcI",
        Timestamps: "timestamps_Timestamps_rywDX",
        RangeSelector: "timestamps_RangeSelector_10jtX",
        SeekScrubber: "timestamps_SeekScrubber_k2RBd",
        PlayHead: "timestamps_PlayHead_nu0fs",
        TimelineRelativeTimestampContainer:
          "timestamps_TimelineRelativeTimestampContainer_3JmIk",
        TimelineRelativeTimestamp: "timestamps_TimelineRelativeTimestamp_3_QYB",
      };
    },
    94580: (e) => {
      e.exports = {
        ZoomControls: "zoomcontrol_ZoomControls_f2gx_",
        ZoomTooltipCtn: "zoomcontrol_ZoomTooltipCtn_22C_i",
        ZoomIcon: "zoomcontrol_ZoomIcon_13Dum",
        Disabled: "zoomcontrol_Disabled_S6tVK",
        ResolutionCtn: "zoomcontrol_ResolutionCtn_QNyKn",
        ResolutionFill: "zoomcontrol_ResolutionFill_2yThW",
      };
    },
    1345: (e) => {
      e.exports = {
        UserSelectionButton: "userselectioncontrols_UserSelectionButton_3irz5",
        AddUserMarker: "userselectioncontrols_AddUserMarker_3Rc_v",
        StartClipRange: "userselectioncontrols_StartClipRange_lZppc",
        EndClipRange: "userselectioncontrols_EndClipRange_2AbDS",
        InlineClipControl: "userselectioncontrols_InlineClipControl_2wm_V",
      };
    },
    97578: (e, t, r) => {
      "use strict";
      r.d(t, { F0: () => o, Zb: () => s, aF: () => l, hB: () => a });
      const n = new (r(50454).s)("GR");
      function i(e) {
        return (...t) => {
          const r = `[${(performance.now() / 1e3).toFixed(3)}]`;
          e(r, ...t);
        };
      }
      const a = i(n.Debug),
        l = (i(n.Info), i(n.Warning)),
        o = i(n.Error),
        s = a;
    },
    55385: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => w });
      var n = r(89526),
        i = r(19304),
        a = r(71488),
        l = r.n(a),
        o = r(77822),
        s = r(83315),
        c = r(14826),
        m = r(77613),
        d = r(50454),
        u = r(87195),
        h = r(33940),
        _ = r(16826),
        f = r(818),
        g = r(84343),
        S = r(25733),
        b = r.n(S),
        v = r(57605),
        P = r(88199),
        p = r(60161);
      function M(e) {
        let { refContainer: t, visible: r } = e;
        const a = (0, m.we)(),
          l = a.GetGameRecordingVideo(),
          [o, c] = (0, n.useState)(!1),
          d = (0, s.SZ)(() => l.IsPaused());
        return l
          ? n.createElement(
              "div",
              {
                className: (0, i.Z)(
                  b().PlaybackControls,
                  (r || o || d) && b().Show,
                ),
              },
              n.createElement(
                "div",
                { className: b().UserSelectionControls },
                n.createElement(P.QY, null),
                n.createElement(P.mp, null),
                n.createElement(P.a7, null),
              ),
              n.createElement(C, { playbackCoordinator: a, setPinOpen: c }),
              n.createElement(
                "div",
                { className: b().MuteMaxButtons },
                n.createElement(B, { player: l, setPinOpen: c }),
                n.createElement(E, { player: l }),
                n.createElement(O, { refContainer: t }),
              ),
            )
          : n.createElement("div", { className: b().PlaybackControls });
      }
      function C(e) {
        const { playbackCoordinator: t, setPinOpen: r } = e,
          a = t.GetGameRecordingVideo(),
          l = (0, i.Z)(b().PlaybackControlsBar),
          o = (0, s.SZ)(() => a.IsPaused());
        return n.createElement(
          "div",
          { className: l },
          n.createElement(R, { playbackCoordinator: t }),
          o && n.createElement(k, { playbackCoordinator: t }),
          n.createElement(T, { player: a }),
          o && n.createElement(G, { playbackCoordinator: t }),
          n.createElement(X, { playbackCoordinator: t }),
        );
      }
      function y(e) {
        let { className: t, tooltip: r, onClick: a, children: l } = e,
          o =
            ((0, h._T)(e, ["className", "tooltip", "onClick", "children"]),
            (0, i.Z)(b().PlaybackButton, t));
        return n.createElement(
          g.HP,
          { toolTipContent: r },
          n.createElement(
            "div",
            {
              className: o,
              onClick: (e) => {
                a(e), e.stopPropagation();
              },
            },
            l,
          ),
        );
      }
      function T(e) {
        const { player: t } = e,
          r = (0, s.SZ)(() => t.IsPaused()),
          i = r ? n.createElement(f.o1, null) : n.createElement(f.fp, null);
        let a = (0, c.Xx)(
          r ? "#Playback_Play_Tooltip" : "#Playback_Pause_Tooltip",
        );
        return n.createElement(
          y,
          {
            className: b().CircleButtonLarge,
            onClick: () => t.TogglePlayPause(),
            tooltip: a,
          },
          n.createElement("div", { className: b().PlaybackButtonContents }, i),
        );
      }
      function k(e) {
        var t;
        const { playbackCoordinator: r } = e,
          i = null !== (t = e.ms) && void 0 !== t ? t : 100;
        return n.createElement(
          y,
          {
            onClick: function () {
              r.SeekDeltaMS(-i);
            },
            className: b().CircleButtonMedium,
            tooltip: (0, c.Xx)("#Playback_PrevFrame_Tooltip"),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            n.createElement(f.xg, null),
          ),
        );
      }
      function G(e) {
        var t;
        const { playbackCoordinator: r } = e,
          i = null !== (t = e.ms) && void 0 !== t ? t : 100;
        return n.createElement(
          y,
          {
            onClick: function () {
              r.SeekDeltaMS(i);
            },
            className: b().CircleButtonMedium,
            tooltip: (0, c.Xx)("#Playback_NextFrame_Tooltip"),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            n.createElement(f.LF, null),
          ),
        );
      }
      function R(e) {
        var t;
        const { playbackCoordinator: r } = e,
          a = null !== (t = e.ms) && void 0 !== t ? t : 1e4;
        const l = `-${a / 1e3}s`;
        return n.createElement(
          y,
          {
            onClick: function () {
              r.SeekDeltaMS(-a);
            },
            className: (0, i.Z)(b().CircleButtonMedium, b().JumpButton),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            n.createElement(f.Sg, null),
            n.createElement("span", { className: b().JumpLegend }, l),
          ),
        );
      }
      function X(e) {
        var t;
        const { playbackCoordinator: r } = e,
          a = null !== (t = e.ms) && void 0 !== t ? t : 1e4;
        const l = `+${a / 1e3}s`;
        return n.createElement(
          y,
          {
            onClick: function () {
              r.SeekDeltaMS(a);
            },
            className: (0, i.Z)(b().CircleButtonMedium, b().JumpButton),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            n.createElement(f.sR, null),
            n.createElement("span", { className: b().JumpLegend }, l),
          ),
        );
      }
      function E(e) {
        const { player: t } = e,
          r = (0, s.SZ)(() => t.GetMuted());
        return n.createElement(
          y,
          {
            onClick: function () {
              t.SetMute(!r);
            },
            className: b().CircleButtonMedium,
            tooltip: (0, c.Xx)("#Playback_ToggleMute_Tooltip"),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            r ? n.createElement(_.D1O, null) : n.createElement(_.ffh, null),
          ),
        );
      }
      function O(e) {
        const { refContainer: t } = e;
        let r = n.useCallback(() => {
          t.current && (0, p.$S)(t.current);
        }, [t]);
        return n.createElement(
          y,
          {
            onClick: r,
            className: b().CircleButtonMedium,
            tooltip: (0, c.Xx)("#Playback_FullScreen_Tooltip"),
          },
          n.createElement(
            "div",
            { className: b().PlaybackButtonContents },
            " ",
            n.createElement(f.IT, null),
          ),
        );
      }
      function B(e) {
        const { player: t, setPinOpen: r } = e,
          i = n.useMemo(
            () => [
              { data: 0.25, label: "0.25x" },
              { data: 1, label: "1x" },
              { data: 2, label: "2x" },
            ],
            [],
          );
        return n.createElement(v.ry, {
          strClassName: b().SpeedDrop,
          rgOptions: i,
          selectedOption: t.GetPlaybackSpeed(),
          onChange: (e) => t.SetPlaybackSpeed(e.data),
          tooltip: (0, c.Xx)("#Playback_Speed_Tooltip"),
          onMenuOpened: () => r(!0),
          onMenuClose: () => r(!1),
        });
      }
      function w(e) {
        const { disableSound: t } = e,
          r = (0, m.we)(),
          a = (0, o.e4)(r.StopPlayback, r.SetVideoElement),
          c = r.GetGameRecordingVideo(),
          d = (0, s.SZ)(() => r.GetRecordingID()),
          u = (0, s.SZ)(() => c.GetPlaybackError()) || !d,
          [h, _] = (function () {
            const [e, t] = n.useState(!1),
              r = n.useRef(null);
            let i = n.useCallback(
                (e) => {
                  r.current && (clearTimeout(r.current), (r.current = void 0)),
                    e
                      ? t(!0)
                      : (r.current = window.setTimeout(() => t(!1), 800));
                },
                [r, t],
              ),
              a = n.useCallback(() => {
                i(!0);
              }, [i]),
              l = n.useCallback(() => {
                i(!1);
              }, [i]);
            return (
              n.useEffect(() => () => clearTimeout(r.current), []),
              [e, { enter: a, leave: l, move: a }]
            );
          })(),
          f = n.useRef();
        let g = (0, i.Z)(l().GameRecordingPlayer, u && l().NoVideo);
        return n.createElement(
          "div",
          {
            ref: f,
            className: g,
            onClick: function () {
              r.TogglePlayPause();
            },
            onMouseEnter: _.enter,
            onMouseLeave: _.leave,
            onMouseMove: _.move,
          },
          n.createElement("video", { ref: a, controls: !1, muted: t }),
          n.createElement(F, { player: c }),
          n.createElement(I, null),
          n.createElement(D, null),
          d && n.createElement(M, { refContainer: f, visible: h }),
          !d && n.createElement(L, null),
        );
      }
      function I() {
        const e = (0, m.we)(),
          t = d.c.Get().IsDebugLogEnabled("GR"),
          r = (0, s.SZ)(() => e.GetPlaybackStats());
        return t && r
          ? n.createElement(
              "div",
              { className: l().PerfCtnVideo },
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Average Seek MS: "),
                n.createElement("span", null, r.nMean.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "StdDev Seek MS: "),
                n.createElement("span", null, r.nStdDev.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Slowest Seek MS: "),
                n.createElement("span", null, r.nMax.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Fastest Seek MS: "),
                n.createElement("span", null, r.nMin.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "# Seeks: "),
                n.createElement("span", null, r.nLength),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Last Val: "),
                n.createElement("span", null, r.nLastVal.toFixed(3)),
              ),
            )
          : null;
      }
      function D() {
        const e = d.c.Get().IsDebugLogEnabled("GR"),
          t = (0, m.we)(),
          r =
            ((0, s.SZ)(() => {
              t.GetCurrentPlaybackGlobalMS();
            }),
            (0, u.wn)());
        return e && r
          ? n.createElement(
              "div",
              { className: l().PerfCtnThumbnails },
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Avg Thumbnail Load MS: "),
                n.createElement("span", null, r.nMean.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "StdDev Thumbnail Load MS: "),
                n.createElement("span", null, r.nStdDev.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Slowest Thumbnail Load MS: "),
                n.createElement("span", null, r.nMax.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Fastest Thumbnail Load MS: "),
                n.createElement("span", null, r.nMin.toFixed(3)),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "# Loaded: "),
                n.createElement("span", null, r.nLength),
              ),
              n.createElement(
                "div",
                null,
                n.createElement("span", null, "Last Load: "),
                n.createElement("span", null, r.nLastVal.toFixed(3)),
              ),
            )
          : null;
      }
      function F(e) {
        let { player: t } = e,
          r = "";
        switch ((0, s.SZ)(() => t.GetPlaybackError())) {
          case o.qd.DownloadFailed:
          case o.qd.PlaybackError:
            r = "#GameRecording_PlayerError_Generic";
        }
        return r
          ? n.createElement(
              "div",
              { className: l().PlayerError },
              n.createElement(
                "div",
                { className: l().Text },
                (0, c.Xx)("#GameRecording_PlayerError_Generic"),
              ),
            )
          : null;
      }
      function L(e) {
        return n.createElement(
          "div",
          { className: l().PlayerError },
          n.createElement(
            "div",
            { className: l().Text },
            (0, c.Xx)("#GameRecording_PlayerNoContent"),
          ),
        );
      }
    },
    77822: (e, t, r) => {
      "use strict";
      r.d(t, { Is: () => m, e4: () => d, qd: () => n });
      var n,
        i = r(33940),
        a = r(59621),
        l = r(24141),
        o = r(85246),
        s = r(4306),
        c = r(97578);
      !(function (e) {
        (e[(e.None = 0)] = "None"),
          (e[(e.DownloadFailed = 1)] = "DownloadFailed"),
          (e[(e.PlaybackError = 2)] = "PlaybackError");
      })(n || (n = {}));
      class m {
        constructor() {
          (this.m_elVideo = null),
            (this.m_player = null),
            (this.m_listeners = new o.G_()),
            (this.m_nDownloadFailureCount = 0),
            (this.m_bPaused = !1),
            (this.m_bAtEnd = !1),
            (this.m_ePlayerError = n.None),
            (this.m_bUserInputNeeded = !1),
            (this.m_bMuted = !1),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_nPlaybackTime = 0),
            (this.m_nVideoStartTime = 0),
            (this.m_nVideoDuration = 0),
            (this.m_nVolume = 0),
            (0, a.rC)(this);
        }
        IsPaused() {
          return this.m_bPaused;
        }
        IsAtEnd() {
          return this.m_bAtEnd;
        }
        BSeekReadyToPlay() {
          return this.m_bSeekReadyToPlay;
        }
        GetPlaybackError() {
          return this.m_ePlayerError;
        }
        GetUserInputNeeded() {
          return this.m_bUserInputNeeded;
        }
        GetPlaybackTime() {
          return this.m_nPlaybackTime;
        }
        GetTimelineDuration() {
          return this.m_nVideoDuration;
        }
        GetVolume() {
          return this.m_nVolume;
        }
        GetMuted() {
          return this.m_bMuted;
        }
        GetMPDURL() {
          var e;
          return null === (e = this.m_player) || void 0 === e
            ? void 0
            : e.GetMPDURL();
        }
        Start(e, t, r) {
          var n;
          this.Stop(),
            (this.m_bAtEnd = !1),
            (this.m_elVideo = e),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userpausechange",
              this.OnUserPauseChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "playing",
              this.OnVideoPlaying,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "pause",
              this.OnVideoPause,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "timeupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "ended",
              this.OnVideoEnd,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-bufferupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-downloadfailed",
              this.OnDownloadFailed,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-playbackerror",
              this.OnPlaybackError,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userinputneeded",
              this.OnUserInputNeeded,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "waiting",
              this.OnVideoWaiting,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "volumechange",
              this.OnVolumeChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "canplay",
              this.OnCanPlay,
            ),
            (this.m_player = new l.C2(this.m_elVideo, !1)),
            this.m_player.PlayMPD(t, null, null),
            (this.m_bMuted = ((n = "muted"), h()[n])),
            this.m_player.SetMuted(this.m_bMuted),
            (this.m_bSeekReadyToPlay = !1);
          const i = `seeking_${t}_${r.toFixed(3)}`;
          (0, c.hB)(`CGameRecordingVideo:: perf mark ${i}`),
            performance.mark(i),
            this.m_player.Seek(r, l.tA.FromAvailableStart),
            (this.m_bPaused = this.m_player.IsPaused());
        }
        Stop() {
          this.m_listeners.Unregister(),
            this.m_player && this.m_player.Close(),
            (this.m_elVideo = null),
            (this.m_player = null),
            (this.m_bPaused = !1),
            (this.m_bAtEnd = !1),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_ePlayerError = n.None),
            (this.m_bUserInputNeeded = !1),
            (this.m_nPlaybackTime = 0),
            (this.m_nVideoStartTime = 0),
            (this.m_nVideoDuration = 0);
        }
        UpdateMPD() {
          var e;
          return (0, i.mG)(this, void 0, void 0, function* () {
            yield null === (e = this.m_player) || void 0 === e
              ? void 0
              : e.UpdateMPD();
          });
        }
        IsInitialized() {
          return !!this.m_player;
        }
        OnCanPlay() {
          this.m_bSeekReadyToPlay = !0;
        }
        OnUserPauseChange() {
          this.m_bPaused = this.m_player.IsPaused();
        }
        OnVideoPlaying() {
          (this.m_nVolume = this.m_player.GetVolume()),
            (0, c.Zb)("video playing");
        }
        OnVideoPause() {
          (0, c.Zb)("video paused");
        }
        OnVideoTimeUpdate() {
          (this.m_nVideoStartTime = this.m_player.GetAvailableVideoStartTime()),
            (this.m_nVideoDuration =
              this.m_player.GetBufferedLiveEdgeTime() - this.m_nVideoStartTime),
            (this.m_nPlaybackTime =
              this.m_player.GetCurrentPlayTime() - this.m_nVideoStartTime);
        }
        OnVideoEnd() {
          (this.m_bAtEnd = !0), (0, c.Zb)("video ended");
        }
        OnDownloadFailed() {
          var e;
          return (0, i.mG)(this, void 0, void 0, function* () {
            (0, c.F0)("video download failed"),
              this.m_nDownloadFailureCount < 2
                ? (yield null === (e = this.m_player) || void 0 === e
                    ? void 0
                    : e.UpdateMPD(),
                  this.m_nDownloadFailureCount++)
                : (this.m_ePlayerError = n.DownloadFailed);
          });
        }
        OnPlaybackError() {
          (0, c.F0)("video playback error"),
            (this.m_ePlayerError = n.PlaybackError);
        }
        OnUserInputNeeded() {
          this.m_bUserInputNeeded = !0;
        }
        OnVolumeChange() {
          (0, c.Zb)("volume change"),
            (this.m_nVolume = this.m_player.GetVolume());
        }
        OnVideoWaiting() {
          this.GetTimelineDuration() - this.GetPlaybackTime() < 1 &&
            (this.m_bAtEnd = !0);
        }
        UserInputReceived() {
          this.IsInitialized() &&
            ((this.m_bUserInputNeeded = !1), this.m_player.SeekAndPlay(0));
        }
        SetVolume(e) {
          this.IsInitialized() && this.m_player.SetVolume(e);
        }
        SetMute(e) {
          this.IsInitialized() && this.m_player.SetMuted(e),
            (this.m_bMuted = e),
            (function (e, t) {
              let r = h();
              r[e] = t;
              let n = JSON.stringify(r);
              window.localStorage.setItem("gameRecordingPlayer", n);
            })("muted", e);
        }
        TogglePlayPause() {
          this.IsInitialized() &&
            (this.m_player.IsPaused() ? this.Play() : this.Pause());
        }
        Play() {
          this.IsInitialized() && this.m_player.Play();
        }
        Pause() {
          this.IsInitialized() && this.m_player.Pause();
        }
        SetPlaybackSpeed(e) {
          this.IsInitialized() && (this.m_elVideo.playbackRate = e);
        }
        GetPlaybackSpeed() {
          return this.IsInitialized() ? this.m_elVideo.playbackRate : 1;
        }
        Seek(e) {
          if (!this.IsInitialized()) return;
          const t = `seeking_${this.m_player.GetMPDURL()}_${e.toFixed(3)}`;
          (this.m_bSeekReadyToPlay = !1),
            performance.mark(t),
            (0, c.hB)(`CGameRecordingVideo:: perf mark ${t}`),
            (0, c.hB)(`CGameRecordingVideo::Seek to ${e}`),
            (this.m_nPlaybackTime = e),
            this.m_player.Seek(e, l.tA.FromAvailableStart);
        }
      }
      function d(e, t) {
        return (0, s.xK)((r) => (t(r), () => e()), [t]);
      }
      let u;
      function h() {
        if (!u) {
          let e,
            t = window.localStorage.getItem("gameRecordingPlayer") || "{}";
          try {
            e = JSON.parse(t);
          } catch (t) {
            e = {};
          }
          u = { muted: e.muted || !1 };
        }
        return u;
      }
      (0, i.gn)([a.LO], m.prototype, "m_bPaused", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_bAtEnd", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_ePlayerError", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_bUserInputNeeded", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_bMuted", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_bSeekReadyToPlay", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_nPlaybackTime", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_nVideoStartTime", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_nVideoDuration", void 0),
        (0, i.gn)([a.LO], m.prototype, "m_nVolume", void 0),
        (0, i.gn)([s.ak], m.prototype, "OnCanPlay", null),
        (0, i.gn)([s.ak], m.prototype, "OnUserPauseChange", null),
        (0, i.gn)([s.ak], m.prototype, "OnVideoPlaying", null),
        (0, i.gn)([s.ak], m.prototype, "OnVideoPause", null),
        (0, i.gn)([s.ak], m.prototype, "OnVideoTimeUpdate", null),
        (0, i.gn)([s.ak], m.prototype, "OnVideoEnd", null),
        (0, i.gn)([s.ak], m.prototype, "OnDownloadFailed", null),
        (0, i.gn)([s.ak], m.prototype, "OnPlaybackError", null),
        (0, i.gn)([s.ak], m.prototype, "OnUserInputNeeded", null),
        (0, i.gn)([s.ak], m.prototype, "OnVolumeChange", null),
        (0, i.gn)([s.ak], m.prototype, "OnVideoWaiting", null),
        (0, i.gn)([s.ak], m.prototype, "UserInputReceived", null);
    },
    87195: (e, t, r) => {
      "use strict";
      r.d(t, { sC: () => g, wn: () => f });
      var n = r(33940),
        i = r(89526),
        a = r(58218),
        l = r(23801),
        o = r(44973),
        s = r(97578),
        c = r(65689),
        m = r(77613),
        d = r(4306);
      class u {
        constructor() {
          (this.k_QueueWaitUntilRequestMS = 10),
            (this.k_nMaxBatchSize = 50),
            (this.m_mapPromises = new Map()),
            (this.m_mapThumbnailImages = new Map()),
            (this.m_rgPendingRequest = new Array()),
            (this.m_PendingInfoResolve = void 0),
            (this.m_PendingTimer = void 0),
            (this.k_AlreadyResolvedOK = Promise.resolve(!0)),
            (this.m_rgThumbnailPerf = []);
        }
        AddPerfMeasure(e) {
          this.m_rgThumbnailPerf.push(e);
        }
        GetPerfMeasures() {
          if (!this.m_rgThumbnailPerf.length) return null;
          const e = this.m_rgThumbnailPerf.length,
            t = this.m_rgThumbnailPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgThumbnailPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            n = Math.max(...this.m_rgThumbnailPerf),
            i = Math.min(...this.m_rgThumbnailPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: n,
            nMin: i,
            nLength: e,
            nLastVal: this.m_rgThumbnailPerf[e - 1],
          };
        }
        GetKey(e, t, r, n) {
          return `${e}_${n ? t : t - (t % 9e3)}_${r}_${n}`;
        }
        GetThumbnail(e, t, r, n) {
          if (!e) return;
          const i = this.GetKey(e, t, r, n);
          return this.m_mapThumbnailImages.get(i);
        }
        QueueThumbnailRequest(e, t, r, n) {
          const i = this.GetKey(e, t, r, n);
          if (this.m_mapThumbnailImages.get(i)) return this.k_AlreadyResolvedOK;
          this.m_PendingInfoPromise &&
            (this.m_rgPendingRequest[0].strRecordingID != e ||
              this.m_rgPendingRequest.length > this.k_nMaxBatchSize) &&
            (this.m_PendingTimer && window.clearTimeout(this.m_PendingTimer),
            this.FlushPendingInfo()),
            (this.m_PendingInfoPromise &&
              this.m_rgPendingRequest[0].strRecordingID == e) ||
              ((this.m_PendingInfoPromise = new Promise(
                (e) => (this.m_PendingInfoResolve = e),
              )),
              (this.m_PendingTimer = window.setTimeout(
                () => this.FlushPendingInfo(),
                this.k_QueueWaitUntilRequestMS,
              )));
          const a = {
            strRecordingID: e,
            nRecordingOffsetMS: t,
            cPxMajorAxis: r,
            bPreciseTiming: n,
          };
          return (
            this.m_rgPendingRequest.some((e) => {
              return (
                (r = a),
                (t = e).strRecordingID === r.strRecordingID &&
                  t.nRecordingOffsetMS === r.nRecordingOffsetMS &&
                  t.cPxMajorAxis === r.cPxMajorAxis &&
                  t.bPreciseTiming == r.bPreciseTiming
              );
              var t, r;
            }) ||
              (this.m_rgPendingRequest.push(a),
              this.m_mapPromises.set(i, this.m_PendingInfoPromise)),
            this.m_PendingInfoPromise
          );
        }
        FlushPendingInfo() {
          return (0, n.mG)(this, void 0, void 0, function* () {
            if (void 0 === this.m_PendingInfoResolve) return;
            const e = this.m_PendingInfoResolve,
              t = this.m_rgPendingRequest;
            (this.m_PendingInfoPromise = void 0),
              (this.m_PendingInfoResolve = void 0),
              (this.m_rgPendingRequest = []),
              (this.m_PendingTimer = void 0),
              yield this.InternalLoadMultipleThumbnails(t),
              e();
          });
        }
        InternalLoadMultipleThumbnails(e) {
          return (0, n.mG)(this, void 0, void 0, function* () {
            e.sort((e, t) => e.nRecordingOffsetMS - t.nRecordingOffsetMS);
            try {
              const t = e.map((e) => 1e3 * e.nRecordingOffsetMS),
                r = yield (0, c.no)(
                  e[0].strRecordingID,
                  void 0,
                  t,
                  e[0].cPxMajorAxis,
                  e[0].bPreciseTiming,
                );
              (0, l.X)(
                (null == r ? void 0 : r.length) == t.length,
                `CThumbnailCache.InternalLoadMultipleThumbnails request ${
                  t.length
                } and got back ${null == r ? void 0 : r.length}`,
              );
              for (
                let n = 0;
                n < t.length && n < (null == r ? void 0 : r.length);
                ++n
              ) {
                const t = e[n],
                  i = this.GetKey(
                    t.strRecordingID,
                    t.nRecordingOffsetMS,
                    t.cPxMajorAxis,
                    e[0].bPreciseTiming,
                  );
                this.m_mapThumbnailImages.set(i, null == r ? void 0 : r[n]);
              }
            } catch (e) {
              (0, s.F0)("Failed to load multiple request thumbnails", e);
            }
          });
        }
        LoadThumbnail(e, t, r, i) {
          return (0, n.mG)(this, void 0, void 0, function* () {
            const n = this.GetKey(e, t, r, i);
            return (
              !!this.m_mapThumbnailImages.get(n) ||
              (this.m_mapPromises.has(n) ||
                this.m_mapPromises.set(
                  n,
                  this.InternalLoadThumbnail(e, t, r, i),
                ),
              this.m_mapPromises.get(n))
            );
          });
        }
        InternalLoadThumbnail(e, t, r, i) {
          return (0, n.mG)(this, void 0, void 0, function* () {
            try {
              const n = yield (0, c.no)(e, void 0, [1e3 * t], r, i);
              if ((null == n ? void 0 : n.length) > 0) {
                const a = this.GetKey(e, t, r, i);
                return this.m_mapThumbnailImages.set(a, n[0]), !0;
              }
              (0, s.aF)(
                `ThumbnailImage: got empty jpeg ${n.length} list back  ${e} @ ${t}`,
              );
            } catch (r) {
              (0, s.F0)(
                `ThumbnailImage: Fail to load thumbnail ${e} @ ${t} with ${r}`,
              );
            }
            return !1;
          });
        }
        static Get() {
          return (
            u.s_Singleton ||
              ((u.s_Singleton = new u()),
              "dev" == o.De.WEB_UNIVERSE &&
                (window.g_ThumbnailCache = u.s_Singleton)),
            u.s_Singleton
          );
        }
      }
      function h(e, t) {
        const r = (0, m.we)();
        return (0, i.useMemo)(
          () =>
            r.BInitialized()
              ? e != r.GetGameID()
                ? ((0, l.X)(!1, `Game ID don't match ${e} != ${r.GetGameID()}`),
                  null)
                : r.ConvertGlobaOffsetToRecordingAndRelativeOffset(t)
              : null,
          [e, t, r],
        );
      }
      function _(e) {
        var t;
        const r = (0, i.useRef)(null),
          n = (0, d.NW)(),
          l = (0, a.T)("useThumbnailAsURL");
        return (
          (0, i.useEffect)(() => {
            var t;
            if (
              e &&
              !(null === (t = null == l ? void 0 : l.token) || void 0 === t
                ? void 0
                : t.reason)
            ) {
              const t = new Blob([e], { type: "image/jpeg" }),
                i = URL.createObjectURL(t);
              (r.current = i), n();
            }
            return () => {
              r.current &&
                (URL.revokeObjectURL(r.current), (r.current = void 0));
            };
          }, [
            null === (t = null == l ? void 0 : l.token) || void 0 === t
              ? void 0
              : t.reason,
            e,
            n,
          ]),
          r.current
        );
      }
      function f() {
        return u.Get().GetPerfMeasures();
      }
      function g(e, t, r, n = !0) {
        const a = h(e, t),
          [l, o] = (0, i.useState)(() =>
            u
              .Get()
              .GetThumbnail(
                null == a ? void 0 : a.strRecordingID,
                null == a ? void 0 : a.nRecordingOffsetMS,
                r,
                n,
              ),
          );
        let c = (0, d.Sd)();
        return (
          (0, i.useEffect)(() => {
            if (a && !l) {
              const t = u
                .Get()
                .GetThumbnail(
                  null == a ? void 0 : a.strRecordingID,
                  null == a ? void 0 : a.nRecordingOffsetMS,
                  r,
                  n,
                );
              if (t) o(t);
              else {
                let t = `thumbnail_${e}_${r}_${n}`;
                performance.mark(t),
                  u
                    .Get()
                    .QueueThumbnailRequest(
                      a.strRecordingID,
                      a.nRecordingOffsetMS,
                      r,
                      n,
                    )
                    .then(() => {
                      try {
                        const e = performance.measure(`measure_${t}`, t);
                        e && u.Get().AddPerfMeasure(e.duration);
                      } catch (e) {
                        (0, s.hB)(
                          `CThumbnailCache:: cant measure ${t}, error: ${e}`,
                        );
                      }
                      c() ||
                        o(
                          u
                            .Get()
                            .GetThumbnail(
                              a.strRecordingID,
                              a.nRecordingOffsetMS,
                              r,
                              n,
                            ),
                        );
                    });
              }
            }
          }, [l, r, a, t, n, c, e]),
          _(l)
        );
      }
    },
    65689: (e, t, r) => {
      "use strict";
      r.d(t, {
        $H: () => u,
        D0: () => l,
        GL: () => o,
        VA: () => d,
        Vj: () => a,
        no: () => s,
        oV: () => c,
        uI: () => m,
      });
      var n = r(33940),
        i = r(83315);
      function a(e, t) {
        return (0, n.mG)(this, void 0, void 0, function* () {
          0;
        });
      }
      function l() {
        return (0, i.SZ)(() => null);
      }
      function o(e) {
        return null;
      }
      function s(e, t, r, n, i) {
        return null;
      }
      function c() {
        return null;
      }
      function m() {
        return 0;
      }
      function d(e) {
        0;
      }
      function u(e, t) {
        return (0, i.SZ)(() => {
          0;
        });
      }
    },
    48704: (e, t, r) => {
      "use strict";
      r.d(t, {
        Kc: () => f,
        NN: () => _,
        Op: () => P,
        Uk: () => g,
        _H: () => o,
        az: () => v,
        jg: () => S,
        mo: () => b,
        n9: () => p,
        oR: () => c,
        pI: () => h,
        pT: () => u,
        q1: () => m,
        wR: () => s,
        x8: () => d,
      });
      var n = r(89526),
        i = r(50796);
      const a = { nBeforeMS: 0, nAfterMS: 12e3 },
        l = n.createContext({
          globalStartMS: void 0,
          globalEndMS: void 0,
          setRange: null,
          setStartMS: null,
          setEndMS: null,
          globalPreviewStartMS: void 0,
          globalPreviewEndMS: void 0,
          setPreviewRange: null,
          clearPreviewSelection: null,
          selectionZoomCount: 0,
          zoomIntoSelection: null,
        });
      function o() {
        const e = (0, n.useContext)(l);
        return { nGlobalStartMS: e.globalStartMS, nGlobalEndMS: e.globalEndMS };
      }
      function s() {
        return (0, n.useContext)(l).globalStartMS;
      }
      function c() {
        return (0, n.useContext)(l).globalEndMS;
      }
      function m() {
        return (0, n.useContext)(l).setRange;
      }
      function d() {
        return (0, n.useContext)(l).setStartMS;
      }
      function u() {
        return (0, n.useContext)(l).setEndMS;
      }
      function h() {
        const e = (0, n.useContext)(l);
        return {
          selectedMarker: e.selectedMarker,
          setSelectedMarker: e.setSelectedMarker,
        };
      }
      function _() {
        var e, t;
        const r = (0, n.useContext)(l);
        return (
          !isNaN(
            null === (e = r.globalStartMS) || void 0 === e ? void 0 : e.valMS,
          ) &&
          !isNaN(
            null === (t = r.globalEndMS) || void 0 === t ? void 0 : t.valMS,
          )
        );
      }
      function f() {
        return (0, n.useContext)(l).clearSelection;
      }
      function g() {
        return (0, n.useContext)(l).setPreviewRange;
      }
      function S() {
        const e = (0, n.useContext)(l);
        return {
          globalStartMS: e.globalPreviewStartMS,
          globalEndMS: e.globalPreviewEndMS,
        };
      }
      function b() {
        var e, t;
        const r = (0, n.useContext)(l);
        return (
          !isNaN(
            null === (e = r.globalPreviewStartMS) || void 0 === e
              ? void 0
              : e.valMS,
          ) &&
          !isNaN(
            null === (t = r.globalPreviewEndMS) || void 0 === t
              ? void 0
              : t.valMS,
          )
        );
      }
      function v() {
        return (0, n.useContext)(l).clearPreviewSelection;
      }
      function P(e, t) {
        const r = m(),
          l = o();
        let s = n.useCallback(
          (e, t, n) => {
            if (void 0 === t && void 0 === n) return;
            let o = t || l.nGlobalStartMS,
              s = n || l.nGlobalEndMS;
            o &&
              s &&
              s.valMS <= o.valMS &&
              (void 0 !== t ? (s = void 0) : (o = void 0));
            let c = a.nBeforeMS + a.nAfterMS;
            void 0 === o && (o = (0, i.Z6)(s.valMS - c)),
              void 0 === s && (s = (0, i.Z6)(o.valMS + c)),
              r(o, s),
              e.SetPlaybackStop(s);
          },
          [l, r],
        );
        return s;
      }
      function p(e) {
        let t = (0, n.useContext)(l),
          r = t.selectionZoomCount,
          i = t.globalStartMS,
          a = t.globalEndMS,
          o = (0, n.useRef)(r),
          s = (0, n.useRef)(null);
        (s.current = e),
          (0, n.useEffect)(() => {
            let e =
              !isNaN(null == i ? void 0 : i.valMS) &&
              !isNaN(null == a ? void 0 : a.valMS);
            (o.current == r && e) ||
              ((o.current = r), e ? s.current(i, a) : s.current(null, null));
          }, [r, i, a, o, s]);
      }
    },
    50796: (e, t, r) => {
      "use strict";
      function n(e) {
        return { type: "global", valMS: e };
      }
      function i(e) {
        return { type: "timeline", valMS: e };
      }
      function a(e) {
        return (t) => t.type === e;
      }
      r.d(t, { Z6: () => n, bu: () => l, pX: () => i, yj: () => o });
      a("global"), a("timeline"), a("recording"), a("clip");
      function l(e) {
        return { type: "global", valPX: e };
      }
      function o(e) {
        return { type: "scrollWindow", valPX: e };
      }
      function s(e) {
        return (t) => t.type === e;
      }
      s("global"), s("clientWindow"), s("virtualWindow"), s("scrollWindow");
    },
    50953: (e, t, r) => {
      "use strict";
      r.d(t, { k9: () => Dt, $z: () => It, Lj: () => wt });
      var n = r(89526),
        i = r(83315),
        a = r(11426),
        l = r(48203),
        o = r(19304),
        s = r(50796),
        c = r(33940),
        m = r(59621),
        d = r(36041),
        u = r(11837),
        h = r(97578),
        _ = r(4306);
      const f = [12e3, 7500, 4500, 3e3, 1500, 1e3, 750, 400, 250, 100],
        g = {
          12e3: 7.5,
          7500: 12,
          4500: 10,
          3e3: 15,
          1500: 10,
          1e3: 15,
          750: 10,
          400: 7.5,
          250: 12,
          100: 15,
        };
      function S(e) {
        let t = (function (e) {
          for (let t = f.length - 1; t >= 0; t--) {
            let r = f[t];
            if (r >= e) return r;
          }
          return 12e3;
        })(e);
        return g[t];
      }
      var b = r(23801),
        v = r(65689),
        P = r(48704);
      class p {
        constructor(e, t, r, n) {
          (this.m_bLoaderInitialized = !1),
            (this.m_durationMS = (0, s.Z6)(null)),
            (this.m_rgClipSummaries = []),
            (this.m_timelineIDToClipMap = new Map()),
            (this.m_nOverscanPercent = 10),
            (this.m_nGapBetweenTimelinesPX = 40),
            (this.m_scrollLeftPX = (0, s.bu)(0)),
            (this.m_scrollWindowWidth = null),
            (this.m_scrollWindowOffsetPX = null),
            (this.m_bAutoScrollPaused = !1),
            (this.m_autoScrollPauseTimeout = null),
            (this.m_nMaxAutoZoomScale = null),
            (this.m_nUserZoomScaleMS = null),
            (this.m_nCurrentZoomScaleMS = null),
            (this.m_nTempZoomScaleMS = null),
            (this.m_timelineOffsets = null),
            (this.m_loadedTimelines = new Set()),
            (0, m.rC)(this),
            (this.m_loader = e),
            (this.m_fnUnregisterFromLoader =
              this.m_loader.AddEventListener(this)),
            (this.m_fnUnregisterPlaybackCoordinator = t.AddEventListener(this)),
            (this.m_fnForceUpdate = r),
            (this.m_nUserZoomScaleMS = (0, v.uI)() || 12e3),
            (this.m_rgClipSummaries = n || []),
            e.BInitialized() && this.OnLoaderInitialized();
        }
        BInitialized() {
          return (
            this.m_bLoaderInitialized &&
            null !== this.m_scrollWindowWidth &&
            null !== this.m_timelineOffsets
          );
        }
        OnLoaderInitialized() {
          (this.m_durationMS = this.m_loader.GetGlobalTimelineEndMS()),
            this.ComputeAllUpdates(),
            (this.m_bLoaderInitialized = !0);
        }
        OnTimelineLoaded(e) {
          (0, h.Zb)("OnTimelineLoaded", e), this.m_loadedTimelines.add(e);
        }
        OnInvalidate(e) {
          (0, h.Zb)("on invalidate ", e),
            (this.m_durationMS = this.m_loader.GetGlobalTimelineEndMS()),
            this.ComputeZoomScale(),
            this.BInitialized() && e
              ? this.UpdateTimelineOffsetsFollowing(e)
              : (this.ComputeTimelineOffsets(), this.ComputeClipOffsets());
        }
        OnFocusGlobalMS(e) {
          this.ScrollToCenteredGlobalMS(e);
        }
        GetGameID() {
          return this.m_loader.GetGameID();
        }
        IsSameLoader(e) {
          return this.m_loader == e;
        }
        BIsTimelineLoaded(e) {
          return this.m_loadedTimelines.has(e);
        }
        Close() {
          this.m_fnUnregisterFromLoader && this.m_fnUnregisterFromLoader(),
            this.m_fnUnregisterPlaybackCoordinator &&
              this.m_fnUnregisterPlaybackCoordinator(),
            (this.m_fnUnregisterFromLoader = null),
            (this.m_fnUnregisterPlaybackCoordinator = null),
            (this.m_loader = null),
            (this.m_bLoaderInitialized = !1),
            this.m_autoScrollPauseTimeout && this.ClearAutoScrollPauseTimeout();
        }
        GetOverscan() {
          return this.m_nOverscanPercent;
        }
        SetOverscan(e) {
          this.m_nOverscanPercent = e;
        }
        GetCurrentZoomScale() {
          return this.m_nCurrentZoomScaleMS;
        }
        GetMaxZoomScale() {
          const e = f[0];
          return this.m_nMaxAutoZoomScale > e ? e : this.m_nMaxAutoZoomScale;
        }
        GetUserZoomScale() {
          return this.m_nUserZoomScaleMS;
        }
        SetUserZoomScale(e) {
          this.m_nCurrentZoomScaleMS !== e &&
            (this.ClearTempZoomScale(),
            (this.m_nUserZoomScaleMS = e),
            this.ComputeAllUpdates(),
            (0, v.VA)(this.m_nUserZoomScaleMS));
        }
        SetTempZoomScale(e, t) {
          let r = Math.max(e.valMS, 0),
            n = Math.min(t.valMS, this.m_durationMS.valMS),
            i = 0;
          for (let e of this.m_timelineOffsets)
            e.globalOffsetMS.valMS >= r && e.globalOffsetMS.valMS < n && i++;
          let a = this.GetTimelineGapWidth() * i,
            l = n - r,
            o = this.m_scrollWindowWidth - a;
          (this.m_nTempZoomScaleMS = l / o), this.ComputeAllUpdates();
          let c = this.ConvertGlobalMSToGlobalPXOffset((0, s.Z6)(r));
          this.ScrollToOffset(c.valPX);
        }
        ClearTempZoomScale() {
          if (null === this.m_nTempZoomScaleMS) return;
          let e = this.GetScrollFocusPX(),
            t = this.ConvertPXOffsetToClosestLessThanGlobalMS(
              (0, s.bu)(e.valPX),
            );
          (this.m_nTempZoomScaleMS = null),
            this.ComputeAllUpdates(),
            this.ScrollToCenteredGlobalMS(t);
        }
        ZoomIn(e) {
          let t =
              null !== this.m_nTempZoomScaleMS
                ? this.m_nTempZoomScaleMS
                : this.m_nUserZoomScaleMS,
            r = Math.min(t, this.m_nCurrentZoomScaleMS),
            n = f.findIndex((e) => r >= e);
          if (
            ((n = -1 == n ? f.length - 1 : n),
            f[n] == r && (n = d.Lh(n + 1, 0, f.length - 1)),
            isNaN(e))
          ) {
            const e =
              this.GetVisualWindowStartPX().valPX + 0.5 * this.GetVisualWidth();
            this.SetZoomWithFocus(f[n], e);
          } else this.SetZoomWithFocus(f[n], e);
        }
        ZoomOut(e) {
          if (this.m_nCurrentZoomScaleMS >= this.m_nMaxAutoZoomScale) return;
          let t = Math.min(this.m_nUserZoomScaleMS, this.m_nCurrentZoomScaleMS),
            r = f.findIndex((e) => t >= e);
          if (
            ((r = -1 == r ? f.length - 1 : r),
            f[r] == t && (r = d.Lh(r - 1, 0, f.length - 1)),
            isNaN(e))
          ) {
            const e =
              this.GetVisualWindowStartPX().valPX + 0.5 * this.GetVisualWidth();
            this.SetZoomWithFocus(f[r], e);
          } else this.SetZoomWithFocus(f[r], e);
        }
        SetZoomWithFocus(e, t) {
          const r = this.ConvertPXOffsetToClosestLessThanGlobalMS((0, s.bu)(t)),
            n = t - this.GetVisualWindowStartPX().valPX;
          this.SetUserZoomScale(e);
          const i = this.ConvertGlobalMSToGlobalPXOffset(r),
            a = this.GetScrollableWidthPX(),
            l = d.Lh(i.valPX - n, 0, a);
          this.ScrollToOffset(l);
        }
        SetTimelineGap(e) {
          this.m_nGapBetweenTimelinesPX !== e &&
            ((this.m_nGapBetweenTimelinesPX = e), this.ComputeAllUpdates());
        }
        GetTimelineGapWidth() {
          return this.m_nGapBetweenTimelinesPX;
        }
        SetClipSummaries(e) {
          (this.m_rgClipSummaries = e || []),
            this.BInitialized() && this.ComputeClipOffsets();
        }
        GetDuration() {
          return this.m_durationMS;
        }
        GetNumTimelines() {
          return this.m_loader.GetTimelines().length;
        }
        UpdateTimelineOffsetsFollowing(e) {
          const t = this.m_timelineOffsets.findIndex((t) => t.timelineID === e);
          if (t > -1) {
            for (let e = t; e < this.m_timelineOffsets.length; e++) {
              const t = this.m_timelineOffsets[e],
                r = this.m_loader.GetTimelineMetadata(t.timelineID),
                n = this.ComputeTimelineOffset(r, e);
              this.m_timelineOffsets[e] = n;
            }
            for (let e = t; e < this.m_timelineOffsets.length; e++) {
              const t = this.m_timelineOffsets[e],
                r = this.FindTimelineOffsets(t.timelineID),
                n = this.m_timelineIDToClipMap.get(t.timelineID);
              if (n && n.length) {
                const e = n.map((e) => {
                  const t = (0, s.Z6)(
                      r.globalOffsetMS.valMS + e.timelineOffsetMS,
                    ),
                    n = (0, s.Z6)(
                      r.globalOffsetMS.valMS +
                        e.timelineOffsetMS +
                        e.nDurationMS,
                    );
                  return Object.assign(Object.assign({}, e), {
                    globalOffsetMS: t,
                    startOffsetPX: this.ConvertGlobalMSToGlobalPXOffset(t),
                    endOffsetPX: this.ConvertGlobalMSToGlobalPXOffset(n),
                  });
                });
                this.m_timelineIDToClipMap.set(t.timelineID, e);
              }
            }
          }
          this.m_fnForceUpdate();
        }
        ComputeTimelineOffset(e, t) {
          const r = isNaN(parseInt(e.metadata.duration_ms()))
              ? 0
              : parseInt(e.metadata.duration_ms()),
            n =
              this.ConvertDurationMSToDeltaPX(e.nGlobalOffsetMS.valMS) +
              this.m_nGapBetweenTimelinesPX * t,
            i = n + this.ConvertDurationMSToDeltaPX(r),
            a = e.metadata.recordings().map((t) => {
              const i = (0, s.pX)(parseInt(t.start_offset_ms())),
                a = (0, s.Z6)(i.valMS + e.nGlobalOffsetMS.valMS),
                l = n + this.ConvertDurationMSToDeltaPX(i.valMS);
              let o = parseInt(t.duration_ms());
              isNaN(o) &&
                this.m_loader.IsActiveRecording(t.recording_id()) &&
                (o = r - i.valMS);
              const c = l + this.ConvertDurationMSToDeltaPX(o);
              return {
                recordingID: t.recording_id(),
                globalOffsetMS: a,
                nDurationMS: o,
                startOffsetPX: (0, s.bu)(l),
                endOffsetPX: (0, s.bu)(c),
              };
            });
          return {
            timelineID: e.metadata.timeline_id(),
            globalOffsetMS: e.nGlobalOffsetMS,
            nDurationMS: r,
            startOffsetPX: (0, s.bu)(n),
            endOffsetPX: (0, s.bu)(i),
            recordingOffsets: a,
          };
        }
        ComputeAllUpdates() {
          null !== this.m_scrollWindowWidth &&
            this.ComputeZoomScale() &&
            (this.ComputeTimelineOffsets(), this.ComputeClipOffsets());
        }
        ComputeZoomScale() {
          if (null === this.m_scrollWindowWidth)
            return (
              (0, b.X)(!1, "Timeline View has not seen a scroll width update"),
              !1
            );
          let e = this.GetTimelineGapWidth() * this.GetNumTimelines(),
            t = this.GetDuration(),
            r = Math.max(this.m_scrollWindowWidth - e, 1),
            n = t.valMS / r;
          this.m_nMaxAutoZoomScale = n;
          let i =
              null !== this.m_nTempZoomScaleMS
                ? this.m_nTempZoomScaleMS
                : this.m_nUserZoomScaleMS,
            a = Math.min(n, i);
          return (
            a !== this.m_nCurrentZoomScaleMS &&
            ((this.m_nCurrentZoomScaleMS = a), !0)
          );
        }
        ComputeTimelineOffsets() {
          (this.m_timelineOffsets = this.m_loader
            .GetTimelines()
            .map((e, t) => this.ComputeTimelineOffset(e, t))),
            this.m_fnForceUpdate();
        }
        ComputeClipOffsets() {
          this.m_timelineIDToClipMap.clear(),
            this.m_rgClipSummaries.forEach((e) => {
              const t = e.start_timeline_id;
              this.m_timelineIDToClipMap.has(t) ||
                this.m_timelineIDToClipMap.set(t, []);
              const r = parseInt(e.start_offset_ms),
                n = parseInt(e.duration_ms),
                i = { clipID: e.clip_id, timelineOffsetMS: r, nDurationMS: n },
                a = this.FindTimelineOffsets(e.start_timeline_id);
              if (a) {
                const e = (0, s.Z6)(a.globalOffsetMS.valMS + r),
                  t = (0, s.Z6)(a.globalOffsetMS.valMS + r + n);
                (i.globalOffsetMS = e),
                  (i.startOffsetPX = this.ConvertGlobalMSToGlobalPXOffset(e)),
                  (i.endOffsetPX = this.ConvertGlobalMSToGlobalPXOffset(t));
              }
              this.m_timelineIDToClipMap.get(t).push(i);
            });
        }
        GetClipsForTimeline(e) {
          return this.m_timelineIDToClipMap.get(e);
        }
        GetGlobalTimelineGapsPX() {
          const e = [];
          let t = (0, s.bu)(0),
            r = (0, s.bu)(0);
          return (
            this.m_timelineOffsets.forEach((n, i) => {
              0 === i
                ? (t = n.endOffsetPX)
                : i === this.m_timelineOffsets.length - 1
                ? ((r = n.startOffsetPX),
                  e.push({ gapStartPX: t, gapEndPX: r }))
                : ((r = n.startOffsetPX),
                  e.push({ gapStartPX: t, gapEndPX: r }),
                  (t = n.endOffsetPX));
            }),
            e
          );
        }
        FetchTimelineEntries(e, t) {
          return this.FetchTimelineEntriesWorker(
            e,
            t,
            this.m_loader.GetIteratorEntriesWithin,
          );
        }
        FetchTimelineGameModes(e) {
          return this.FetchTimelineEntriesWorker(
            ["gamemode"],
            e,
            this.m_loader.GetIteratorGameModesWithin,
          );
        }
        FetchTimelineEntriesWorker(e, t, r) {
          const n = this.ConvertPXOffsetToClosestLessThanGlobalMS(
            this.GetVirtualWindowEndPX(),
          );
          let i = this.m_loader.CreateTimelineIterator(t.valMS, 0);
          if (this.m_loader.HasIteratorReachedEnd(i))
            return { strState: "error", rgEntry: [] };
          let a = [];
          const l = this.m_loader.GetIteratorTimelineState(i);
          if ("loaded" == l)
            for (let l of r(i, n.valMS - t.valMS))
              if (e.includes(l.type)) {
                const e = Object.assign(Object.assign({}, l), {
                  time: l.time - i.m_nTimelineOffsetMS,
                });
                a.push(e);
              }
          return { strState: l, rgEntry: a };
        }
        FetchTimelineRanges(e) {
          const { strState: t, rgEntry: r } = this.FetchTimelineEntriesWorker(
            ["range"],
            e,
            this.m_loader.GetIteratorEntriesWithin,
          );
          return { strState: t, rgRanges: r };
        }
        ScrollToCenteredGlobalMS(e) {
          const t = this.ConvertGlobalMSToGlobalPXOffset(e);
          this.ScrollToOffsetCentered(t.valPX);
        }
        ScrollToOffset(e) {
          this.m_scrollLeftPX = (0, s.bu)(
            d.Lh(e, 0, this.GetMaxScrollLeftPX().valPX),
          );
        }
        ScrollToOffsetCentered(e) {
          const t = Math.max(0, e - 0.5 * this.m_scrollWindowWidth);
          this.ScrollToOffset(t);
        }
        ScrollBy(e) {
          const t = this.m_scrollLeftPX.valPX + e;
          this.m_scrollLeftPX = (0, s.bu)(
            d.Lh(t, 0, this.GetMaxScrollLeftPX().valPX),
          );
        }
        GetAutoScrollPaused() {
          return this.m_bAutoScrollPaused;
        }
        SetAutoScrollPaused(e) {
          this.ClearAutoScrollPauseTimeout(), (this.m_bAutoScrollPaused = e);
        }
        SetAutoPauseScrollTimeout(e) {
          this.m_autoScrollPauseTimeout = e;
        }
        GetAutoScrollPauseTimeout() {
          return this.m_autoScrollPauseTimeout;
        }
        ClearAutoScrollPauseTimeout() {
          this.m_autoScrollPauseTimeout &&
            clearTimeout(this.m_autoScrollPauseTimeout),
            (this.m_autoScrollPauseTimeout = null);
        }
        SetAutoScrollPauseTimeout(e = 5e3) {
          this.ClearAutoScrollPauseTimeout(),
            this.SetAutoPauseScrollTimeout(
              window.setTimeout(() => {
                this.SetAutoScrollPaused(!1);
              }, e),
            );
        }
        ScrollToEnd() {
          this.m_scrollLeftPX = this.GetMaxScrollLeftPX();
        }
        SetScrollWindowWidth(e) {
          (this.m_scrollWindowWidth = e),
            this.m_loader.BInitialized() &&
              (this.ComputeZoomScale() &&
                (this.ComputeTimelineOffsets(), this.ComputeClipOffsets()),
              this.ScrollToOffset(this.m_scrollLeftPX.valPX));
        }
        SetScrollWindowOffset(e) {
          this.m_scrollWindowOffsetPX = e;
        }
        GetScrollWindowOffset() {
          return this.m_scrollWindowOffsetPX;
        }
        GetScrollableWidthPX() {
          var e;
          return (
            null === (e = this.m_timelineOffsets) || void 0 === e
              ? void 0
              : e.length
          )
            ? this.m_timelineOffsets[this.m_timelineOffsets.length - 1]
                .endOffsetPX.valPX
            : 0;
        }
        GetScrollableWidthWithOffsets() {
          const e = this.GetScrollableWidthPX();
          return e ? e + this.m_nGapBetweenTimelinesPX : 0;
        }
        GetOverscanWidth() {
          return (this.GetScrollableWidthPX() * this.m_nOverscanPercent) / 100;
        }
        GetScrollWindowWidth() {
          return this.m_scrollWindowWidth;
        }
        GetScrollFocusPX() {
          return (0, s.bu)(
            this.GetVisualWindowStartPX().valPX +
              0.5 * this.GetScrollWindowWidth(),
          );
        }
        GetMaxScrollLeftPX() {
          return (0, s.bu)(
            Math.max(
              0,
              this.GetScrollableWidthPX() -
                this.GetScrollWindowWidth() +
                this.m_nGapBetweenTimelinesPX,
            ),
          );
        }
        BReachedMaxScroll() {
          return (
            Math.ceil(this.m_scrollLeftPX.valPX) ===
            Math.ceil(this.GetMaxScrollLeftPX().valPX)
          );
        }
        BReachedMinScroll() {
          return 0 === this.m_scrollLeftPX.valPX;
        }
        GetVisualWindowStartPX() {
          return this.m_scrollLeftPX;
        }
        GetVisualWindowEndPX() {
          return (0, s.bu)(
            Math.min(
              this.m_scrollLeftPX.valPX + this.m_scrollWindowWidth,
              this.GetScrollableWidthPX(),
            ),
          );
        }
        GetVisualWidth() {
          return Math.min(
            this.m_scrollWindowWidth,
            this.GetScrollableWidthWithOffsets(),
          );
        }
        GetVirtualWindowStartPX() {
          return (0, s.bu)(
            Math.max(this.m_scrollLeftPX.valPX - this.GetOverscanWidth(), 0),
          );
        }
        GetVirtualWindowWidthPX() {
          const e = d.Lh(this.m_scrollLeftPX.valPX, 0, this.GetOverscanWidth()),
            t = Math.min(
              this.GetScrollableWidthPX() -
                (this.m_scrollLeftPX.valPX + this.m_scrollWindowWidth),
              this.GetOverscanWidth(),
            );
          return e + this.m_scrollWindowWidth + t;
        }
        GetVirtualWindowEndPX() {
          return (0, s.bu)(
            this.GetVirtualWindowStartPX().valPX +
              this.GetVirtualWindowWidthPX(),
          );
        }
        GetTimelinesInWindow() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.GetVirtualWindowStartPX(),
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              this.GetVirtualWindowEndPX(),
            );
          return this.m_timelineOffsets.slice(e, t + 1);
        }
        GetWindowRelativeTimelines() {
          return this.GetTimelinesInWindow().map((e) => {
            const t =
                e.startOffsetPX.valPX < this.GetVirtualWindowStartPX().valPX
                  ? this.GetVirtualWindowStartPX()
                  : e.startOffsetPX,
              r =
                e.endOffsetPX.valPX > this.GetVirtualWindowEndPX().valPX
                  ? this.GetVirtualWindowEndPX()
                  : e.endOffsetPX;
            return {
              timelineID: e.timelineID,
              nStartPX: t,
              nEndPX: r,
              nTimelineStartMS: this.ConvertPXToTimelineRelativeMS(t),
              nGlobalStartMS: this.ConvertPXOffsetToClosestLessThanGlobalMS(t),
            };
          });
        }
        GetWindowRelativeRecordings() {
          const e = [];
          return (
            this.GetTimelinesInWindow().forEach((t) => {
              t.recordingOffsets.forEach((t) => {
                if (
                  t.endOffsetPX.valPX > this.GetVirtualWindowStartPX().valPX ||
                  t.startOffsetPX.valPX < this.GetVirtualWindowEndPX().valPX
                ) {
                  const r =
                      t.startOffsetPX.valPX <
                      this.GetVirtualWindowStartPX().valPX
                        ? this.GetVirtualWindowStartPX()
                        : t.startOffsetPX,
                    n =
                      t.endOffsetPX.valPX > this.GetVirtualWindowEndPX().valPX
                        ? this.GetVirtualWindowEndPX()
                        : t.endOffsetPX;
                  e.push({
                    recordingID: t.recordingID,
                    nStartPX: r,
                    nEndPX: n,
                  });
                }
              });
            }),
            e
          );
        }
        GetWindowRelativeClips() {
          const e = [];
          return (
            this.GetTimelinesInWindow().forEach((t) => {
              const r = this.GetClipsForTimeline(t.timelineID);
              r &&
                r.length &&
                r.forEach((t) => {
                  if (
                    t.endOffsetPX.valPX >
                      this.GetVirtualWindowStartPX().valPX ||
                    t.startOffsetPX.valPX < this.GetVirtualWindowEndPX().valPX
                  ) {
                    const r =
                        t.startOffsetPX.valPX <
                        this.GetVirtualWindowStartPX().valPX
                          ? this.GetVirtualWindowStartPX()
                          : t.startOffsetPX,
                      n =
                        t.endOffsetPX.valPX > this.GetVirtualWindowEndPX().valPX
                          ? this.GetVirtualWindowEndPX()
                          : t.endOffsetPX;
                    e.push({ clipID: t.clipID, nStartPX: r, nEndPX: n });
                  }
                });
            }),
            e
          );
        }
        GetVisibleTimelinesInWindow() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.m_scrollLeftPX,
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              (0, s.bu)(this.m_scrollLeftPX.valPX + this.m_scrollWindowWidth),
            );
          return this.m_timelineOffsets.slice(e, t + 1);
        }
        GetVisibleWindowRelativeTimelines() {
          return this.GetVisibleTimelinesInWindow().map((e) => {
            const t = this.m_scrollLeftPX,
              r = (0, s.bu)(
                this.GetVirtualWindowEndPX().valPX - this.GetOverscanWidth(),
              ),
              n = e.endOffsetPX.valPX > r.valPX ? r : e.endOffsetPX,
              i = e.startOffsetPX.valPX < t.valPX ? t : e.startOffsetPX;
            return {
              timelineID: e.timelineID,
              nVisibleStartPX: i,
              nEndPX: n,
              nTimelineStartMS: this.ConvertPXToTimelineRelativeMS(t),
              nGlobalStartMS: this.ConvertPXOffsetToClosestLessThanGlobalMS(t),
            };
          });
        }
        GetVisibleWindowRelativeTimestamps() {
          return this.GetVisibleTimelinesInWindow().map((e) => {
            const t = this.m_scrollLeftPX,
              r = (0, s.bu)(
                this.GetVirtualWindowEndPX().valPX - this.GetOverscanWidth(),
              ),
              n = e.endOffsetPX.valPX > r.valPX ? r : e.endOffsetPX,
              i = e.startOffsetPX.valPX < t.valPX ? t : e.startOffsetPX;
            return {
              timelineID: e.timelineID,
              nVisibleStartPX: i,
              nEndPX: n,
              nTimelineStartMS: this.ConvertPXToTimelineRelativeMS(t),
              nGlobalStartMS: this.ConvertPXOffsetToClosestLessThanGlobalMS(t),
            };
          });
        }
        ConvertPXToTimelineRelativeMS(e) {
          const t = this.ConvertPXOffsetToClosestLessThanGlobalMS(e);
          return this.m_loader.GetTimelineOffsetFromGlobal(t.valMS, 0)
            .nTimelineOffsetMS;
        }
        FindTimelineForGlobalMS(e) {
          const t = this.m_loader.GetTimelineOffsetFromGlobal(e.valMS, 0);
          return t ? t.strTimelineID : null;
        }
        FindTimelineOffsetsForGlobalMS(e) {
          const t = u.sL(
            this.m_timelineOffsets,
            (t) => e.valMS - t.globalOffsetMS.valMS,
          );
          if (t < 0) return null;
          return this.m_timelineOffsets[t];
        }
        ConvertGlobalMSToTimelineMS(e) {
          return this.m_loader.GetTimelineOffsetFromGlobal(e.valMS, 0);
        }
        GetTimeRecorded(e) {
          const t = this.m_loader.GetTimelineMetadata(e);
          return t ? t.metadata.date_recorded() : null;
        }
        ConvertToClientWindowPXTOGlobalMSOffset(e) {
          const t =
            e.valPX + this.m_scrollLeftPX.valPX - this.m_scrollWindowOffsetPX;
          return this.ConvertPXOffsetToGlobalMSOrNone((0, s.bu)(t));
        }
        ConvertGlobalMSToScrollWindowPXOffset(e) {
          const t = this.ConvertGlobalMSToGlobalPXOffset(e);
          return (0, s.yj)(t.valPX - this.m_scrollLeftPX.valPX);
        }
        ConvertTimelineRelativeMSToGlobalPX(e, t) {
          const r = this.FindTimelineOffsets(e);
          return r
            ? (0, s.bu)(
                r.startOffsetPX.valPX +
                  this.ConvertDurationMSToDeltaPX(t.valMS),
              )
            : (0, s.bu)(0);
        }
        ConvertTimelineRelativeOffsetToGlobalOffsetMS(e, t) {
          const r = this.m_loader.GetGlobalOffsetDataForTimeline(e, 0);
          return r ? r.nGlobalOffsetMS + t : 0;
        }
        ConvertGlobalMSToGlobalPXOffset(e) {
          const t = u.sL(
            this.m_timelineOffsets,
            (t) => e.valMS - t.globalOffsetMS.valMS,
          );
          if (t < 0) return (0, s.bu)(0);
          const r = this.m_timelineOffsets[t],
            n = this.ConvertDurationMSToDeltaPX(
              e.valMS - r.globalOffsetMS.valMS,
            );
          return (0, s.bu)(r.startOffsetPX.valPX + n);
        }
        ConvertPXOffsetToClosestLessThanGlobalMS(e) {
          if (this.IsInGap(e)) {
            const t = this.FindClosestTimelineEndForOffsetPX(e);
            return t
              ? (0, s.Z6)(t.globalOffsetMS.valMS + t.nDurationMS)
              : (0, s.Z6)(0);
          }
          const t = this.FindClosestTimelineStartForOffsetPX(e);
          if (!t) return (0, s.Z6)(0);
          const r = this.ConvertDeltaPXToDurationMS(
            e.valPX - t.startOffsetPX.valPX,
          );
          return (0, s.Z6)(t.globalOffsetMS.valMS + r);
        }
        ConvertPXOffsetToClosestGreaterThanGlobalMS(e) {
          if (this.IsInGap(e)) {
            const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
            if (t < 0) return (0, s.Z6)(0);
            const r = t + 1,
              n = this.m_timelineOffsets[r];
            return n
              ? (0, s.Z6)(n.globalOffsetMS.valMS + n.nDurationMS)
              : (0, s.Z6)(0);
          }
          const t = this.FindClosestTimelineStartForOffsetPX(e);
          if (!t) return (0, s.Z6)(0);
          const r = this.ConvertDeltaPXToDurationMS(
            e.valPX - t.startOffsetPX.valPX,
          );
          return (0, s.Z6)(t.globalOffsetMS.valMS + r);
        }
        ConvertPXOffsetToGlobalMSOrNone(e) {
          if (this.IsInGap(e)) return null;
          const t = this.FindClosestTimelineStartForOffsetPX(e);
          if (!t) return null;
          const r = this.ConvertDeltaPXToDurationMS(
            e.valPX - t.startOffsetPX.valPX,
          );
          return (0, s.Z6)(t.globalOffsetMS.valMS + r);
        }
        FindClosestTimelineEndForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
          if (t < 0) return null;
          return this.m_timelineOffsets[t];
        }
        FindClosestTimelineStartForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineStartForOffsetPX(e);
          if (t < 0) return null;
          return this.m_timelineOffsets[t];
        }
        FindIndexOfClosestTimelineEndForOffsetPX(e) {
          return u.sL(
            this.m_timelineOffsets,
            (t) => e.valPX - t.endOffsetPX.valPX,
          );
        }
        FindIndexOfClosestTimelineStartForOffsetPX(e) {
          return u.sL(
            this.m_timelineOffsets,
            (t) => e.valPX - t.startOffsetPX.valPX,
          );
        }
        FindTimelineOffsets(e) {
          return this.m_timelineOffsets.find((t) => t.timelineID === e);
        }
        IsInGap(e) {
          return (
            -1 !==
            this.GetGlobalTimelineGapsPX().findIndex(
              (t) => t.gapStartPX.valPX < e.valPX && t.gapEndPX.valPX > e.valPX,
            )
          );
        }
        ConvertDurationMSToDeltaPX(e) {
          return e / this.m_nCurrentZoomScaleMS;
        }
        ConvertDeltaPXToDurationMS(e) {
          return e * this.m_nCurrentZoomScaleMS;
        }
      }
      (0, c.gn)([m.LO], p.prototype, "m_bLoaderInitialized", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_durationMS", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_timelineIDToClipMap", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_scrollLeftPX", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_scrollWindowWidth", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_scrollWindowOffsetPX", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_bAutoScrollPaused", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_autoScrollPauseTimeout", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_nMaxAutoZoomScale", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_nUserZoomScaleMS", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_nCurrentZoomScaleMS", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_nTempZoomScaleMS", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_timelineOffsets", void 0),
        (0, c.gn)([m.LO], p.prototype, "m_loadedTimelines", void 0),
        (0, c.gn)([m.aD], p.prototype, "OnLoaderInitialized", null),
        (0, c.gn)([m.aD], p.prototype, "SetUserZoomScale", null),
        (0, c.gn)([_.ak], p.prototype, "BReachedMaxScroll", null),
        (0, c.gn)([_.ak], p.prototype, "BReachedMinScroll", null);
      const M = n.createContext(null);
      function C(e) {
        var t;
        let {
          loader: r,
          playbackCoordinator: i,
          children: a,
          clipSummaries: l,
        } = e;
        const o = (0, _.NW)();
        let c = (0, n.useRef)(null);
        (c.current && c.current.IsSameLoader(r)) ||
          (null === (t = c.current) || void 0 === t || t.Close(),
          (c.current = new p(r, i, o, l)));
        let m = c.current;
        return (
          (0, n.useEffect)(() => {
            m.SetClipSummaries(l);
          }, [m, l]),
          n.useEffect(() => () => c.current && c.current.Close(), []),
          (0, P.n9)((e, t) => {
            if (!e || !t) return void m.ClearTempZoomScale();
            let r = Math.floor(0.1 * (t.valMS - e.valMS)),
              n = (0, s.Z6)(e.valMS - r),
              i = (0, s.Z6)(t.valMS + r);
            m.SetTempZoomScale(n, i);
          }),
          n.createElement(M.Provider, { value: c.current }, a)
        );
      }
      function y() {
        return (0, n.useContext)(M);
      }
      var T = r(72120);
      const k = n.memo(function (e) {
          const t = y(),
            r = (0, i.SZ)(() => t.GetWindowRelativeTimelines());
          return n.createElement(
            n.Fragment,
            null,
            r.map((e) =>
              n.createElement(G, {
                key: e.timelineID,
                timelineID: e.timelineID,
                ticksStartPX: e.nStartPX,
                ticksEndPX: e.nEndPX,
                ticksStartMS: e.nTimelineStartMS,
              }),
            ),
          );
        }),
        G = n.memo(function (e) {
          const { timelineID: t, ticksEndPX: r, ticksStartMS: a } = e,
            l = y(),
            o = (0, i.SZ)(() => l.GetCurrentZoomScale()),
            c = S(o),
            m = (0, n.useMemo)(() => {
              const e = o * c,
                n = (0, s.pX)(Math.ceil(a.valMS / e) * e),
                i = l.ConvertTimelineRelativeMSToGlobalPX(t, n),
                m = r.valPX - i.valPX,
                d = Math.ceil(m / c);
              return Array.from({ length: d }).map((r, a) => {
                const l = (0, s.pX)(n.valMS + e * a),
                  o = i.valPX + a * c,
                  m = l.valMS / e;
                return {
                  key: `${t}_${l.valMS}`,
                  offsetPX: o,
                  timeMS: l,
                  nTimelineRelativeTickIndex: m,
                };
              });
            }, [l, c, r.valPX, a.valMS, t, o]);
          return m
            ? n.createElement(
                n.Fragment,
                null,
                m.map((e) =>
                  n.createElement(R, {
                    key: e.key,
                    timeMS: e.timeMS.valMS,
                    timelineRelativeIndex: e.nTimelineRelativeTickIndex,
                    globalOffsetPX: e.offsetPX,
                  }),
                ),
              )
            : null;
        }),
        R = n.memo(function (e) {
          const { timeMS: t, globalOffsetPX: r, timelineRelativeIndex: i } = e,
            a = n.useMemo(
              () =>
                i % 20 == 0
                  ? "Whole"
                  : i % 10 == 0
                  ? "Half"
                  : i % 5 == 0
                  ? "Quarter"
                  : "Default",
              [i],
            );
          return n.createElement(
            "div",
            {
              className: l.TimeTick,
              style: { transform: `translateX(${r}px)` },
            },
            n.createElement("div", {
              className: (0, o.Z)(l.TickLine, a && l[a]),
            }),
            "Whole" === a &&
              n.createElement(
                "div",
                { className: l.TickStamp },
                (function (e) {
                  const t = !1;
                  return (0, T.SF)(e / 1e3, t);
                })(t),
              ),
          );
        });
      var X,
        E = r(85540),
        O = r(77613);
      function B(e) {
        return (
          (function (e) {
            return "highlight" === e.type;
          })(e) && "steam_achievement" == e.icon
        );
      }
      function w(e) {
        return "usermarker" === e.type;
      }
      !(function (e) {
        (e[(e.Invalid = 0)] = "Invalid"),
          (e[(e.Playing = 1)] = "Playing"),
          (e[(e.Staging = 2)] = "Staging"),
          (e[(e.Menus = 3)] = "Menus");
      })(X || (X = {}));
      var I = r(84682),
        D = r(61385),
        F = r(57605),
        L = r(77557),
        W = r(99307),
        x = r(57742),
        A = r(60161),
        z = r(14826),
        N = r(87228),
        Z = r(70487);
      function V(e) {
        var t;
        let {
          markerInfo: r,
          onClick: i,
          onMouseEnter: a,
          onMouseLeave: l,
          classNames: s,
          style: c,
          faded: m,
        } = e;
        const d = (0, O.we)(),
          { selectedMarker: u } = (0, P.pI)(),
          h = (0, P.Kc)(),
          _ =
            (null === (t = r.entry) || void 0 === t ? void 0 : t.id) ==
              (null == u ? void 0 : u.strEntryID) &&
            r.strTimelineID == (null == u ? void 0 : u.strTimelineID);
        let f = n.useCallback(
          (e) => {
            if (!w(r.entry)) return;
            let t = n.createElement(J, {
              markerInfo: r,
              playbackCoordinator: d,
              fnClearSelection: h,
            });
            (0, x.AM)(t, (0, A.RA)(e)), e.stopPropagation(), e.preventDefault();
          },
          [d, r, h],
        );
        return n.createElement(
          "div",
          {
            style: null != c ? c : {},
            className: (0, o.Z)(s, {
              [N.HighlightIcon]: !0,
              [N.Selected]: _,
              [N.Faded]: m,
            }),
            onClick: (e) => {
              i && i(e);
            },
            onContextMenu: f,
            onMouseEnter: a,
            onMouseLeave: l,
          },
          n.createElement(U, { markerInfo: r }),
        );
      }
      function U(e) {
        let { markerInfo: t } = e;
        const r = (0, O.we)().GetGameID(),
          i = B(t.entry),
          a = !i && (0, D.jq)(t.strMarkerIcon),
          l = !i && !a;
        return n.createElement(
          n.Fragment,
          null,
          i && n.createElement(H, { markerInfo: t, strGameID: r }),
          a && n.createElement(j, { markerInfo: t }),
          l &&
            n.createElement($, {
              strMarkerIcon: t.strMarkerIcon,
              strGameID: r,
            }),
        );
      }
      function H(e) {
        const { markerInfo: t, strGameID: r } = e,
          i = new Z.N1(r),
          a = (0, v.$H)(i.GetAppID(), t.strDescription);
        let l, o;
        if (a) (l = "white"), (o = n.createElement("img", { src: a.iconURL }));
        else {
          const e = (0, D.cY)();
          (l = (0, D.Mv)(e.color)), (o = e.func({}));
        }
        return n.createElement("div", { style: { color: l } }, o);
      }
      function j(e) {
        const { markerInfo: t } = e;
        let r, i;
        w(t.entry)
          ? ((r = (0, D.vt)()), (i = N.CustomMarker))
          : (r = (0, D.XT)(t.strMarkerIcon));
        const a = (0, D.Mv)(r.color),
          l = r.func({}),
          o = n.createElement("div", { className: i }, l);
        return n.createElement(q, { element: o, color: a });
      }
      function $(e) {
        const { strMarkerIcon: t, strGameID: r } = e,
          i = new Z.N1(r).GetAppID(),
          a = (0, I.JZ)(i, t);
        if (null === a) return null;
        if (void 0 === a) {
          const e = (0, D.vt)();
          return n.createElement(
            "div",
            { style: { color: (0, D.Mv)(e.color) } },
            e.func({}),
          );
        }
        const { color: l, svg: o } = a,
          s = new XMLSerializer().serializeToString(o),
          c = n.createElement(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
            n.createElement("g", { dangerouslySetInnerHTML: { __html: s } }),
          ),
          m = (0, D.Mv)(l);
        return n.createElement(q, { element: c, color: m });
      }
      function q(e) {
        const { element: t, color: r } = e;
        return n.createElement(
          "div",
          { className: N.MarkerCtn },
          n.createElement(
            "div",
            { className: (0, o.Z)(N.MarkerBacking, N.MarkerElt) },
            t,
          ),
          n.createElement(
            "div",
            { className: N.MarkerElt, style: { color: r } },
            t,
          ),
        );
      }
      function J(e) {
        const {
            closeModal: t,
            markerInfo: r,
            playbackCoordinator: i,
            fnClearSelection: a,
          } = e,
          l = r.entry,
          [o, s] = n.useState(l.title || ""),
          [m, d] = n.useState(l.description || ""),
          u = (0, L.tx)();
        return u.bLoading
          ? n.createElement(L.NT, {
              state: u,
              strDialogTitle: (0, z.Xx)("#Marker_Dialog"),
              closeModal: t,
            })
          : n.createElement(
              W.uH,
              {
                strTitle: (0, z.Xx)("#Marker_Dialog"),
                strMiddleButtonText: (0, z.Xx)("#Marker_Action_Delete"),
                onCancel: t,
                onOK: () =>
                  (0, c.mG)(this, void 0, void 0, function* () {
                    const { fnUpdateUserTimelineMarkers: e } = (0, v.oV)();
                    u.fnSetLoading(!0);
                    const t = i.GetGameID(),
                      n = {
                        timeline_id: r.strTimelineID,
                        entry_id: l.id,
                        time: r.entry.time,
                        type: 5,
                        marker_icon: l.icon,
                        marker_title: o,
                        marker_description: m,
                        marker_priority: l.priority,
                      };
                    1 == (yield e(t, n))
                      ? ((l.description = m),
                        (l.title = o),
                        (r.strDescription = m),
                        (r.strTitle = o),
                        u.fnSetSuccess(!0),
                        u.fnSetStrSuccess(
                          (0, z.Xx)("#EventDisplay_Share_Success"),
                        ))
                      : (u.fnSetError(!0),
                        u.fnSetStrSuccess((0, z.Xx)("#ImageUpload_Failed")));
                  }),
                onMiddleButton: () =>
                  (0, c.mG)(this, void 0, void 0, function* () {
                    u.fnSetLoading(!0);
                    const e = yield (function (e, t, r, n) {
                      return (0, c.mG)(this, void 0, void 0, function* () {
                        const { fnRemoveUserTimelineMarker: i } = (0, v.oV)(),
                          a = e.GetGameID();
                        n();
                        const l = yield i(a, r, t);
                        return (
                          1 == l
                            ? e.RemoveUserMarker(r, t)
                            : (0, h.Zb)(
                                `Failed to delete user marker for timeline ${r} entry ${t}`,
                              ),
                          l
                        );
                      });
                    })(i, r.entry.id, r.strTimelineID, a);
                    1 == e ? t() : u.fnSetError(!0);
                  }),
              },
              n.createElement(F.II, {
                type: "text",
                value: o,
                onChange: (e) => s(e.currentTarget.value),
                label: (0, z.Xx)("#Marker_Title"),
              }),
              n.createElement(F.II, {
                type: "text",
                value: m,
                onChange: (e) => d(e.currentTarget.value),
                label: (0, z.Xx)("#Marker_Description"),
              }),
            );
      }
      var K = r(84343),
        Y = r(87195),
        Q = r(818);
      class ee {
        constructor(e) {
          (this.m_reservations = []), (this.m_nIconWidth = e);
        }
        BAllowIcon(e) {
          const t = {
            nStart: e - this.m_nIconWidth / 2,
            nEnd: e + this.m_nIconWidth / 2,
          };
          let r = 0;
          for (; r < this.m_reservations.length; r++) {
            const e = this.m_reservations[r];
            if (e.nStart >= t.nEnd) break;
            if (!((n = t).nStart >= (i = e).nEnd || n.nEnd <= i.nStart))
              return !1;
          }
          var n, i;
          return this.m_reservations.splice(r, 0, t), !0;
        }
      }
      function te(e) {
        const {
            view: t,
            coordinator: r,
            bPlayerHidden: i,
            entry: a,
            nGlobalTLStartMS: l,
            timelineID: c,
            faded: m,
          } = e,
          { setSelectedMarker: d } = (0, P.pI)(),
          u = (0, P.Uk)(),
          _ = (0, P.az)();
        let f = { strType: "chunk", entry: a };
        const g = (0, s.Z6)(parseInt(a.time) + l.valMS),
          S = t.ConvertGlobalMSToGlobalPXOffset(g),
          b = (0, n.useCallback)(
            (e) => {
              let [t, n] = r
                .GetLoader()
                .CreateGlobalRangeForTimeline(c, g.valMS, 8e3, 4e3);
              r.SetPlaytimeFromGlobalMS((0, s.Z6)(t)),
                null == d || d(a.id, c, t, n),
                e.stopPropagation();
            },
            [r, a.id, g, d, c],
          ),
          v = (0, n.useCallback)(
            (e) => {
              null == u ||
                u((0, s.Z6)(g.valMS - 8e3), (0, s.Z6)(g.valMS + 4e3));
            },
            [g.valMS, u],
          ),
          p = (0, n.useCallback)(
            (e) => {
              null == _ || _();
            },
            [_],
          );
        if (!["highlight", "usermarker", "screenshot"].includes(a.type))
          return (
            (0, h.hB)(
              `Unexpected timeline entry type ${a.type}, returning empty highlight marker`,
            ),
            null
          );
        let M = a;
        const C = { transform: `translateX( calc( ${S.valPX}px - 50% ))` },
          y = { transform: `translateX( ${S.valPX - 1}px )` };
        (f.strMarkerIcon = M.icon),
          (f.nMarkerPriority = M.priority),
          (f.strTimelineID = c);
        let T = null;
        if (B(M)) {
          const t = M;
          (f.strTitle = t.title),
            (f.strDescription = t.description),
            (T = n.createElement(le, {
              markerInfo: f,
              entry: t,
              gameID: e.gameID,
              nGlobalMS: g,
            }));
        } else if (
          (function (e) {
            return "screenshot" === e.type;
          })(M)
        ) {
          M.handle;
          T = n.createElement(ie, {
            markerInfo: f,
            entry: M,
            gameID: e.gameID,
            nGlobalMS: g,
          });
        } else {
          const t = M;
          (f.strTitle = t.title),
            (f.strDescription = t.description),
            (T = n.createElement(ie, {
              markerInfo: f,
              entry: M,
              gameID: e.gameID,
              nGlobalMS: g,
            }));
        }
        const k = i ? "bottom" : "top",
          G = i ? 100 : 40;
        return n.createElement(
          n.Fragment,
          null,
          n.createElement(
            K.HP,
            {
              toolTipContent: T,
              direction: k,
              nDelayShowMS: 20,
              nBodyDistance: G,
              className: (0, o.Z)(E.TimelineMarkerCtn),
              style: C,
            },
            n.createElement(V, {
              classNames: E.TimelineMarker,
              key: M.id,
              markerInfo: f,
              faded: m,
              onClick: b,
              onMouseEnter: v,
              onMouseLeave: p,
            }),
          ),
          n.createElement("div", {
            className: E.TimelineMarkerDropLine,
            style: y,
          }),
        );
      }
      function re(e) {
        const {
            view: t,
            coordinator: r,
            bPlayerHidden: i,
            range: a,
            nGlobalTLStartMS: l,
            timelineID: c,
            faded: m,
          } = e,
          { setSelectedMarker: d } = (0, P.pI)(),
          u = (0, P.Uk)(),
          h = (0, P.az)(),
          _ = (0, s.Z6)(parseInt(a.time) + l.valMS),
          f = t.ConvertGlobalMSToGlobalPXOffset(_),
          g = (0, s.Z6)(parseInt(a.time) + parseInt(a.duration) + l.valMS);
        t.ConvertGlobalMSToGlobalPXOffset(g);
        let S = { strType: "chunk", entry: a };
        const b = (0, n.useCallback)(
            (e) => {
              let [t, n] = r
                .GetLoader()
                .CreateGlobalRangeForTimeline(
                  c,
                  _.valMS,
                  0,
                  parseInt(a.duration),
                );
              r.SetPlaytimeFromGlobalMS((0, s.Z6)(t)),
                d && d(a.id, c, t, n),
                e.stopPropagation();
            },
            [r, a.id, _, a.duration, d, c],
          ),
          v = (0, n.useCallback)(
            (e) => {
              u(_, g);
            },
            [_, g, u],
          ),
          p = (0, n.useCallback)(
            (e) => {
              h && h();
            },
            [h],
          ),
          M = { transform: `translateX( calc( ${f.valPX}px - 50% ))` },
          C = { transform: `translateX( ${f.valPX - 1}px )` };
        (S.strMarkerIcon = a.icon),
          (S.nMarkerPriority = a.priority),
          (S.strTitle = a.title),
          (S.strDescription = a.description),
          (S.strTimelineID = c);
        const y = i ? "bottom" : "top",
          T = i ? 100 : 40,
          k = n.createElement(ae, { range: a, gameID: e.gameID, nGlobalMS: _ });
        return n.createElement(
          n.Fragment,
          null,
          n.createElement(
            K.HP,
            {
              toolTipContent: k,
              direction: y,
              nDelayShowMS: 20,
              nBodyDistance: T,
              className: (0, o.Z)(E.TimelineMarkerCtn),
              style: M,
            },
            n.createElement(V, {
              classNames: E.TimelineMarker,
              key: a.id,
              markerInfo: S,
              faded: m,
              onClick: b,
              onMouseEnter: v,
              onMouseLeave: p,
            }),
          ),
          n.createElement(
            "div",
            { className: E.TimelineMarkerRangeMarker, style: C },
            n.createElement(Q.Hi, null),
            " ",
          ),
        );
      }
      function ne(e) {
        const { nGlobalMS: t, gameID: r } = e,
          i = ((0, O.we)(), (0, Y.sC)(r, t.valMS, 200, !1));
        return Boolean(i)
          ? n.createElement("img", { src: i })
          : n.createElement(n.Fragment, null);
      }
      function ie(e) {
        const { markerInfo: t, entry: r, gameID: i, nGlobalMS: a } = e,
          l = w(r) ? (0, z.Xx)("#Marker_UserMarker_Title") : r.title,
          o = r.description,
          c = (0, s.pX)(parseInt(r.time));
        return n.createElement(
          "div",
          { className: E.TooltipContainer },
          n.createElement(
            "div",
            { className: E.ThumbnailContainer },
            n.createElement(ne, { nGlobalMS: a, gameID: i }),
          ),
          (l || o) &&
            n.createElement(
              "div",
              { className: E.TooltipHighlight },
              n.createElement(
                "div",
                { className: E.HighlightIcon },
                n.createElement(U, { markerInfo: t }),
              ),
              n.createElement(
                "div",
                { className: E.HighlightInfoBlock },
                l && n.createElement("div", { className: E.HighlightTitle }, l),
                o && n.createElement("div", { className: E.HighlightDesc }, o),
              ),
            ),
          n.createElement(
            "div",
            { className: E.Timestamp },
            (0, T.SF)(c.valMS / 1e3),
          ),
        );
      }
      function ae(e) {
        const { range: t, gameID: r, nGlobalMS: i } = e,
          a = t.title,
          l = t.title,
          o = (0, s.pX)(parseInt(t.time)),
          c = (0, s.pX)(parseInt(t.time) + parseInt(t.duration));
        let m = { strType: "chunk", entry: t, strMarkerIcon: t.icon };
        return n.createElement(
          "div",
          { className: E.TooltipContainer },
          n.createElement(
            "div",
            { className: E.ThumbnailContainer },
            n.createElement(ne, { nGlobalMS: i, gameID: r }),
          ),
          (a || l) &&
            n.createElement(
              "div",
              { className: E.TooltipHighlight },
              n.createElement(
                "div",
                { className: E.HighlightIcon },
                n.createElement(U, { markerInfo: m }),
              ),
              n.createElement(
                "div",
                { className: E.HighlightInfoBlock },
                a && n.createElement("div", { className: E.HighlightTitle }, a),
                l && n.createElement("div", { className: E.HighlightDesc }, l),
              ),
            ),
          n.createElement(
            "div",
            { className: E.Timestamp },
            (0, T.SF)(o.valMS / 1e3),
          ),
          n.createElement(
            "div",
            { className: E.Timestamp },
            (0, T.SF)(c.valMS / 1e3),
          ),
        );
      }
      function le(e) {
        var t, r, i;
        const { markerInfo: a, entry: l, gameID: o, nGlobalMS: s } = e,
          c = new Z.N1(o),
          m = (0, v.$H)(
            c.GetAppID(),
            null !== (t = a.strDescription) && void 0 !== t ? t : "",
          );
        if (!m) return null;
        let d = Object.assign({}, l);
        return (
          (d.title = null !== (r = m.name) && void 0 !== r ? r : ""),
          (d.description =
            null !== (i = m.description) && void 0 !== i ? i : ""),
          n.createElement(ie, {
            markerInfo: a,
            entry: d,
            gameID: o,
            nGlobalMS: s,
          })
        );
      }
      const oe = n.memo(function (e) {
          const t = y(),
            r = (0, i.SZ)(() => t.GetTimelinesInWindow());
          return n.createElement(
            n.Fragment,
            null,
            r.map((e) =>
              n.createElement(se, {
                key: e.timelineID,
                timelineID: e.timelineID,
                timelineOffset: e.globalOffsetMS,
              }),
            ),
          );
        }),
        se = n.memo(function (e) {
          const { timelineID: t, timelineOffset: r } = e,
            a = y(),
            l = (0, O.we)(),
            o = (0, i.SZ)(() => l.GetHidePlayer()),
            s = l.GetGameID(),
            c = 16 * a.GetCurrentZoomScale(),
            { strState: m, rgEntry: d } = a.FetchTimelineEntries(
              ["highlight", "usermarker", "screenshot"],
              r,
            );
          if ("loaded" != m) return null;
          d.sort((e, t) =>
            e.priority != t.priority
              ? t.priority - e.priority
              : e.time != t.time
              ? parseInt(e.time) - parseInt(t.time)
              : e.id.localeCompare(t.id),
          );
          const { strState: u, rgRanges: h } = a.FetchTimelineRanges(r);
          if ("loaded" != u) return null;
          let _ = new ee(c),
            f = [];
          const g = d.filter((e) => "usermarker" == e.type),
            S = d.filter((e) => "usermarker" != e.type);
          return (
            g.concat(h, S).forEach((e, i) => {
              const c = r.valMS + parseInt(e.time),
                m = _.BAllowIcon(c),
                d = `${e.type}_${t}_${i}`;
              switch (e.type) {
                case "usermarker":
                case "highlight":
                case "screenshot":
                  f.push(
                    n.createElement(te, {
                      gameID: s,
                      key: d,
                      view: a,
                      coordinator: l,
                      entry: e,
                      bPlayerHidden: o,
                      faded: !m,
                      nGlobalTLStartMS: r,
                      timelineID: t,
                    }),
                  );
                  break;
                case "range":
                  f.push(
                    n.createElement(re, {
                      gameID: s,
                      key: d,
                      view: a,
                      coordinator: l,
                      range: e,
                      bPlayerHidden: o,
                      faded: !m,
                      nGlobalTLStartMS: r,
                      timelineID: t,
                    }),
                  );
              }
            }),
            n.createElement(n.Fragment, null, f.reverse())
          );
        });
      var ce = r(22334);
      function me(e) {
        const {
            view: t,
            entry: r,
            nGlobalEntryEndMS: i,
            nGlobalTLStartMS: a,
          } = e,
          l = (0, s.Z6)(parseInt(r.time) + a.valMS),
          c = t.ConvertGlobalMSToGlobalPXOffset(l),
          m = t.ConvertGlobalMSToGlobalPXOffset(i),
          d = {
            transform: `translateX( ${c.valPX}px )`,
            width: m.valPX - c.valPX,
          },
          u = (0, o.Z)({
            [ce.Unspecified]: r.mode === X.Invalid,
            [ce.Staging]: r.mode === X.Staging,
            [ce.Menus]: r.mode === X.Menus,
            [ce.Playing]: r.mode === X.Playing,
          });
        return n.createElement("div", {
          key: r.id,
          className: (0, o.Z)(ce.GameModeMarker, u),
          style: d,
        });
      }
      const de = n.memo(function (e) {
          const t = y(),
            r = (0, i.SZ)(() => t.GetTimelinesInWindow());
          return n.createElement(
            n.Fragment,
            null,
            r.map((e) =>
              n.createElement(ue, {
                timelineID: e.timelineID,
                key: e.timelineID,
                timelineOffset: e.globalOffsetMS,
                duration: e.nDurationMS,
              }),
            ),
          );
        }),
        ue = n.memo(function (e) {
          const { timelineID: t, timelineOffset: r, duration: i } = e,
            a = y(),
            l = (0, s.Z6)(r.valMS + i);
          let { strState: o, rgEntry: c } = a.FetchTimelineGameModes(r);
          if ("loaded" != o) return null;
          0 == c.length &&
            (c = [
              { time: "0", type: "gamemode", mode: X.Invalid, id: "synthetic" },
            ]);
          let m = [];
          for (let e = 0; e < c.length; e++) {
            const t = (0, s.Z6)(
              e < c.length - 1
                ? parseInt(c[e + 1].time) + r.valMS
                : l.valMS - 1,
            );
            m.push(
              me({
                view: a,
                entry: c[e],
                nGlobalEntryEndMS: t,
                nGlobalTLStartMS: r,
              }),
            );
          }
          return n.createElement(n.Fragment, null, m);
        });
      var he = r(92310),
        _e = r(53643);
      const fe = n.createContext({
        bInContainer: null,
        bContainerFocus: null,
        nMouseClientXPX: null,
        globalMouseXPX: null,
        scrollWindowMouseXPX: null,
        fnRegisterMouseEvent: null,
      });
      function ge(e) {
        const { children: t } = e,
          [r, a] = (0, n.useState)(),
          [l, o] = (0, n.useState)(),
          [c, m] = (0, n.useState)(),
          u = (0, n.useRef)(),
          h = y(),
          _ = (0, i.SZ)(() => h.GetScrollableWidthPX()),
          f = (0, i.SZ)(() => h.GetVisualWindowStartPX()),
          g = (0, i.SZ)(() => h.GetScrollWindowWidth()),
          S = (0, i.SZ)(() => h.GetScrollWindowOffset()),
          b = n.useMemo(() => {
            if (u.current) {
              const e = u.current.getBoundingClientRect();
              return (0, s.bu)(d.Lh(c - e.x, 0, _));
            }
            return (0, s.bu)(0);
          }, [c, f.valPX, _]),
          v = n.useMemo(() => {
            if (u.current) {
              const e = u.current.getBoundingClientRect(),
                t = _ > g ? S : e.x;
              return (0, s.yj)(d.Lh(c - t, 0, g));
            }
            return (0, s.yj)(0);
          }, [c, S, g, _]),
          P = (0, n.useCallback)(
            (e, t) => (
              u.current && u.current.addEventListener(e, t),
              () => {
                var r;
                return null === (r = u.current) || void 0 === r
                  ? void 0
                  : r.removeEventListener(e, t);
              }
            ),
            [],
          ),
          p = (0, n.useCallback)(() => {
            a(!0);
          }, []),
          M = (0, n.useCallback)(() => {
            a(!1);
          }, []),
          C = (0, n.useCallback)((e) => {
            m(e.clientX);
          }, []),
          T = (0, n.useCallback)((e) => {
            o(!0);
          }, []),
          k = (0, n.useCallback)((e) => {
            o(!1);
          }, []);
        (0, n.useEffect)(() => {
          const e = (0, A.kR)(u.current);
          return (
            e.addEventListener("mousemove", C),
            () => {
              e.removeEventListener("mousemove", C);
            }
          );
        }, [C]);
        const G = (0, n.useMemo)(
          () => ({
            bContainerFocus: l,
            bInContainer: r,
            nMouseClientXPX: c,
            globalMouseXPX: b,
            scrollWindowMouseXPX: v,
            fnRegisterMouseEvent: P,
          }),
          [l, r, c, b, v, P],
        );
        return n.createElement(
          fe.Provider,
          { value: G },
          n.createElement(
            "div",
            {
              ref: u,
              onMouseOver: T,
              onFocus: T,
              onMouseOut: k,
              onBlur: k,
              onMouseEnter: p,
              onMouseLeave: M,
              className: _e.MouseListenerContainer,
            },
            t,
          ),
        );
      }
      function Se() {
        return (0, n.useContext)(fe).globalMouseXPX;
      }
      function be() {
        return (0, n.useContext)(fe).scrollWindowMouseXPX;
      }
      function ve() {
        return (0, n.useContext)(fe).bInContainer;
      }
      function Pe(e, t) {
        const r = (0, n.useContext)(fe).fnRegisterMouseEvent,
          i = (0, n.useRef)(),
          a = (0, n.useCallback)(() => {
            i.current = r(e, t);
          }, [r, t, e]),
          l = (0, n.useCallback)(() => {
            i.current && i.current();
          }, []);
        (0, n.useEffect)(() => (a(), () => l()), [a, l]);
      }
      var pe = r(58422),
        Me = r(69159),
        Ce = r(40103),
        ye = r(84174);
      function Te() {
        const e = y(),
          t = (0, O.we)(),
          r = (0, P.Op)();
        return n.useCallback(
          (i, a, l, o) => {
            const s = n.createElement(ke, {
              isCurrentPlayback: l,
              nGlobalOffsetMS: a,
              playbackCoordinator: t,
              timelineView: e,
              fnSetSelectionClipRange: r,
            });
            (0, Ce.yV)(s, i, o);
          },
          [t, e, r],
        );
      }
      function ke(e) {
        const {
            playbackCoordinator: t,
            timelineView: r,
            nGlobalOffsetMS: a,
            fnSetSelectionClipRange: l,
            isCurrentPlayback: s,
          } = e,
          c = (0, i.SZ)(() => r.GetAutoScrollPauseTimeout()),
          m = (0, i.SZ)(() => r.GetVisualWindowStartPX()),
          d = (0, n.useRef)(),
          u = (0, n.useRef)();
        (0, n.useLayoutEffect)(() => {
          d.current && u.current ? u.current.Hide() : (d.current = !0);
        }, [m.valPX]),
          (0, n.useEffect)(() => {
            r.SetAutoScrollPaused(!0);
          }, [r]),
          (0, n.useEffect)(() => {
            c && r.ClearAutoScrollPauseTimeout();
          }, [c, r]);
        return n.createElement(
          Me.xV,
          { refInstance: u },
          n.createElement(
            Me.Zo,
            {
              onSelected: () => {
                t.AddUserMarkerAtGlobalMS(a),
                  t.SeekToGlobalOffsetMS(a.valMS),
                  t.FocusGlobalMS(a);
              },
            },
            n.createElement(
              "div",
              { className: (0, o.Z)(ye.MenuItem, ye.AddUserMarker) },
              n.createElement(Q.KT, null),
              (0, z.Xx)(
                s
                  ? "#Playback_UserSelectionControls_AddUserMarker"
                  : "#TimelineDialog_AddMarker",
              ),
            ),
          ),
          n.createElement(
            Me.Zo,
            {
              onSelected: () => {
                l(t, a, void 0),
                  t.SeekToGlobalOffsetMS(a.valMS),
                  t.FocusGlobalMS(a);
              },
            },
            n.createElement(
              "div",
              { className: (0, o.Z)(ye.MenuItem, ye.StartEndClip) },
              n.createElement(Q.Eq, { direction: "left" }),
              (0, z.Xx)(
                s
                  ? "#Playback_UserSelectionControls_SetClipStart"
                  : "#TimelineContext_SetClipStart",
              ),
            ),
          ),
          n.createElement(
            Me.Zo,
            {
              onSelected: () => {
                l(t, void 0, a),
                  t.SeekToGlobalOffsetMS(a.valMS),
                  t.FocusGlobalMS(a);
              },
            },
            n.createElement(
              "div",
              { className: (0, o.Z)(ye.MenuItem, ye.StartEndClip) },
              n.createElement(Q.Eq, { direction: "right" }),
              (0, z.Xx)(
                s
                  ? "#Playback_UserSelectionControls_SetClipEnd"
                  : "#TimelineContext_SetClipEnd",
              ),
            ),
          ),
        );
      }
      function Ge(e) {
        const t = (0, O.we)(),
          r = (0, i.SZ)(() => t.GetHidePlayer()),
          [a, l] = (0, n.useState)(!1);
        return r
          ? n.createElement(Re, { setIsActive: l })
          : n.createElement(Xe, { bActive: a, setIsActive: l });
      }
      const Re = (0, n.memo)(function (e) {
          const { setIsActive: t } = e,
            r = ve(),
            a = y(),
            l = (0, i.SZ)(() => a.GetScrollableWidthPX()),
            c = (0, _.fB)(100),
            m = (0, n.useCallback)(
              (e) => {
                a.GetAutoScrollPaused() || c(() => a.ScrollToOffset(e));
              },
              [c, a],
            );
          (0, n.useEffect)(() => {
            a.ScrollToEnd();
          }, [a]),
            (0, n.useEffect)(() => {
              m(l);
            }, [l, m]);
          const d = a.ConvertPXToTimelineRelativeMS((0, s.bu)(l));
          return n.createElement(
            "div",
            {
              className: (0, o.Z)(pe.PlayHeadContainer),
              style: { transform: `translateX( calc(${l}px - 50% ))` },
            },
            n.createElement(Ee, {
              setIsActive: t,
              timelinePlaytimeMS: d.valMS,
              bShowContent: r,
            }),
          );
        }),
        Xe = (0, n.memo)(function (e) {
          const { bActive: t, setIsActive: r } = e,
            a = (0, O.we)(),
            l = (0, i.SZ)(() => a.GetGlobalMSPlaytime()),
            c = y(),
            m = (0, i.SZ)(() => c.ConvertGlobalMSToGlobalPXOffset(l)),
            u = Se(),
            h = (function (e, t, r, a, l) {
              const o = (0, n.useRef)(),
                c = (0, i.SZ)(() => t.GetScrollableWidthPX()),
                m = (0, i.SZ)(() => t.GetScrollWindowWidth()),
                [u, h] = (0, n.useState)(),
                _ = (0, n.useMemo)(
                  () => ({
                    rightBreakpoint: (0, s.yj)(m * wt),
                    leftBreakpoint: (0, s.yj)(m * It),
                  }),
                  [m],
                ),
                f = (0, n.useMemo)(() => 0.005 * c, [c]),
                g = (0, n.useRef)();
              (0, n.useEffect)(
                () => () => {
                  g.current && cancelAnimationFrame(g.current);
                },
                [],
              );
              const S = n.useCallback(
                (e, t, r, n) => {
                  n(e)
                    ? (h(
                        d.Lh(
                          e.GetVisualWindowStartPX().valPX + t,
                          0,
                          e.GetScrollableWidthPX(),
                        ),
                      ),
                      cancelAnimationFrame(g.current))
                    : (e.ScrollBy(r),
                      h((t) => d.Lh(t + r, 0, e.GetScrollableWidthPX())),
                      (g.current = requestAnimationFrame(() => S(e, t, r, n))));
                },
                [h],
              );
              return (
                (0, n.useEffect)(() => {
                  if ((g.current && cancelAnimationFrame(g.current), r))
                    if (
                      e.valPX < _.leftBreakpoint.valPX &&
                      !t.BReachedMinScroll()
                    ) {
                      if (e.valPX <= o.current) {
                        const r =
                          Math.max(
                            -1,
                            (e.valPX - _.leftBreakpoint.valPX) /
                              _.leftBreakpoint.valPX,
                          ) * f;
                        g.current = requestAnimationFrame(() =>
                          S(t, e.valPX, r, t.BReachedMinScroll),
                        );
                      }
                      o.current = e.valPX;
                    } else if (
                      e.valPX > _.rightBreakpoint.valPX &&
                      !t.BReachedMaxScroll()
                    ) {
                      if (e.valPX >= o.current) {
                        const r =
                          Math.min(
                            1,
                            (e.valPX - _.rightBreakpoint.valPX) /
                              (m - _.rightBreakpoint.valPX),
                          ) * f;
                        g.current = requestAnimationFrame(() =>
                          S(t, e.valPX, r, t.BReachedMaxScroll),
                        );
                      }
                      o.current = e.valPX;
                    } else h(d.Lh(l.valPX, 0, c));
                  else h(a.valPX);
                }, [r, _, f, e.valPX, a.valPX, l.valPX, c, t, S, m]),
                u
              );
            })(be(), c, t, m, u),
            _ = (0, n.useMemo)(
              () =>
                t
                  ? c.ConvertPXToTimelineRelativeMS((0, s.bu)(h)).valMS
                  : c.ConvertGlobalMSToTimelineMS(l).nTimelineOffsetMS.valMS,
              [t, h, l, c],
            );
          return (
            (0, n.useEffect)(() => {
              if (!t) return;
              const e = c.ConvertPXOffsetToGlobalMSOrNone((0, s.bu)(h));
              e && a.SetPlaytimeFromGlobalMS(e);
            }, [h, t, a, c]),
            n.createElement(
              "div",
              {
                className: (0, o.Z)(
                  pe.PlayheadInteractionCtn,
                  t && pe.ActiveCtn,
                ),
              },
              n.createElement(
                "div",
                {
                  className: (0, o.Z)(pe.PlayHeadContainer, t && pe.Active),
                  style: { transform: `translateX( calc(${h}px - 50% ))` },
                },
                n.createElement(Ee, {
                  setIsActive: r,
                  timelinePlaytimeMS: _,
                  bShowContent: !0,
                }),
              ),
            )
          );
        }),
        Ee = (0, n.memo)(function (e) {
          ve();
          const { setIsActive: t, timelinePlaytimeMS: r, bShowContent: i } = e,
            a = (0, n.useCallback)((e) => {
              e.stopPropagation();
            }, []),
            l = (0, n.useCallback)((e) => {
              e.stopPropagation();
            }, []);
          return n.createElement(
            "div",
            {
              className: (0, o.Z)(pe.PlayHeadContent, i && pe.Show),
              onMouseOver: a,
              onMouseOut: l,
              onFocus: a,
              onBlur: l,
            },
            n.createElement(Oe, { setIsActive: t }),
          );
        }),
        Oe = n.memo(function (e) {
          const { setIsActive: t } = e,
            r = (0, O.we)(),
            i = Te(),
            a = (0, n.useCallback)(
              (e) => {
                if (0 != e.button) return;
                const r = (0, A.RA)(e);
                let n, i;
                const a = () => {
                  t(!0), n();
                };
                r.addEventListener("mousemove", a),
                  (n = () => r.removeEventListener("mousemove", a));
                const l = () => {
                  t(!1), n(), i();
                };
                r.addEventListener("mouseup", l),
                  (i = () => r.removeEventListener("mouseup", l));
              },
              [t],
            ),
            l = (0, n.useCallback)(
              (e) => {
                let t = r.GetCurrentPlaybackGlobalMS(0);
                i(e, (0, s.Z6)(t.nGlobalOffsetMS), !0, {
                  bDisableMouseOverlay: !0,
                }),
                  e.stopPropagation(),
                  e.preventDefault();
              },
              [r, i],
            );
          return n.createElement(
            "div",
            { className: pe.PlayHead, onMouseDown: a, onContextMenu: l },
            n.createElement(Be, null),
          );
        });
      function Be(e) {
        return n.createElement(
          "svg",
          Object.assign({}, e, {
            width: "12",
            height: "70",
            viewBox: "0 0 12 70",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          }),
          n.createElement("rect", {
            x: "5",
            y: "4",
            width: "2",
            height: "90",
            fill: "currentColor",
          }),
          n.createElement("path", {
            d: "M6 6L0.803849 -9.78799e-07L11.1962 -7.02746e-08L6 6Z",
            fill: "currentColor",
          }),
        );
      }
      function we(e) {
        const t = (0, n.useContext)(fe);
        return t.bInContainer
          ? n.createElement(Ie, { globalMouseXPX: t.globalMouseXPX.valPX || 0 })
          : null;
      }
      const Ie = n.memo(function (e) {
          const { globalMouseXPX: t } = e,
            r = ve(),
            a = y(),
            l = (0, O.we)(),
            c = (0, n.useContext)(fe).bContainerFocus,
            m = Te(),
            u = (0, i.SZ)(() => a.ConvertPXToTimelineRelativeMS((0, s.bu)(t))),
            h = (0, n.useCallback)(
              (e) => {
                if (!c) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  r = d.Lh(e.clientX - t.x, 0, t.width),
                  n = a.ConvertPXOffsetToGlobalMSOrNone((0, s.bu)(r));
                n && l.SetPlaytimeFromGlobalMS(n);
              },
              [c, l, a],
            ),
            _ = (0, n.useCallback)(
              (e) => {
                if (!c) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  r = d.Lh(e.clientX - t.x, 0, t.width),
                  n = a.ConvertPXOffsetToGlobalMSOrNone((0, s.bu)(r));
                n &&
                  (m(e, n, !1, { bDisableMouseOverlay: !0 }),
                  e.preventDefault(),
                  e.stopPropagation());
              },
              [c, a, m],
            );
          return (
            Pe("click", h),
            Pe("contextmenu", _),
            n.createElement(
              "div",
              {
                className: he.GhostPlayheadCtn,
                style: { transform: `translateX( calc(${t}px - 50% ))` },
              },
              n.createElement(Le, null),
              n.createElement(
                "div",
                { className: (0, o.Z)(he.SeekTimeContainer, r && he.Show) },
                u && (0, T.SF)(u.valMS / 1e3, !1),
              ),
            )
          );
        }),
        De = (0, n.memo)(function (e) {
          const t = (0, O.we)(),
            r = parseInt(he.thumbnailWidth),
            i = (0, Y.sC)(t.GetGameID(), e.globalMS, r, !1),
            a = Boolean(i)
              ? n.createElement("img", { src: i })
              : n.createElement("div", null);
          return n.createElement(
            "div",
            { className: he.GhostPlayheadTooltip },
            a,
          );
        }),
        Fe = (0, n.memo)(function (e) {
          const { globalMS: t } = e,
            r = t - (t % 9e3);
          return n.createElement(De, { key: r, globalMS: r });
        }),
        Le = (0, n.memo)(function () {
          const e = y(),
            t = Se(),
            r = (0, i.SZ)(() => e.ConvertPXOffsetToGlobalMSOrNone(t)),
            a = ve(),
            l = (0, O.we)(),
            o = (0, i.SZ)(() => l.GetHidePlayer());
          if (!r) return null;
          if (!a) return null;
          const s = o ? "bottom" : "top";
          return n.createElement(
            K.HP,
            {
              toolTipContent: n.createElement(Fe, { globalMS: r.valMS }),
              direction: s,
              nDelayShowMS: 0,
              nBodyDistance: 8,
            },
            n.createElement(
              "div",
              { className: he.GhostPlayheadContent },
              n.createElement(Be, { className: he.GhostPlayhead }),
            ),
          );
        });
      var We = r(83047);
      const xe = (0, n.memo)(function () {
          const [e, t] = (0, n.useState)("none");
          return (0, P.q1)()
            ? n.createElement(Ae, {
                activeControlState: e,
                setActiveControlState: t,
              })
            : null;
        }),
        Ae = (0, n.memo)(function (e) {
          const { activeControlState: t, setActiveControlState: r } = e,
            i = (0, P.NN)(),
            a = (0, P.mo)();
          return n.createElement(
            "div",
            { className: We.RangeControls },
            i &&
              n.createElement(Ne, {
                activeControlState: t,
                setActiveControlState: r,
              }),
            n.createElement(
              "div",
              {
                className: (0, o.Z)(
                  We.HoverRangePreviewCtn,
                  a && "none" === t && We.Show,
                ),
              },
              a && n.createElement(ze, null),
            ),
          );
        }),
        ze = (0, n.memo)(function () {
          const e = (0, P.jg)(),
            t = y(),
            r = (0, i.SZ)(
              () => t.ConvertGlobalMSToGlobalPXOffset(e.globalStartMS).valPX,
            ),
            a = (0, i.SZ)(
              () => t.ConvertGlobalMSToGlobalPXOffset(e.globalEndMS).valPX,
            );
          return n.createElement(
            "div",
            { className: (0, o.Z)(We.RangePreview) },
            n.createElement(
              "div",
              { className: We.TrackRangeControls },
              n.createElement(qe, { direction: "left", offsetPX: r }),
              n.createElement($e, { startOffsetPX: r, endOffsetPX: a }),
              n.createElement(qe, { direction: "right", offsetPX: a }),
            ),
          );
        }),
        Ne = (0, n.memo)(function (e) {
          const { activeControlState: t, setActiveControlState: r } = e,
            [a, l] = (0, n.useState)(),
            [s, c] = (0, n.useState)(),
            m = (0, P.wR)(),
            d = (0, P.oR)(),
            u = y(),
            h = (0, i.SZ)(() => u.ConvertGlobalMSToGlobalPXOffset(m).valPX),
            _ = (0, i.SZ)(() => u.ConvertGlobalMSToGlobalPXOffset(d).valPX),
            f = (0, n.useCallback)(
              (e) => {
                "none" === t && e.stopPropagation();
              },
              [t],
            ),
            g = (0, n.useCallback)(
              (e) => {
                "none" === t && e.stopPropagation();
              },
              [t],
            );
          return n.createElement(
            "div",
            {
              className: (0, o.Z)(
                We.RangeSelectorCtn,
                "none" !== t && We.Active,
              ),
              onMouseOver: f,
              onMouseOut: g,
              onFocus: f,
              onBlur: g,
            },
            n.createElement(
              "div",
              { className: We.TrackRangeControls },
              n.createElement(Ze, {
                isActive: "left" === t,
                setControlState: r,
                setRangeControlPX: l,
                pxOffset: a,
              }),
              n.createElement($e, {
                startOffsetPX: "left" === t ? a : h,
                endOffsetPX: "right" === t ? s : _,
                className: We.SelectedRangeMask,
              }),
              n.createElement(Ue, {
                isActive: "right" === t,
                setControlState: r,
                setRangeControlPX: c,
                pxOffset: s,
              }),
            ),
          );
        });
      const Ze = (0, n.memo)(function (e) {
          const {
              isActive: t,
              setControlState: r,
              setRangeControlPX: i,
              pxOffset: a,
            } = e,
            l = (0, P.wR)();
          return t
            ? n.createElement(Ve, {
                setControlState: r,
                setRangeControlPX: i,
                pxOffset: a,
              })
            : n.createElement(je, {
                offsetMS: l,
                direction: "left",
                setControlState: r,
                setRangeControlPX: i,
              });
        }),
        Ve = (0, n.memo)(function (e) {
          const { setControlState: t, setRangeControlPX: r, pxOffset: a } = e,
            l = (0, P.x8)(),
            o = (0, P.oR)(),
            c = y(),
            m = (0, O.we)(),
            u = Se(),
            h = be(),
            _ = (0, i.SZ)(() => c.GetScrollableWidthPX()),
            f = (0, i.SZ)(() => c.GetScrollWindowWidth()),
            g = (0, n.useMemo)(
              () => ({
                rightBreakpoint: (0, s.yj)(f * wt),
                leftBreakpoint: (0, s.yj)(f * It),
              }),
              [f],
            ),
            S = (0, n.useMemo)(() => 0.005 * _, [_]);
          return (
            (function (e, t, r, i, a, l, o, c, m) {
              const u = (0, n.useRef)(),
                h = (0, n.useRef)();
              (0, n.useEffect)(
                () => () => {
                  h.current && cancelAnimationFrame(h.current);
                },
                [],
              );
              const _ = n.useCallback(
                (e, t, r, n) => {
                  n(e)
                    ? (m(
                        d.Lh(
                          e.GetVisualWindowStartPX().valPX + t,
                          0,
                          e.GetScrollableWidthPX(),
                        ),
                      ),
                      cancelAnimationFrame(h.current))
                    : (e.ScrollBy(r),
                      m((t) => d.Lh(t + r, 0, e.GetScrollableWidthPX())),
                      h.current && cancelAnimationFrame(h.current),
                      (h.current = requestAnimationFrame(() => _(e, t, r, n))));
                },
                [m],
              );
              (0, n.useEffect)(() => {
                h.current && cancelAnimationFrame(h.current);
                const n = a.ConvertGlobalMSToGlobalPXOffset((0, s.Z6)(l.valMS)),
                  f = a.ConvertGlobalMSToScrollWindowPXOffset(
                    (0, s.Z6)(l.valMS),
                  );
                if (o.valPX > n.valPX) return m(n.valPX), void c("right");
                if (
                  i.valPX < t.leftBreakpoint.valPX &&
                  !a.BReachedMinScroll()
                ) {
                  if (i.valPX <= u.current) {
                    const e =
                      Math.max(
                        -1,
                        (i.valPX - t.leftBreakpoint.valPX) /
                          t.leftBreakpoint.valPX,
                      ) * r;
                    h.current = requestAnimationFrame(() =>
                      _(a, i.valPX, e, a.BReachedMinScroll),
                    );
                  }
                  u.current = i.valPX;
                } else if (
                  i.valPX > t.leftBreakpoint.valPX &&
                  f.valPX > t.rightBreakpoint.valPX &&
                  !a.BReachedMaxScroll()
                ) {
                  if (i.valPX >= u.current) {
                    const e = (e) => {
                        const r = e.ConvertGlobalMSToScrollWindowPXOffset(
                          (0, s.Z6)(l.valMS),
                        );
                        return (
                          e.BReachedMaxScroll() ||
                          r.valPX <= t.rightBreakpoint.valPX
                        );
                      },
                      n =
                        Math.min(
                          1,
                          (i.valPX - t.leftBreakpoint.valPX) /
                            t.leftBreakpoint.valPX,
                        ) * r;
                    h.current = requestAnimationFrame(() =>
                      _(a, i.valPX, n, e),
                    );
                  }
                  u.current = i.valPX;
                } else m(d.Lh(o.valPX, 0, e)), (u.current = i.valPX);
              }, [
                t.leftBreakpoint.valPX,
                t.rightBreakpoint.valPX,
                o.valPX,
                r,
                l.valMS,
                i.valPX,
                c,
                a,
                m,
                l,
                e,
                _,
              ]);
            })(_, g, S, h, c, o, u, t, r),
            (0, n.useEffect)(() => {
              const e = c.ConvertPXOffsetToClosestLessThanGlobalMS(
                (0, s.bu)(a),
              );
              m.SetPlaytimeFromGlobalMS(e), l(e);
            }, [m, a, l, c]),
            n.createElement(qe, { offsetPX: a, direction: "left" })
          );
        }),
        Ue = (0, n.memo)(function (e) {
          const {
              isActive: t,
              setControlState: r,
              setRangeControlPX: i,
              pxOffset: a,
            } = e,
            l = (0, P.oR)();
          return t
            ? n.createElement(He, {
                setControlState: r,
                setRangeControlPX: i,
                pxOffset: a,
              })
            : n.createElement(je, {
                offsetMS: l,
                direction: "right",
                setControlState: r,
                setRangeControlPX: i,
              });
        }),
        He = (0, n.memo)(function (e) {
          const { setControlState: t, setRangeControlPX: r, pxOffset: a } = e,
            l = (0, P.pT)(),
            o = (0, P.wR)(),
            c = y(),
            m = (0, O.we)(),
            u = Se(),
            h = be(),
            _ = (0, i.SZ)(() => c.GetScrollableWidthPX()),
            f = (0, i.SZ)(() => c.GetScrollWindowWidth()),
            g = (0, n.useMemo)(
              () => ({
                rightBreakpoint: (0, s.yj)(f * wt),
                leftBreakpoint: (0, s.yj)(f * It),
              }),
              [f],
            ),
            S = (0, n.useMemo)(() => 0.005 * _, [_]);
          return (
            (function (e, t, r, i, a, l, o, c, m, u) {
              const h = (0, n.useRef)(),
                _ = (0, n.useRef)();
              (0, n.useEffect)(
                () => () => {
                  _.current && cancelAnimationFrame(_.current);
                },
                [],
              );
              const f = n.useCallback(
                (e, t, r, n) => {
                  n(e)
                    ? (u(
                        d.Lh(
                          e.GetVisualWindowStartPX().valPX + t,
                          0,
                          e.GetScrollableWidthPX(),
                        ),
                      ),
                      cancelAnimationFrame(_.current))
                    : (e.ScrollBy(r),
                      u((t) => d.Lh(t + r, 0, e.GetScrollableWidthPX())),
                      _.current && cancelAnimationFrame(_.current),
                      (_.current = requestAnimationFrame(() => f(e, t, r, n))));
                },
                [u],
              );
              (0, n.useEffect)(() => {
                _.current && cancelAnimationFrame(_.current);
                const n = l.ConvertGlobalMSToGlobalPXOffset((0, s.Z6)(o.valMS)),
                  g = l.ConvertGlobalMSToScrollWindowPXOffset(
                    (0, s.Z6)(o.valMS),
                  );
                if (c.valPX < n.valPX) return u(n.valPX), void m("left");
                if (
                  a.valPX > r.rightBreakpoint.valPX &&
                  !l.BReachedMaxScroll()
                ) {
                  if (a.valPX >= h.current) {
                    const e =
                      Math.min(
                        1,
                        (a.valPX - r.rightBreakpoint.valPX) /
                          (t - r.rightBreakpoint.valPX),
                      ) * i;
                    _.current = requestAnimationFrame(() =>
                      f(l, a.valPX, e, l.BReachedMaxScroll),
                    );
                  }
                  h.current = a.valPX;
                } else if (
                  a.valPX < r.rightBreakpoint.valPX &&
                  g.valPX < r.leftBreakpoint.valPX &&
                  a.valPX <= h.current &&
                  !l.BReachedMinScroll()
                ) {
                  if (a.valPX <= h.current) {
                    const e =
                        Math.max(
                          -1,
                          (a.valPX - r.rightBreakpoint.valPX) /
                            (t - r.rightBreakpoint.valPX),
                        ) * i,
                      n = (e) =>
                        e.ConvertGlobalMSToScrollWindowPXOffset(
                          (0, s.Z6)(o.valMS),
                        ).valPX > r.leftBreakpoint.valPX ||
                        e.BReachedMinScroll();
                    l.ScrollBy(e),
                      (_.current = requestAnimationFrame(() =>
                        f(l, a.valPX, e, n),
                      ));
                  }
                  h.current = a.valPX;
                } else u(d.Lh(c.valPX, 0, e)), (h.current = a.valPX);
              }, [
                r.leftBreakpoint.valPX,
                r.rightBreakpoint.valPX,
                o.valMS,
                i,
                a.valPX,
                m,
                l,
                u,
                e,
                t,
                c.valPX,
                f,
              ]);
            })(_, f, g, S, h, c, o, u, t, r),
            (0, n.useEffect)(() => {
              const e = c.ConvertPXOffsetToClosestLessThanGlobalMS(
                (0, s.bu)(a),
              );
              m.SetPlaytimeFromGlobalMS(e), m.SetPlaybackStop(e), l(e);
            }, [m, a, l, c]),
            n.createElement(qe, { offsetPX: a, direction: "right" })
          );
        });
      const je = (0, n.memo)(function (e) {
          const {
              offsetMS: t,
              direction: r,
              setControlState: a,
              setRangeControlPX: l,
            } = e,
            o = y(),
            s = (0, i.SZ)(() => o.ConvertGlobalMSToGlobalPXOffset(t));
          (0, n.useEffect)(
            () => (
              l(void 0),
              () => {
                l(s.valPX);
              }
            ),
            [s, l],
          );
          const c = (0, n.useCallback)(
            (e) => {
              const t = (0, A.RA)(e);
              let n, i;
              const l = () => {
                a(r), n();
              };
              t.addEventListener("mousemove", l),
                (n = () => t.removeEventListener("mousemove", l));
              const o = () => {
                a("none"), n(), i();
              };
              t.addEventListener("mouseup", o),
                (i = () => t.removeEventListener("mouseup", o));
            },
            [r, a],
          );
          return n.createElement(
            "div",
            { className: We.InactiveSelectedRangeControl, onMouseDown: c },
            n.createElement(qe, { offsetPX: s.valPX, direction: r }),
          );
        }),
        $e = (0, n.memo)(function (e) {
          const { startOffsetPX: t, endOffsetPX: r, className: i } = e,
            a = { width: r - t || 0, transform: `translateX(${t}px)` };
          return n.createElement("div", {
            className: (0, o.Z)(We.RangeMask, i),
            style: a,
          });
        }),
        qe = (0, n.memo)(function (e) {
          const { direction: t, offsetPX: r } = e,
            i = { transform: `translateX(${r}px)` };
          return n.createElement(
            "div",
            { className: We.RangeControl, style: i },
            n.createElement(
              "div",
              { className: (0, o.Z)(We.RangeIcon, "left" === t && We.Left) },
              n.createElement(Je, { innerFill: "#171d25", direction: t }),
            ),
          );
        });
      function Je(e) {
        return n.createElement(
          "svg",
          {
            viewBox: "0 0 16 16",
            fill: "currentColor",
            xmlns: "http://www.w3.org/2000/svg",
            style: {
              transform: `rotate(${"right" === e.direction ? 180 : 0}deg)`,
            },
          },
          n.createElement("path", {
            d: "M0 3C0 1.34315 1.34315 0 3 0H16V16H3C1.34315 16 0 14.6569 0 13V3Z",
            fill: "currentColor",
          }),
          n.createElement("rect", {
            x: "9.33203",
            y: "4",
            width: "1.33333",
            height: "8",
            rx: "0.666667",
            fill: e.innerFill,
          }),
          n.createElement("rect", {
            x: "5.33203",
            y: "4",
            width: "1.33333",
            height: "8",
            rx: "0.666667",
            fill: e.innerFill,
          }),
        );
      }
      var Ke = r(7023);
      const Ye = n.memo(function (e) {
          const t = y(),
            r = (0, i.SZ)(() => t.GetVisibleWindowRelativeTimelines());
          return n.createElement(
            n.Fragment,
            null,
            r.map((e) => {
              const r = t.GetTimeRecorded(e.timelineID);
              return n.createElement(Qe, {
                key: e.timelineID,
                startPX: e.nVisibleStartPX,
                timestamp: r,
              });
            }),
          );
        }),
        Qe = n.memo(function (e) {
          const { timestamp: t, startPX: r } = e,
            i = (0, O.we)().GetRecordingMode(),
            a = (0, z.m9)(t);
          return n.createElement(
            "div",
            {
              className: (0, o.Z)(Ke.TimelineRelativeDate, Ke[i]),
              style: { transform: `translateX(${r.valPX}px)` },
            },
            a,
          );
        });
      var et = r(90722);
      const tt = (0, n.memo)(function (e) {
        const t = y(),
          r = (0, i.SZ)(() => t.GetWindowRelativeRecordings());
        return n.createElement(
          n.Fragment,
          null,
          r.map((e) =>
            n.createElement(rt, {
              key: e.recordingID,
              startPX: e.nStartPX.valPX,
              endPX: e.nEndPX.valPX,
            }),
          ),
        );
      });
      function rt(e) {
        const { endPX: t, startPX: r } = e,
          i = { width: t - r || 0, transform: `translateX(${r}px)` };
        return n.createElement("div", {
          className: et.RecordingDecorator,
          style: i,
        });
      }
      var nt = r(88068);
      const it = (0, n.memo)(function (e) {
          const t = y(),
            r = (0, i.SZ)(() => t.GetWindowRelativeClips());
          return n.createElement(
            n.Fragment,
            null,
            r.map((e) =>
              n.createElement(at, {
                key: e.clipID,
                startPX: e.nStartPX.valPX,
                endPX: e.nEndPX.valPX,
              }),
            ),
          );
        }),
        at = (0, n.memo)(function (e) {
          const { endPX: t, startPX: r } = e,
            i = { width: t - r || 0, transform: `translateX(${r}px)` };
          return n.createElement("div", {
            className: nt.ClipDecorator,
            style: i,
          });
        });
      var lt = r(15352);
      function ot(e, t) {
        return e.globalOffsetMS.valMS - t.globalOffsetMS.valMS;
      }
      function st(e, t) {
        return parseInt(e.time) - parseInt(t.time);
      }
      function ct(e) {
        const t = y(),
          r = (0, i.SZ)(() => t.GetTimelinesInWindow()),
          a = n.useMemo(() => {
            const e = [...r].sort(ot);
            let i = [];
            for (const r of e) {
              const e = r.globalOffsetMS,
                { strState: n, rgEntry: a } = t.FetchTimelineEntries(
                  ["timestamp"],
                  e,
                );
              if ("loaded" != n) continue;
              let l;
              a.sort(st);
              for (let r of a) {
                let n = r;
                if ((null == l ? void 0 : l.title) == n.title) continue;
                l = n;
                const a = (0, s.Z6)(parseInt(r.time) + e.valMS),
                  o = t.ConvertGlobalMSToGlobalPXOffset(a);
                i.push({ timestamp: n, nOffsetPX: o });
              }
            }
            let a = [];
            for (let e = 0; e < i.length; e++) {
              const { timestamp: t, nOffsetPX: r } = i[e];
              let l;
              e < i.length - 1 && (l = i[e + 1].nOffsetPX),
                a.push(
                  n.createElement(mt, {
                    key: t.time + t.title,
                    startPX: r,
                    endPX: l,
                    title: t.title,
                  }),
                );
            }
            return a;
          }, [t, r]);
        return n.createElement(n.Fragment, null, a);
      }
      function mt(e) {
        const { title: t, startPX: r, endPX: i } = e;
        let a = {
          transform: `translateX(${r.valPX}px)`,
          width: i ? i.valPX - r.valPX + "px" : void 0,
        };
        return n.createElement(
          "div",
          { className: lt.TimelineRelativeTimestampContainer, style: a },
          n.createElement(
            "div",
            { className: lt.TimelineRelativeTimestamp },
            t,
          ),
        );
      }
      var dt,
        ut = r(7610),
        ht = r(81768);
      function _t() {
        const e = (function (e) {
          const t = (0, v.D0)().find((t) => t.game_id() == e);
          if (!t) return dt.NotRecording;
          switch (t.recording_type()) {
            default:
            case 0:
            case 1:
              return dt.NotRecording;
            case 2:
              return dt.ManualRecording;
            case 3:
              return dt.BackgroundRecording;
          }
        })((0, O.we)().GetGameID());
        return e === dt.NotRecording || e === dt.NotRunning
          ? null
          : n.createElement(ft, null);
      }
      function ft(e) {
        const t = (0, O.we)(),
          r = (0, i.SZ)(() => t.GetIsLiveEdge()),
          a = n.useCallback(() => {
            t.SetHidePlayer(!1);
            const e = t.GetLiveEdgeMS();
            t.SeekToGlobalOffsetMS(e.valMS), t.FocusGlobalMS(e);
          }, [t]);
        return n.createElement(
          K.HP,
          {
            className: ht.GoLiveButtonCtn,
            toolTipContent: (0, z.Xx)("#Playback_JumpToLatest"),
            direction: "bottom",
          },
          n.createElement(
            F.zx,
            {
              disabled: r,
              onClick: a,
              className: (0, o.Z)(ht.GoLiveButton, r && ht.IsLive),
            },
            n.createElement(Q.sR, null),
          ),
        );
      }
      !(function (e) {
        (e.NotRunning = "NotRunning"),
          (e.NotRecording = "NotRecording"),
          (e.ManualRecording = "ManualRecording"),
          (e.BackgroundRecording = "BackgroundRecording"),
          (e.ForeverRecording = "ForeverRecording");
      })(dt || (dt = {}));
      var gt = r(94580),
        St = r(16826);
      function bt(e) {
        const t = y(),
          r = (0, P.NN)(),
          a = (0, P._H)(),
          l = (0, O.we)(),
          s = (0, i.SZ)(() => t.GetCurrentZoomScale()),
          c = (0, i.SZ)(() => t.GetMaxZoomScale()),
          m = (0, n.useCallback)(() => {
            const e = vt(t, l, r, a);
            t.ZoomIn(e);
          }, [r, l, a, t]),
          d = (0, n.useCallback)(() => {
            const e = vt(t, l, r, a);
            t.ZoomOut(e);
          }, [r, l, a, t]);
        let u = f.length - 1,
          h = f.findIndex((e) => c >= e);
        f[h] !== c && (h = Math.max(h - 1, 0));
        let _ = f.findIndex((e) => s >= e);
        (_ = -1 == _ ? f.length - 1 : _),
          f[_] !== s && (_ = Math.max(_ - 1, 0));
        let g = { width: `${(((_ - h) / (u - h)) * 100).toFixed(0)}%` };
        return n.createElement(
          "div",
          { className: gt.ZoomControls },
          n.createElement(
            K.HP,
            {
              className: gt.ZoomTooltipCtn,
              direction: "bottom",
              toolTipContent: (0, z.Xx)("#TimelineDialog_Decrease_Resolution"),
            },
            n.createElement(
              F.zx,
              {
                disabled: s >= c,
                className: (0, o.Z)(gt.ZoomIcon, s >= c && gt.Disabled),
                onClick: d,
              },
              n.createElement(St.WF_, null),
            ),
          ),
          n.createElement(
            "div",
            { className: gt.ResolutionCtn },
            n.createElement("div", { className: gt.ResolutionFill, style: g }),
          ),
          n.createElement(
            K.HP,
            {
              className: gt.ZoomTooltipCtn,
              direction: "bottom",
              toolTipContent: (0, z.Xx)("#TimelineDialog_Increase_Resolution"),
            },
            n.createElement(
              F.zx,
              {
                disabled: s <= f[u],
                className: (0, o.Z)(gt.ZoomIcon, s <= f[u] && gt.Disabled),
                onClick: m,
              },
              n.createElement(St.mm_, null),
            ),
          ),
        );
      }
      function vt(e, t, r, n) {
        const i = e.GetVisualWindowStartPX(),
          a = e.GetVisualWindowEndPX(),
          l = t.GetGlobalMSPlaytime();
        if (l.valMS) {
          const t = l
            ? Math.floor(e.ConvertGlobalMSToGlobalPXOffset(l).valPX)
            : 0;
          if (t > i.valPX && t < a.valPX) return t;
        }
        if (r) {
          const t =
              (n.nGlobalEndMS.valMS - n.nGlobalStartMS.valMS) / 2 +
              n.nGlobalStartMS.valMS,
            r = l
              ? Math.floor(
                  e.ConvertGlobalMSToGlobalPXOffset((0, s.Z6)(t)).valPX,
                )
              : 0;
          if (r > i.valPX && r < a.valPX) return r;
        }
      }
      var Pt = r(88199),
        pt = r(33337);
      const Mt = "--:--";
      function Ct() {
        const e = (0, O.we)(),
          t = (0, i.SZ)(() => e.GetTimelineRelativePlayback()),
          r = (0, n.useMemo)(
            () =>
              isNaN(t.timelineDuration)
                ? Mt
                : (0, T.SF)(t.timelinePlaybackMS.valMS / 1e3, !1),
            [t.timelineDuration, t.timelinePlaybackMS.valMS],
          ),
          a = (0, n.useMemo)(
            () =>
              isNaN(t.timelineDuration)
                ? Mt
                : (0, T.SF)(t.timelineDuration / 1e3, !1),
            [t.timelineDuration],
          );
        return n.createElement("div", { className: pt.TimeBar }, `${r} / ${a}`);
      }
      function yt() {
        const e = (0, O.we)(),
          t = (0, i.SZ)(() => e.GetGlobalMSPlaytime()),
          { nGlobalEndMS: r, nGlobalStartMS: a } = (0, P._H)(),
          l = (0, n.useMemo)(
            () =>
              t.valMS > r.valMS || t.valMS < a.valMS
                ? Mt
                : (0, T.SF)((t.valMS - a.valMS) / 1e3, !1),
            [t.valMS, r.valMS, a.valMS],
          ),
          s = (0, n.useMemo)(
            () => (0, T.SF)((r.valMS - a.valMS) / 1e3, !1),
            [r.valMS, a.valMS],
          );
        return n.createElement(
          "div",
          { className: (0, o.Z)(pt.TimeBar, pt.RangeSelection) },
          `${l} / ${s}`,
        );
      }
      function Tt() {
        return (0, P.NN)()
          ? n.createElement(yt, null)
          : n.createElement(Ct, null);
      }
      function kt(e) {
        const { children: t, className: r } = e,
          a = (0, O.we)(),
          l = y(),
          s = n.useCallback(
            (e) => {
              const t = e.target.getBoundingClientRect();
              l.SetScrollWindowOffset(t.x), l.SetScrollWindowWidth(t.width);
            },
            [l],
          ),
          c = (0, _.yU)(s),
          m = n.useCallback(
            (e) => {
              if (e.ctrlKey) {
                const t = e.currentTarget.getBoundingClientRect(),
                  r = e.clientX + l.GetVisualWindowStartPX().valPX - t.x;
                e.deltaY > 0 ? l.ZoomOut(r) : l.ZoomIn(r);
              } else l.ScrollBy(e.deltaY);
            },
            [l],
          ),
          d = (0, n.useCallback)(() => {
            l.SetAutoScrollPaused(!0);
          }, [l]),
          u = (0, n.useCallback)(() => {
            l.SetAutoScrollPauseTimeout();
          }, [l]);
        return (
          (function (e, t) {
            const r = (0, i.SZ)(() => t.BInitialized()),
              a = (0, i.SZ)(() => t.GetScrollWindowWidth());
            let l = (0, n.useRef)(!1);
            (0, n.useEffect)(() => {
              if (l.current || !r || a <= 0) return;
              const n = Math.floor(
                t.ConvertGlobalMSToGlobalPXOffset(e.GetGlobalMSPlaytime())
                  .valPX,
              );
              t.ScrollToOffsetCentered(n), (l.current = !0);
            }, [l, e, a, r, t]);
          })(a, l),
          (function (e, t) {
            const r = (0, i.SZ)(() => t.GetScrollWindowWidth()),
              a = (0, i.SZ)(() => t.GetAutoScrollPaused()),
              l = (0, i.SZ)(() => {
                const r = e.GetGlobalMSPlaytime();
                return r && t.BInitialized()
                  ? Math.floor(t.ConvertGlobalMSToGlobalPXOffset(r).valPX)
                  : 0;
              });
            n.useEffect(() => {
              a || e.BIsVideoElementPaused() || t.ScrollToOffsetCentered(l);
            }, [a, l, r, e, t]);
          })(a, l),
          n.createElement(
            "div",
            { onWheel: m, onMouseEnter: d, onMouseLeave: u },
            n.createElement(
              "div",
              { className: ut.LeftControlsAndContent },
              n.createElement(
                "div",
                { ref: c, className: (0, o.Z)(ut.ContentAndGradient, r) },
                t,
                n.createElement(Gt, { timelineView: l }),
              ),
              a.GetRecordingMode() === O.tP.Overlay &&
                n.createElement(_t, null),
              n.createElement(
                "div",
                { className: ut.StartClipRangeButton },
                n.createElement(Pt.H_, null),
              ),
            ),
            n.createElement(
              "div",
              { className: ut.ScrollbarAndSiblings },
              n.createElement(Rt, null),
              n.createElement(
                "div",
                { className: ut.Controls },
                n.createElement(bt, null),
                n.createElement(Tt, null),
              ),
            ),
          )
        );
      }
      const Gt = (0, n.memo)(function (e) {
        const { timelineView: t } = e,
          r = (0, i.SZ)(() => t.GetVisualWindowStartPX()),
          a = (0, i.SZ)(() => t.BReachedMaxScroll());
        return n.createElement(
          "div",
          { className: ut.ScrollGradientCtn },
          n.createElement("div", {
            className: (0, o.Z)(
              ut.FrontGradient,
              0 === r.valPX && ut.HideGradient,
            ),
          }),
          n.createElement("div", {
            className: (0, o.Z)(ut.EndGradient, a && ut.HideGradient),
          }),
        );
      });
      function Rt() {
        const [e, t] = (0, n.useState)({
            scrollBarWidth: 0,
            scrollBarXOffset: 0,
          }),
          r = n.useCallback((e) => {
            const r = e.target.getBoundingClientRect();
            t({ scrollBarWidth: r.width, scrollBarXOffset: r.x });
          }, []),
          a = y(),
          l = (0, i.SZ)(() => a.GetScrollableWidthWithOffsets()),
          s = (0, i.SZ)(() => a.GetVisualWidth()),
          c = (0, n.useMemo)(
            () => (s * e.scrollBarWidth) / l || 0,
            [s, e.scrollBarWidth, l],
          ),
          m = (0, _.yU)(r);
        return n.createElement(
          "div",
          {
            className: (0, o.Z)(
              ut.ScrollBarCtn,
              Math.round(c) === Math.round(e.scrollBarWidth) &&
                ut.HideScrollBar,
            ),
            ref: m,
          },
          n.createElement(Xt, { timelineView: a, scrollSize: e }),
          n.createElement(Bt, {
            scrollSize: e,
            timelineView: a,
            timelineWidth: l,
            thumbWidth: c,
          }),
        );
      }
      function Xt(e) {
        const { timelineView: t, scrollSize: r } = e,
          i = (0, O.we)(),
          a = (function (e, t) {
            const r = (0, n.useRef)(),
              i = (0, n.useRef)(),
              a = (0, n.useCallback)(
                (r) =>
                  (0, s.bu)(
                    (e.GetScrollableWidthWithOffsets() * r) / t.scrollBarWidth,
                  ),
                [t.scrollBarWidth, e],
              ),
              l = (0, n.useCallback)(() => {
                if (!r.current) return;
                const t = e.GetScrollFocusPX(),
                  n = e.GetScrollWindowWidth();
                if (
                  r.current.valPX > t.valPX - 0.1 * n &&
                  r.current.valPX < t.valPX + 0.1 * n
                )
                  return;
                const a = 0.005 * e.GetScrollableWidthWithOffsets(),
                  o = r.current.valPX - t.valPX;
                if (Math.abs(o) > a) {
                  const r = o > 0 ? a : -a;
                  e.ScrollToOffsetCentered(t.valPX + r),
                    (i.current = requestAnimationFrame(() => l()));
                } else e.ScrollToOffsetCentered(r.current.valPX);
              }, [e]),
              o = (0, n.useCallback)(
                (e) => {
                  (r.current = a(e.clientX - t.scrollBarXOffset)),
                    (i.current = requestAnimationFrame(() => l()));
                },
                [a, l, t.scrollBarXOffset],
              ),
              c = (0, n.useCallback)(() => {
                i.current && cancelAnimationFrame(i.current);
              }, []),
              m = (0, n.useCallback)(
                (e) => {
                  r.current = a(e.clientX - t.scrollBarXOffset);
                },
                [a, t.scrollBarXOffset],
              );
            return (
              (0, n.useEffect)(
                () => () => {
                  i.current && cancelAnimationFrame(i.current);
                },
                [],
              ),
              { onMouseDown: o, onMouseMove: m, onMouseUp: c, onMouseLeave: c }
            );
          })(t, r),
          l = (0, n.useCallback)(
            (e) => {
              const n = e + 0.5 * t.GetTimelineGapWidth();
              return d.Lh(
                (n * r.scrollBarWidth) / t.GetScrollableWidthWithOffsets(),
                0,
                r.scrollBarWidth,
              );
            },
            [r.scrollBarWidth, t],
          );
        return n.createElement(
          "div",
          Object.assign({ className: ut.ScrollTrack }, a),
          n.createElement(Et, {
            timelineView: t,
            playbackCoordinator: i,
            fnConvertGlobalPXToTrackPX: l,
          }),
          n.createElement(Ot, {
            timelineView: t,
            fnConvertGlobalPXToTrackPX: l,
          }),
        );
      }
      function Et(e) {
        const {
            timelineView: t,
            playbackCoordinator: r,
            fnConvertGlobalPXToTrackPX: a,
          } = e,
          l = (0, i.SZ)(() => {
            const e = r.GetGlobalMSPlaytime();
            if (e && t.BInitialized()) {
              const r = Math.floor(t.ConvertGlobalMSToGlobalPXOffset(e).valPX);
              return a(r);
            }
            return null;
          });
        if (!l) return null;
        return n.createElement("div", {
          className: ut.PlayHeadAnnotation,
          onClick: () => {
            const e = r.GetGlobalMSPlaytime();
            t.ScrollToCenteredGlobalMS(e);
          },
          style: { transform: `translateX(${l}px)` },
        });
      }
      function Ot(e) {
        const { timelineView: t, fnConvertGlobalPXToTrackPX: r } = e,
          a = (0, P.NN)(),
          l = (0, P._H)(),
          o = (0, i.SZ)(() => {
            if (a && t.BInitialized()) {
              const e = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(l.nGlobalStartMS).valPX,
                ),
                n = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(l.nGlobalEndMS).valPX,
                );
              return { rangeStartPX: r(e), rangeEndPX: r(n) };
            }
            return null;
          });
        if (!o) return null;
        return n.createElement("div", {
          className: ut.RangeAnnotation,
          onClick: () => {
            t.ScrollToCenteredGlobalMS(l.nGlobalStartMS);
          },
          style: {
            width: o.rangeEndPX - o.rangeStartPX,
            transform: `translateX(${o.rangeStartPX}px)`,
          },
        });
      }
      function Bt(e) {
        const {
            scrollSize: t,
            timelineWidth: r,
            thumbWidth: a,
            timelineView: l,
          } = e,
          { thumbPositionPX: o, onMouseDown: s } = (function (e, t, r, a) {
            const [l, o] = (0, n.useState)(!1),
              [s, c] = (0, n.useState)(0),
              m = (0, i.SZ)(() => a.BInitialized()),
              u = (0, i.SZ)(() => a.GetVisualWindowStartPX()),
              h = (0, n.useMemo)(
                () =>
                  m
                    ? d.Lh(
                        (u.valPX * e.scrollBarWidth) / t,
                        0,
                        e.scrollBarWidth - r,
                      )
                    : 0,
                [m, u.valPX, e.scrollBarWidth, t, r],
              ),
              _ = (0, n.useCallback)(
                (t) => {
                  c(h), o(!0);
                  const r = t.nativeEvent.offsetX,
                    n = (0, A.RA)(t);
                  let i, a;
                  const l = (t) => {
                    c(t.clientX - e.scrollBarXOffset - r);
                  };
                  n.addEventListener("mousemove", l),
                    (i = () => n.removeEventListener("mousemove", l));
                  const s = () => {
                    o(!1), i(), a();
                  };
                  n.addEventListener("mouseup", s),
                    (a = () => n.removeEventListener("mouseup", s));
                },
                [h, e.scrollBarXOffset],
              ),
              f = (0, n.useMemo)(
                () => (l ? d.Lh(s, 0, e.scrollBarWidth - r) : h),
                [s, l, h, e.scrollBarWidth, r],
              );
            return (
              (0, n.useEffect)(() => {
                if (l) {
                  const r = (t * f) / e.scrollBarWidth;
                  a.ScrollToOffset(r);
                }
              }, [l, e.scrollBarWidth, f, a, t]),
              { thumbPositionPX: f, onMouseDown: _ }
            );
          })(t, r, a, l);
        return n.createElement("div", {
          className: ut.ScrollThumb,
          style: { width: a, transform: `translateX(${o}px)` },
          onMouseDown: s,
        });
      }
      const wt = 0.85,
        It = 0.15;
      function Dt(e) {
        const { loader: t, className: r, clipSummaries: l } = e,
          s = (0, i.SZ)(() => t.BInitialized()),
          c = (0, O.we)();
        s || n.createElement("div", { className: a.LoadingTimeline });
        let m = (0, o.Z)(a.ScrollAndControlsCtn, r);
        return n.createElement(
          C,
          { loader: t, clipSummaries: l, playbackCoordinator: c },
          n.createElement(
            "div",
            { className: m },
            n.createElement(
              kt,
              { className: a.TimelineScrollContainer },
              n.createElement(Ft, null),
            ),
          ),
        );
      }
      const Ft = (0, n.memo)(function (e) {
        const t = y();
        return (0, i.SZ)(() => t.BInitialized())
          ? n.createElement(Lt, null)
          : null;
      });
      function Lt() {
        const e = y(),
          t = (0, i.SZ)(() => e.GetScrollableWidthPX()),
          r = (0, i.SZ)(() => e.GetVisualWindowStartPX()),
          l = (0, i.SZ)(() => e.GetTimelineGapWidth());
        return n.createElement(
          "div",
          {
            className: a.ContentContainer,
            style: {
              minWidth: t || 0,
              marginRight: 0.5 * l,
              marginLeft: 0.5 * l,
              transform: `translateX(${-r.valPX}px)`,
            },
          },
          n.createElement(
            Wt,
            { id: "recordings", className: a.RecordingDecorators },
            n.createElement(tt, null),
          ),
          n.createElement(
            Wt,
            { id: "clips", className: a.ClipDecorators },
            n.createElement(it, null),
          ),
          n.createElement(
            Wt,
            { id: "game_modes", className: a.GameModes },
            n.createElement(de, null),
          ),
          n.createElement(
            Wt,
            { id: "date_decorators", className: a.DateDecorator },
            n.createElement(Ye, null),
          ),
          n.createElement(
            Wt,
            { id: "ticks", className: a.BackgroundTicks },
            n.createElement(k, null),
          ),
          n.createElement(
            Wt,
            { id: "highlights", className: a.Highlights },
            n.createElement(oe, null),
          ),
          n.createElement(
            Wt,
            { id: "timestamps", className: a.Timestamps },
            n.createElement(ct, null),
          ),
          n.createElement(
            ge,
            null,
            n.createElement(
              Wt,
              { id: "range_selection", className: a.RangeSelector },
              n.createElement(xe, null),
            ),
            n.createElement(
              Wt,
              { id: "seek_scrub", className: a.SeekScrubber },
              n.createElement(we, null),
            ),
            n.createElement(
              Wt,
              { id: "play_head", className: a.PlayHead },
              n.createElement(Ge, null),
            ),
          ),
        );
      }
      function Wt(e) {
        const { children: t, id: r, className: i } = e;
        return n.createElement(
          "div",
          { id: r, className: (0, o.Z)(i, a.AbsoluteLayer) },
          n.createElement("div", { className: a.RelativeLayer }, t),
        );
      }
    },
    77613: (e, t, r) => {
      "use strict";
      r.d(t, { dF: () => S, tP: () => n, we: () => b });
      var n,
        i = r(33940),
        a = r(89526),
        l = r(4306),
        o = r(59621),
        s = r(97578),
        c = r(83315),
        m = r(65689),
        d = r(36041),
        u = r(50796),
        h = r(11837),
        _ = r(77822);
      !(function (e) {
        (e.Overlay = "Overlay"), (e.Clips = "Clips"), (e.Dialog = "Dialog");
      })(n || (n = {}));
      class f {
        constructor(e, t, r) {
          (this.m_gameRecordingVideo = null),
            (this.m_timelineLoader = null),
            (this.m_fnUnregisterLoader = null),
            (this.m_rgListeners = []),
            (this.m_strRecordingID = null),
            (this.m_bHidePlayer = !1),
            (this.m_nPendingSeekSec = -1),
            (this.m_strRecordingIDStop = null),
            (this.m_nPendingStopMS = -1),
            (this.m_fnUnregisterAutorun = []),
            (this.m_rgSeekPerf = []),
            (0, o.rC)(this),
            (this.m_fnGetManifest = t),
            (this.m_gameRecordingVideo = new _.Is()),
            (this.m_eGameRecordingMode = r),
            r === n.Overlay && (this.m_bHidePlayer = !0),
            this.m_fnUnregisterAutorun.push(
              (0, o.U5)(
                () => this.m_gameRecordingVideo.IsAtEnd(),
                (e) => {
                  e && this.PlayNextTimelineRecording();
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, o.U5)(
                () => this.m_gameRecordingVideo.GetPlaybackTime(),
                (e) => {
                  this.m_strRecordingIDStop === this.m_strRecordingID &&
                    this.m_nPendingStopMS > -1 &&
                    this.m_nPendingStopMS <= 1e3 * e &&
                    (this.m_gameRecordingVideo.Pause(),
                    (this.m_nPendingStopMS = -1));
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, o.U5)(
                () => this.m_gameRecordingVideo.BSeekReadyToPlay(),
                (e) => {
                  if (e) {
                    const e = `seeking_${this.GetManifestFromRecordingID(
                      this.m_strRecordingID,
                    )}_${this.m_gameRecordingVideo
                      .GetPlaybackTime()
                      .toFixed(3)}`;
                    try {
                      const t = `measure_${
                          this.m_strRecordingID
                        }_${this.m_gameRecordingVideo
                          .GetPlaybackTime()
                          .toFixed(3)}`,
                        r = performance.measure(t, e);
                      (0, s.hB)(
                        `CGameRecordingVideo:: perf measure ${e} duration ${r.duration}`,
                      ),
                        r && this.m_rgSeekPerf.push(r.duration);
                    } catch (t) {
                      (0, s.hB)(
                        `CGameRecordingVideo:: cant measure ${e}, error: ${t}`,
                      );
                    }
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.SetLoader(e);
        }
        AddEventListener(e) {
          return this.m_rgListeners.push(e), () => h.Zf(this.m_rgListeners, e);
        }
        FireEvent(e, ...t) {
          for (let r of this.m_rgListeners) {
            let n = r[e];
            n instanceof Function && n.apply(r, t);
          }
        }
        dispose() {
          this.m_fnUnregisterAutorun.forEach((e) => e()),
            this.m_fnUnregisterLoader &&
              (this.m_fnUnregisterLoader(), (this.m_fnUnregisterLoader = null));
        }
        SetVideoElement(e) {
          if (e)
            if (((this.m_videoRef = e), this.m_strRecordingID)) {
              const e = this.m_nPendingSeekSec > 0 ? this.m_nPendingSeekSec : 0;
              (this.m_nPendingSeekSec = -1),
                this.ChangePlaybackRecording(this.m_strRecordingID, e);
            } else this.TryPlayInitialTimelineVideo();
          else this.m_gameRecordingVideo.Stop(), (this.m_videoRef = null);
        }
        OnInvalidateRecording(e, t) {
          const r = this.m_fnGetManifest(t);
          this.m_gameRecordingVideo.GetMPDURL() == r &&
            ((0, s.hB)(`Recording invalidated for ${t}. Reloading MPD`),
            this.m_gameRecordingVideo.UpdateMPD());
        }
        BIsVideoElementPaused() {
          var e;
          return (
            (null === (e = this.m_videoRef) || void 0 === e
              ? void 0
              : e.paused) || this.m_gameRecordingVideo.IsPaused()
          );
        }
        BInitialized() {
          return this.m_timelineLoader.BInitialized();
        }
        GetHidePlayer() {
          return this.m_bHidePlayer;
        }
        SetHidePlayer(e) {
          (this.m_bHidePlayer = e),
            e &&
              (this.m_nPendingSeekSec =
                this.m_gameRecordingVideo.GetPlaybackTime());
        }
        GetGameRecordingVideo() {
          return this.m_gameRecordingVideo;
        }
        GetGameID() {
          return this.m_timelineLoader.GetGameID();
        }
        GetLoader() {
          return this.m_timelineLoader;
        }
        SetLoader(e) {
          this.m_timelineLoader != e &&
            (this.m_fnUnregisterLoader && this.m_fnUnregisterLoader(),
            (this.m_timelineLoader = e),
            (this.m_fnUnregisterLoader =
              this.m_timelineLoader.AddEventListener(this)),
            this.TryPlayInitialTimelineVideo());
        }
        SetGetManifest(e) {
          this.m_fnGetManifest = e;
        }
        GetRecordingID() {
          return this.m_strRecordingID;
        }
        GetRecordingMode() {
          return this.m_eGameRecordingMode;
        }
        GetPlaybackStats() {
          if (!this.m_rgSeekPerf.length) return null;
          const e = this.m_rgSeekPerf.length,
            t = this.m_rgSeekPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgSeekPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            n = Math.max(...this.m_rgSeekPerf),
            i = Math.min(...this.m_rgSeekPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: n,
            nMin: i,
            nLength: e,
            nLastVal: this.m_rgSeekPerf[e - 1],
          };
        }
        TryPlayInitialTimelineVideo() {
          if (this.m_timelineLoader.BInitialized())
            if (this.m_eGameRecordingMode === n.Overlay) {
              const e = this.GetLiveEdgeMS();
              this.SeekToGlobalOffsetMS(e.valMS);
            } else {
              const e =
                this.m_timelineLoader.GetFirstRecordingOfLastTimelineSession();
              this.ChangePlaybackRecording(e, 0);
            }
        }
        GetTotalSeconds() {
          return Math.floor(
            this.m_timelineLoader.GetGlobalTimelineEndMS().valMS / 1e3,
          );
        }
        GetTotalMS() {
          return this.m_timelineLoader.GetGlobalTimelineEndMS().valMS;
        }
        GetCurrentPlaybackGlobalMS(e = 0) {
          const t =
            Math.floor(1e3 * this.m_gameRecordingVideo.GetPlaybackTime()) + e;
          return this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
            this.m_strRecordingID,
            t,
            0,
          );
        }
        GetIsLiveEdge() {
          var e;
          const t =
            (null === (e = this.GetCurrentPlaybackGlobalMS()) || void 0 === e
              ? void 0
              : e.nGlobalOffsetMS) || 0;
          return this.GetTotalMS() - t < 1e4;
        }
        GetLiveEdgeMS() {
          const e = this.GetTotalMS(),
            t = Math.max(0, e - 1e4);
          return (0, u.Z6)(t);
        }
        GetTimelineAndOffsetRelativeToCurrentPlayback(e = 0) {
          const t = this.GetCurrentPlaybackGlobalMS(e);
          return (
            t ||
            ((0, s.F0)(
              `failed to find offset for ${
                this.m_strRecordingID
              } at ${Math.floor(
                1e3 * this.m_gameRecordingVideo.GetPlaybackTime(),
              )} MS`,
            ),
            null)
          );
        }
        AddUserMarkerAtCurrentPlayhead() {
          return (0, i.mG)(this, void 0, void 0, function* () {
            const e = this.GetTimelineAndOffsetRelativeToCurrentPlayback();
            if (e) {
              const t = this.m_timelineLoader.GetGameID(),
                { fnCreateUserTimelineMarkers: r } = (0, m.oV)(),
                n = "steam_marker",
                i = yield r(t, {
                  timeline_id: e.strTimelineID,
                  entry_id: "",
                  time: "" + e.nTimelineOffsetMS,
                  type: 5,
                  marker_icon: n,
                  marker_priority: 0,
                });
              1 == i.eResult &&
                this.m_timelineLoader.AddUserMarker(
                  e.strTimelineID,
                  e.nTimelineOffsetMS,
                  n,
                  i.entry_id,
                );
            }
          });
        }
        SeekToGlobalOffsetMS(e) {
          const t = d.Lh(e, 0, this.GetTotalMS()),
            r =
              this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
                t,
                0,
              );
          r &&
            this.SetPlaybackStateFromRecordingIDAndTime(
              r.strRecordingID,
              r.nRecordingOffsetMS / 1e3,
            );
        }
        SeekDeltaMS(e) {
          const t = this.GetCurrentPlaybackGlobalMS();
          if (t) {
            const r = d.Lh(t.nGlobalOffsetMS + e, 0, this.GetTotalMS());
            this.SeekToGlobalOffsetMS(r);
          }
        }
        ConvertGlobaOffsetToRecordingAndRelativeOffset(e) {
          return this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e,
            0,
          );
        }
        SetPlaybackStateFromRecordingIDAndTime(e, t) {
          this.m_videoRef && this.m_strRecordingID === e
            ? this.m_gameRecordingVideo.Seek(t)
            : this.ChangePlaybackRecording(e, t);
        }
        PlayNextTimelineRecording() {
          const e = this.m_timelineLoader.GetNextRecording(
            this.m_strRecordingID,
          );
          e && this.ChangePlaybackRecording(e, 0);
        }
        GetManifestFromRecordingID(e) {
          return this.m_fnGetManifest(e);
        }
        ChangePlaybackRecording(e, t = 0, r) {
          const n = this.m_gameRecordingVideo.IsPaused();
          if (
            this.m_strRecordingID === e &&
            this.m_gameRecordingVideo.IsInitialized()
          )
            return void this.m_gameRecordingVideo.Seek(t);
          if (
            (this.m_gameRecordingVideo.Stop(), (this.m_strRecordingID = e), !e)
          )
            return;
          if (!this.m_videoRef) return void (this.m_nPendingSeekSec = t);
          const i = this.GetManifestFromRecordingID(e);
          this.m_gameRecordingVideo.Start(this.m_videoRef, i, t),
            (r || n) && this.m_gameRecordingVideo.Pause();
        }
        StopPlayback() {
          this.m_gameRecordingVideo.Stop();
        }
        TogglePlayPause() {
          this.m_gameRecordingVideo.IsPaused()
            ? this.m_gameRecordingVideo.GetTimelineDuration() -
                this.m_gameRecordingVideo.GetPlaybackTime() <
              1
              ? this.PlayNextTimelineRecording()
              : this.m_gameRecordingVideo.Play()
            : this.m_gameRecordingVideo.Pause();
        }
        GetGlobalMSPlaytime() {
          const e = this.m_gameRecordingVideo.GetPlaybackTime(),
            t = this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
              this.m_strRecordingID,
              1e3 * e,
              0,
            );
          return t ? (0, u.Z6)(t.nGlobalOffsetMS) : (0, u.Z6)(0);
        }
        SetPlaytimeFromGlobalMS(e) {
          const t = this.m_timelineLoader.GetRecordingLocation(e.valMS, 0, 0);
          t &&
            ((this.m_bHidePlayer = !1),
            this.ChangePlaybackRecording(t.strRecordingID, t.nSeekMS / 1e3));
        }
        ConvertGlobalOffsetToTimelineRelativeOffset(e) {
          return this.m_timelineLoader.GetTimelineOffsetFromGlobal(e, 0);
        }
        GetTimelineDuration(e) {
          if (!this.m_timelineLoader.BInitialized()) return null;
          const t = this.m_timelineLoader.GetTimelineMetadata(e);
          return t ? parseInt(t.metadata.duration_ms()) : null;
        }
        GetTimelineRelativePlayback() {
          const e = this.GetGlobalMSPlaytime(),
            t = this.ConvertGlobalOffsetToTimelineRelativeOffset(e.valMS),
            r = this.GetTimelineDuration(t.strTimelineID);
          return {
            timelinePlaybackMS: t.nTimelineOffsetMS,
            timelineDuration: r,
          };
        }
        AddUserMarkerAtGlobalMS(e) {
          return (0, i.mG)(this, void 0, void 0, function* () {
            const t = this.m_timelineLoader.GetTimelineOffsetFromGlobal(
              e.valMS,
              0,
            );
            if (t) {
              const e = this.m_timelineLoader.GetGameID(),
                { fnCreateUserTimelineMarkers: r } = (0, m.oV)(),
                n = "steam_marker",
                i = yield r(e, {
                  timeline_id: t.strTimelineID,
                  entry_id: "",
                  time: "" + Math.floor(t.nTimelineOffsetMS.valMS),
                  type: 5,
                  marker_icon: n,
                  marker_priority: 0,
                });
              1 == i.eResult &&
                this.m_timelineLoader.AddUserMarker(
                  t.strTimelineID,
                  Math.floor(t.nTimelineOffsetMS.valMS),
                  n,
                  i.entry_id,
                );
            }
          });
        }
        RemoveUserMarker(e, t) {
          this.m_timelineLoader.RemoveUserMarker(e, t);
        }
        UpdateUserMarker(e, t, r) {
          this.m_timelineLoader.UpdateUserMarker(e, t, r);
        }
        GetRichPresence(e) {
          let t = this.m_timelineLoader.CreateTimelineIterator(e, 0);
          return this.m_timelineLoader.GetIteratorRichPresence(t);
        }
        FocusGlobalMS(e) {
          this.FireEvent("OnFocusGlobalMS", e);
        }
        SetPlaybackStop(e) {
          const t = this.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e.valMS,
          );
          t &&
            ((this.m_strRecordingIDStop = t.strRecordingID),
            (this.m_nPendingStopMS = t.nRecordingOffsetMS));
        }
      }
      (0, i.gn)([o.LO], f.prototype, "m_strRecordingID", void 0),
        (0, i.gn)([o.LO], f.prototype, "m_bHidePlayer", void 0),
        (0, i.gn)([o.LO], f.prototype, "m_rgSeekPerf", void 0),
        (0, i.gn)([l.ak], f.prototype, "SetVideoElement", null),
        (0, i.gn)([l.ak], f.prototype, "OnInvalidateRecording", null),
        (0, i.gn)([l.ak], f.prototype, "GetLiveEdgeMS", null),
        (0, i.gn)([l.ak], f.prototype, "StopPlayback", null),
        (0, i.gn)([l.ak], f.prototype, "TogglePlayPause", null);
      const g = a.createContext({ timelinePlaybackCoordinator: null });
      function S(e) {
        const { children: t, mode: r, fnGetManifest: n, loader: i } = e,
          [l] = a.useState(() => new f(i, n, r)),
          o = (0, c.SZ)(() => i.BInitialized());
        (0, a.useEffect)(() => {
          l.SetLoader(i);
        }, [l, i]),
          (0, a.useEffect)(() => {
            l.SetGetManifest(n);
          }, [l, n]),
          (0, a.useEffect)(() => {
            o && l.TryPlayInitialTimelineVideo();
          }, [l, o]),
          (0, a.useEffect)(() => () => l.dispose(), [l]);
        const s = a.useMemo(() => ({ timelinePlaybackCoordinator: l }), [l]);
        return a.createElement(g.Provider, { value: s }, t);
      }
      function b() {
        return (0, a.useContext)(g).timelinePlaybackCoordinator;
      }
    },
    88199: (e, t, r) => {
      "use strict";
      r.d(t, { H_: () => g, QY: () => h, a7: () => f, mp: () => _ });
      var n = r(84343),
        i = r(19304),
        a = r(14826),
        l = r(48704),
        o = r(77613),
        s = r(89526),
        c = r(818),
        m = r(1345),
        d = r.n(m),
        u = r(57605);
      function h(e) {
        const t = (0, o.we)();
        return s.createElement(
          n.HP,
          {
            direction: "top",
            toolTipContent: (0, a.Xx)(
              "#Playback_UserSelectionControls_AddUserMarker",
            ),
          },
          s.createElement(
            u.zx,
            {
              onClick: () => {
                const e = t.GetGlobalMSPlaytime();
                t.AddUserMarkerAtGlobalMS(e),
                  t.SeekToGlobalOffsetMS(e.valMS),
                  t.FocusGlobalMS(e);
              },
              className: (0, i.Z)(
                d().UserSelectionButton,
                d().AddUserMarker,
                e.className,
              ),
            },
            s.createElement(c.KT, null),
          ),
        );
      }
      function _(e) {
        const t = (0, l.q1)(),
          r = (0, l.Op)(),
          m = (0, o.we)();
        if (!t) return null;
        return s.createElement(
          n.HP,
          {
            direction: "top",
            toolTipContent: (0, a.Xx)(
              "#Playback_UserSelectionControls_SetClipStart",
            ),
          },
          s.createElement(
            u.zx,
            {
              onClick: () => {
                const e = m.GetGlobalMSPlaytime();
                r(m, e, void 0),
                  m.SeekToGlobalOffsetMS(e.valMS),
                  m.FocusGlobalMS(e);
              },
              className: (0, i.Z)(
                d().UserSelectionButton,
                d().StartClipRange,
                e.className,
              ),
            },
            s.createElement(c.Eq, { direction: "left" }),
          ),
        );
      }
      function f(e) {
        const t = (0, l.q1)(),
          r = (0, l.Op)(),
          m = (0, o.we)();
        if (!t) return null;
        return s.createElement(
          n.HP,
          {
            direction: "top",
            toolTipContent: (0, a.Xx)(
              "#Playback_UserSelectionControls_SetClipEnd",
            ),
          },
          s.createElement(
            u.zx,
            {
              onClick: () => {
                const e = m.GetGlobalMSPlaytime();
                r(m, void 0, e),
                  m.SeekToGlobalOffsetMS(e.valMS),
                  m.FocusGlobalMS(e);
              },
              className: (0, i.Z)(
                d().UserSelectionButton,
                d().EndClipRange,
                e.className,
              ),
            },
            s.createElement(c.Eq, { direction: "right" }),
          ),
        );
      }
      function g(e) {
        const t = (0, l.q1)(),
          r = (0, l.NN)(),
          m = (0, l.Kc)(),
          h = (0, l.Op)(),
          _ = (0, o.we)();
        if (!t) return null;
        return s.createElement(
          n.HP,
          {
            direction: "top",
            toolTipContent: (0, a.Xx)(
              r
                ? "#SeekBar_Clear_Selection"
                : "#Playback_UserSelectionControls_SetClipStart",
            ),
          },
          s.createElement(
            u.zx,
            {
              onClick: () => {
                if (r) m();
                else {
                  const e = _.GetGlobalMSPlaytime();
                  h(_, e, void 0),
                    _.SeekToGlobalOffsetMS(e.valMS),
                    _.FocusGlobalMS(e);
                }
              },
              className: (0, i.Z)(
                d().UserSelectionButton,
                d().InlineClipControl,
                e.className,
              ),
            },
            r
              ? s.createElement(c.X, null)
              : s.createElement(c.Eq, { direction: "left" }),
          ),
        );
      }
    },
    52430: (e, t, r) => {
      "use strict";
      r.d(t, { qS: () => P, xG: () => k });
      var n = r(45878),
        i = r(50995),
        a = r(68333);
      const l = n.Message;
      class o extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            o.prototype.representation_name || i.aR(o.M()),
            l.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            o.sm_m ||
              (o.sm_m = {
                proto: o,
                fields: {
                  representation_name: {
                    n: 2,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  horizontal_resolution: {
                    n: 3,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  vertical_resolution: {
                    n: 4,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  frame_rate: {
                    n: 5,
                    br: i.FE.readDouble,
                    bw: i.Xc.writeDouble,
                  },
                  bandwidth: {
                    n: 6,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  audio_sample_rate: {
                    n: 7,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  frame_rate_string: {
                    n: 8,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  codec: { n: 9, br: i.FE.readString, bw: i.Xc.writeString },
                  audio_channel_config: {
                    n: 10,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                },
              }),
            o.sm_m
          );
        }
        static MBF() {
          return o.sm_mbf || (o.sm_mbf = i.Bh(o.M())), o.sm_mbf;
        }
        toObject(e = !1) {
          return o.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(o.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(o.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new o();
          return o.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(o.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return o.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(o.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return o.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CMsgVideoGameRecordingRepresentation";
        }
      }
      class s extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            s.prototype.component_name || i.aR(s.M()),
            l.initialize(this, e, 0, -1, [5], null);
        }
        static M() {
          return (
            s.sm_m ||
              (s.sm_m = {
                proto: s,
                fields: {
                  component_name: {
                    n: 1,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  contents: { n: 2, br: i.FE.readUint32, bw: i.Xc.writeUint32 },
                  segment_size: {
                    n: 3,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  file_type: {
                    n: 4,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  representations: { n: 5, c: o, r: !0, q: !0 },
                },
              }),
            s.sm_m
          );
        }
        static MBF() {
          return s.sm_mbf || (s.sm_mbf = i.Bh(s.M())), s.sm_mbf;
        }
        toObject(e = !1) {
          return s.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(s.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(s.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new s();
          return s.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(s.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return s.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(s.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return s.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CMsgVideoGameRecordingComponent";
        }
      }
      class c extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            c.prototype.steamid || i.aR(c.M()),
            l.initialize(this, e, 0, -1, [7], null);
        }
        static M() {
          return (
            c.sm_m ||
              (c.sm_m = {
                proto: c,
                fields: {
                  steamid: {
                    n: 1,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                  app_id: { n: 2, br: i.FE.readUint32, bw: i.Xc.writeUint32 },
                  num_segments: {
                    n: 3,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  length_milliseconds: {
                    n: 4,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  segment_duration_timescale: {
                    n: 5,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  segment_duration: {
                    n: 6,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  components: { n: 7, c: s, r: !0, q: !0 },
                  start_time_ms: {
                    n: 8,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  start_offset_in_timeline_ms: {
                    n: 9,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                },
              }),
            c.sm_m
          );
        }
        static MBF() {
          return c.sm_mbf || (c.sm_mbf = i.Bh(c.M())), c.sm_mbf;
        }
        toObject(e = !1) {
          return c.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(c.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(c.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new c();
          return c.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(c.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(c.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CMsgVideoGameRecordingDef";
        }
      }
      class m extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            m.prototype.segment_number || i.aR(m.M()),
            l.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            m.sm_m ||
              (m.sm_m = {
                proto: m,
                fields: {
                  segment_number: {
                    n: 1,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  segment_size_bytes: {
                    n: 2,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                },
              }),
            m.sm_m
          );
        }
        static MBF() {
          return m.sm_mbf || (m.sm_mbf = i.Bh(m.M())), m.sm_mbf;
        }
        toObject(e = !1) {
          return m.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(m.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(m.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new m();
          return m.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(m.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(m.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_GameRecordingSegmentInfo";
        }
      }
      class d extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            d.prototype.segment_info || i.aR(d.M()),
            l.initialize(this, e, 0, -1, [5], null);
        }
        static M() {
          return (
            d.sm_m ||
              (d.sm_m = {
                proto: d,
                fields: {
                  segment_info: { n: 1, c: m },
                  url_host: { n: 2, br: i.FE.readString, bw: i.Xc.writeString },
                  url_path: { n: 3, br: i.FE.readString, bw: i.Xc.writeString },
                  use_https: { n: 4, br: i.FE.readBool, bw: i.Xc.writeBool },
                  request_headers: { n: 5, c: u, r: !0, q: !0 },
                },
              }),
            d.sm_m
          );
        }
        static MBF() {
          return d.sm_mbf || (d.sm_mbf = i.Bh(d.M())), d.sm_mbf;
        }
        toObject(e = !1) {
          return d.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(d.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(d.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new d();
          return d.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(d.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return d.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(d.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return d.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_GameRecordingSegmentUploadInfo";
        }
      }
      class u extends l {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            u.prototype.name || i.aR(u.M()),
            l.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            u.sm_m ||
              (u.sm_m = {
                proto: u,
                fields: {
                  name: { n: 1, br: i.FE.readString, bw: i.Xc.writeString },
                  value: { n: 2, br: i.FE.readString, bw: i.Xc.writeString },
                },
              }),
            u.sm_m
          );
        }
        static MBF() {
          return u.sm_mbf || (u.sm_mbf = i.Bh(u.M())), u.sm_mbf;
        }
        toObject(e = !1) {
          return u.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(u.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(u.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new u();
          return u.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(u.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(u.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_GameRecordingSegmentUploadInfo_HTTPHeaders";
        }
      }
      const h = n.Message;
      class _ extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            _.prototype.video_manager_clip_id || i.aR(_.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            _.sm_m ||
              (_.sm_m = {
                proto: _,
                fields: {
                  video_manager_clip_id: {
                    n: 1,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                  video_manager_video_id: {
                    n: 2,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                  server_timeline_id: {
                    n: 3,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                  manifest_url: {
                    n: 4,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  duration_ms: {
                    n: 5,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  start_offset_ms: {
                    n: 6,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                },
              }),
            _.sm_m
          );
        }
        static MBF() {
          return _.sm_mbf || (_.sm_mbf = i.Bh(_.M())), _.sm_mbf;
        }
        toObject(e = !1) {
          return _.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(_.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(_.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new _();
          return _.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(_.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(_.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideoManagerClipID";
        }
      }
      class f extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            f.prototype.clip_id || i.aR(f.M()),
            h.initialize(this, e, 0, -1, [9], null);
        }
        static M() {
          return (
            f.sm_m ||
              (f.sm_m = {
                proto: f,
                fields: {
                  clip_id: {
                    n: 1,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                  gameid: {
                    n: 2,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                  date_recorded: {
                    n: 4,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  total_file_size_bytes: {
                    n: 7,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                  video_ids: { n: 9, c: _, r: !0, q: !0 },
                  owner_steamid: {
                    n: 10,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                  upload_complete: {
                    n: 11,
                    br: i.FE.readBool,
                    bw: i.Xc.writeBool,
                  },
                  duration_ms: {
                    n: 12,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                },
              }),
            f.sm_m
          );
        }
        static MBF() {
          return f.sm_mbf || (f.sm_mbf = i.Bh(f.M())), f.sm_mbf;
        }
        toObject(e = !1) {
          return f.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(f.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(f.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new f();
          return f.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(f.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(f.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingClip";
        }
      }
      class g extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            g.prototype.clip || i.aR(g.M()),
            h.initialize(this, e, 0, -1, [3], null);
        }
        static M() {
          return (
            g.sm_m ||
              (g.sm_m = {
                proto: g,
                fields: {
                  clip: { n: 2, c: f },
                  video_def: { n: 3, c, r: !0, q: !0 },
                },
              }),
            g.sm_m
          );
        }
        static MBF() {
          return g.sm_mbf || (g.sm_mbf = i.Bh(g.M())), g.sm_mbf;
        }
        toObject(e = !1) {
          return g.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(g.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(g.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new g();
          return g.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(g.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(g.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CreateShareClip_Request";
        }
      }
      class S extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            S.prototype.clip || i.aR(S.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            S.sm_m || (S.sm_m = { proto: S, fields: { clip: { n: 1, c: f } } }),
            S.sm_m
          );
        }
        static MBF() {
          return S.sm_mbf || (S.sm_mbf = i.Bh(S.M())), S.sm_mbf;
        }
        toObject(e = !1) {
          return S.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(S.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(S.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new S();
          return S.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(S.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(S.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CreateShareClip_Response";
        }
      }
      class b extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            b.prototype.clip_id || i.aR(b.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            b.sm_m ||
              (b.sm_m = {
                proto: b,
                fields: {
                  clip_id: {
                    n: 2,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                },
              }),
            b.sm_m
          );
        }
        static MBF() {
          return b.sm_mbf || (b.sm_mbf = i.Bh(b.M())), b.sm_mbf;
        }
        toObject(e = !1) {
          return b.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(b.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(b.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new b();
          return b.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(b.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(b.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteSharedClip_Request";
        }
      }
      class v extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), h.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return v.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new v();
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new v();
          return v.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteSharedClip_Response";
        }
      }
      class P extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            P.prototype.clip_id || i.aR(P.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            P.sm_m ||
              (P.sm_m = {
                proto: P,
                fields: {
                  clip_id: {
                    n: 2,
                    br: i.FE.readFixed64String,
                    bw: i.Xc.writeFixed64String,
                  },
                },
              }),
            P.sm_m
          );
        }
        static MBF() {
          return P.sm_mbf || (P.sm_mbf = i.Bh(P.M())), P.sm_mbf;
        }
        toObject(e = !1) {
          return P.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(P.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(P.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new P();
          return P.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(P.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return P.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(P.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return P.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetSingleSharedClip_Request";
        }
      }
      class p extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            p.prototype.clip || i.aR(p.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            p.sm_m || (p.sm_m = { proto: p, fields: { clip: { n: 1, c: f } } }),
            p.sm_m
          );
        }
        static MBF() {
          return p.sm_mbf || (p.sm_mbf = i.Bh(p.M())), p.sm_mbf;
        }
        toObject(e = !1) {
          return p.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(p.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(p.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new p();
          return p.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(p.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(p.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetSingleSharedClip_Response";
        }
      }
      class M extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            M.prototype.recording_id || i.aR(M.M()),
            h.initialize(this, e, 0, -1, [4], null);
        }
        static M() {
          return (
            M.sm_m ||
              (M.sm_m = {
                proto: M,
                fields: {
                  recording_id: {
                    n: 1,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                  component_name: {
                    n: 2,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  representation_name: {
                    n: 3,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  segments_to_store: { n: 4, c: m, r: !0, q: !0 },
                },
              }),
            M.sm_m
          );
        }
        static MBF() {
          return M.sm_mbf || (M.sm_mbf = i.Bh(M.M())), M.sm_mbf;
        }
        toObject(e = !1) {
          return M.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(M.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(M.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new M();
          return M.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(M.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(M.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_BeginGameRecordingSegmentsUpload_Request";
        }
      }
      class C extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            C.prototype.segments_needed || i.aR(C.M()),
            h.initialize(this, e, 0, -1, [1], null);
        }
        static M() {
          return (
            C.sm_m ||
              (C.sm_m = {
                proto: C,
                fields: {
                  segments_needed: { n: 1, c: d, r: !0, q: !0 },
                  call_again: { n: 2, br: i.FE.readBool, bw: i.Xc.writeBool },
                },
              }),
            C.sm_m
          );
        }
        static MBF() {
          return C.sm_mbf || (C.sm_mbf = i.Bh(C.M())), C.sm_mbf;
        }
        toObject(e = !1) {
          return C.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(C.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(C.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new C();
          return C.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(C.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return C.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(C.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return C.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_BeginGameRecordingSegmentsUpload_Response";
        }
      }
      class y extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            y.prototype.recording_id || i.aR(y.M()),
            h.initialize(this, e, 0, -1, void 0, null);
        }
        static M() {
          return (
            y.sm_m ||
              (y.sm_m = {
                proto: y,
                fields: {
                  recording_id: {
                    n: 1,
                    br: i.FE.readUint64String,
                    bw: i.Xc.writeUint64String,
                  },
                  component_name: {
                    n: 2,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  representation_name: {
                    n: 3,
                    br: i.FE.readString,
                    bw: i.Xc.writeString,
                  },
                  first_segment_number: {
                    n: 4,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  num_segments: {
                    n: 5,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                  upload_result: {
                    n: 6,
                    br: i.FE.readUint32,
                    bw: i.Xc.writeUint32,
                  },
                },
              }),
            y.sm_m
          );
        }
        static MBF() {
          return y.sm_mbf || (y.sm_mbf = i.Bh(y.M())), y.sm_mbf;
        }
        toObject(e = !1) {
          return y.toObject(e, this);
        }
        static toObject(e, t) {
          return i.TA(y.M(), e, t);
        }
        static fromObject(e) {
          return i.aD(y.M(), e);
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new y();
          return y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return i.F(y.MBF(), e, t);
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          i.l2(y.M(), e, t);
        }
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_CommitGameRecordingSegmentsUpload_Request";
        }
      }
      class T extends h {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), h.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return T.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new T();
        }
        static deserializeBinary(e) {
          let t = new n.BinaryReader(e),
            r = new T();
          return T.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new n.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new n.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CVideo_CommitGameRecordingSegmentsUpload_Response";
        }
      }
      var k, G;
      !(function (e) {
        (e.CreateShareClip = function (e, t) {
          return e.SendMsg(
            "GameRecordingClip.CreateShareClip#1",
            (0, a.MD)(g, t),
            S,
            { ePrivilege: 1 },
          );
        }),
          (e.DeleteSharedClip = function (e, t) {
            return e.SendMsg(
              "GameRecordingClip.DeleteSharedClip#1",
              (0, a.MD)(b, t),
              v,
              { ePrivilege: 1 },
            );
          }),
          (e.GetSingleSharedClip = function (e, t) {
            return e.SendMsg(
              "GameRecordingClip.GetSingleSharedClip#1",
              (0, a.MD)(P, t),
              p,
              { bConstMethod: !0, ePrivilege: 2, eWebAPIKeyRequirement: 1 },
            );
          });
      })(k || (k = {})),
        (function (e) {
          (e.BeginGameRecordingSegmentsUpload = function (e, t) {
            return e.SendMsg(
              "VideoClip.BeginGameRecordingSegmentsUpload#1",
              (0, a.MD)(M, t),
              C,
              { ePrivilege: 1 },
            );
          }),
            (e.CommitGameRecordingSegmentsUpload = function (e, t) {
              return e.SendMsg(
                "VideoClip.CommitGameRecordingSegmentsUpload#1",
                (0, a.MD)(y, t),
                T,
                { ePrivilege: 1 },
              );
            });
        })(G || (G = {}));
    },
  },
]);
