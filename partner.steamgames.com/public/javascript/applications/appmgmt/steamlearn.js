/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkappmgmt_storeadmin =
  self.webpackChunkappmgmt_storeadmin || []).push([
  [5676],
  {
    31546: (e) => {
      e.exports = {
        TextButton: "datasourceinspect_TextButton_1MgDQ",
        SteamLearnButton: "datasourceinspect_SteamLearnButton_wIB-g",
        Disabled: "datasourceinspect_Disabled_1Fwfm",
        Hidden: "datasourceinspect_Hidden_aPk0K",
        Large: "datasourceinspect_Large_2ookS",
        Medium: "datasourceinspect_Medium_1FMLC",
        Blue: "datasourceinspect_Blue_2v2xf",
        Red: "datasourceinspect_Red_3IcTx",
        DataSourceInspectPage: "datasourceinspect_DataSourceInspectPage_1U6jT",
        DataSourceHeader: "datasourceinspect_DataSourceHeader_1uU8_",
        Name: "datasourceinspect_Name_3X7pQ",
        Description: "datasourceinspect_Description_3wZUk",
        Version: "datasourceinspect_Version_3W6ir",
        CacheDuration: "datasourceinspect_CacheDuration_2iS3d",
        DataSourceDetailsContainer:
          "datasourceinspect_DataSourceDetailsContainer_6lfFD",
        DataSourceElement: "datasourceinspect_DataSourceElement_1rZZr",
        ElementInfo: "datasourceinspect_ElementInfo_3JDiH",
        IndentBarContainer: "datasourceinspect_IndentBarContainer_8EEOX",
        ShortTop: "datasourceinspect_ShortTop_kw0m1",
        IndentBar: "datasourceinspect_IndentBar_2XboH",
        ShortBottom: "datasourceinspect_ShortBottom_HGfMO",
        Details: "datasourceinspect_Details_9dnid",
        ElementName: "datasourceinspect_ElementName_2VE9w",
        Type: "datasourceinspect_Type_2QIYv",
        SubObjectContainer: "datasourceinspect_SubObjectContainer_3O7w8",
        DataSourceType: "datasourceinspect_DataSourceType_8LaFL",
        Float: "datasourceinspect_Float_Ji0CJ",
        Bool: "datasourceinspect_Bool_2GRZK",
        Int: "datasourceinspect_Int_tzOqi",
        String: "datasourceinspect_String_EHF8P",
        Object: "datasourceinspect_Object_179h8",
      };
    },
    80810: (e) => {
      e.exports = {
        TextButton: "datasourcelist_TextButton_2WCob",
        SteamLearnButton: "datasourcelist_SteamLearnButton_35AI5",
        Disabled: "datasourcelist_Disabled_1J5MI",
        Hidden: "datasourcelist_Hidden_jS1JF",
        Large: "datasourcelist_Large_1KnyI",
        Medium: "datasourcelist_Medium_3qCtH",
        Blue: "datasourcelist_Blue_XZysr",
        Red: "datasourcelist_Red_pPWf_",
        DataSourceListPage: "datasourcelist_DataSourceListPage_1OG__",
        RegistrationKey: "datasourcelist_RegistrationKey_1HoYQ",
        DataSourceList: "datasourcelist_DataSourceList_21I3O",
        DataSourceListElement: "datasourcelist_DataSourceListElement_BJp6b",
        Name: "datasourcelist_Name_tRqdS",
        Description: "datasourcelist_Description_1WRfs",
        CacheDuration: "datasourcelist_CacheDuration_2SsrF",
        Version: "datasourcelist_Version_3II5-",
      };
    },
    427: (e) => {
      e.exports = {
        FlowNode: "nodes_FlowNode_3Eq1x",
        Title: "nodes_Title_meAbe",
        TitleText: "nodes_TitleText_1WxJq",
        NodeID: "nodes_NodeID_2vVi7",
        EditGear: "nodes_EditGear_3vw0w",
        Delete: "nodes_Delete_3yetd",
        TitleUnderBar: "nodes_TitleUnderBar_3Rx6P",
        Body: "nodes_Body_Nhk_t",
        SideSection: "nodes_SideSection_2PJWo",
        Left: "nodes_Left_KS5VR",
        Right: "nodes_Right_341wU",
        CenterSection: "nodes_CenterSection_qcMKa",
        Comment: "nodes_Comment_3xIJP",
        LabelValue: "nodes_LabelValue_3O43C",
        Label: "nodes_Label_25GLz",
        Value: "nodes_Value_3rXiS",
        TrainNode: "nodes_TrainNode_2Z5Sy",
        SubHeader: "nodes_SubHeader_KhOcv",
        EditOptions: "nodes_EditOptions_2xcGD",
        Option: "nodes_Option_gjJO0",
        OptionTitle: "nodes_OptionTitle_29pJ8",
        OptionDesc: "nodes_OptionDesc_1AUkO",
        OptionDescSub: "nodes_OptionDescSub_1gb6_",
        CheckboxWithLabel: "nodes_CheckboxWithLabel_1nRNo",
        OptionInput: "nodes_OptionInput_12TFx",
        VeryWide: "nodes_VeryWide_3HA1H",
        Invalid: "nodes_Invalid_3qpmP",
        InputSelect: "nodes_InputSelect_3WRZK",
        Shape: "nodes_Shape_2JtFk",
        TrainNodeEditDialog: "nodes_TrainNodeEditDialog_23Ih6",
        ConnectorID: "nodes_ConnectorID_1xOlw",
      };
    },
    2089: (e) => {
      e.exports = {
        TextButton: "projectcreate_TextButton_2wwVA",
        SteamLearnButton: "projectcreate_SteamLearnButton_2JNpk",
        Disabled: "projectcreate_Disabled_lGOCY",
        Hidden: "projectcreate_Hidden_J7kzJ",
        Large: "projectcreate_Large_1Wi3m",
        Medium: "projectcreate_Medium_2Fqb6",
        Blue: "projectcreate_Blue_3Hz6C",
        Red: "projectcreate_Red_cP4LF",
        ProjectCreatePage: "projectcreate_ProjectCreatePage_3GUPW",
        EditSection: "projectcreate_EditSection_25OCa",
        EditSectionTitle: "projectcreate_EditSectionTitle_3fdSg",
        InputTitle: "projectcreate_InputTitle_1rZnO",
        InputWide: "projectcreate_InputWide_3WyPM",
        InputAreaWide: "projectcreate_InputAreaWide_3pP5A",
        SteamLearnSelect: "projectcreate_SteamLearnSelect_376_r",
        CreateProjectResultDialog:
          "projectcreate_CreateProjectResultDialog_1P9YZ",
        CreateProjectResultDialogContents:
          "projectcreate_CreateProjectResultDialogContents_9vDId",
      };
    },
    57112: (e) => {
      e.exports = {
        TextButton: "projectdatasettings_TextButton_3p1VO",
        SteamLearnButton: "projectdatasettings_SteamLearnButton_17FIU",
        Disabled: "projectdatasettings_Disabled_3l8Hc",
        Hidden: "projectdatasettings_Hidden_3OO4t",
        Large: "projectdatasettings_Large_j-VIP",
        Medium: "projectdatasettings_Medium_3TgJQ",
        Blue: "projectdatasettings_Blue_2J_3S",
        Red: "projectdatasettings_Red_2S7YS",
        ProjectDataSettingsPage:
          "projectdatasettings_ProjectDataSettingsPage_3bCMu",
        ProjectDataSettingsBody:
          "projectdatasettings_ProjectDataSettingsBody_3PJ1s",
        Separator: "projectdatasettings_Separator_3q6kg",
        OptionHeader: "projectdatasettings_OptionHeader_32ipv",
        OptionDesc: "projectdatasettings_OptionDesc_Ye-6h",
        OptionBlock: "projectdatasettings_OptionBlock_E8-ta",
        OptionDetails: "projectdatasettings_OptionDetails_2xT8R",
        ValueInput: "projectdatasettings_ValueInput_MziGJ",
        Wide: "projectdatasettings_Wide_UXj_O",
        Invalid: "projectdatasettings_Invalid_10M0u",
      };
    },
    95917: (e) => {
      e.exports = {
        TextButton: "projectdatasources_TextButton_2yO-1",
        SteamLearnButton: "projectdatasources_SteamLearnButton_bG5n6",
        Disabled: "projectdatasources_Disabled_2vNCC",
        Hidden: "projectdatasources_Hidden_5WD4b",
        Large: "projectdatasources_Large_1bUsM",
        Medium: "projectdatasources_Medium_gfYM5",
        Blue: "projectdatasources_Blue_36que",
        Red: "projectdatasources_Red_3Vpxj",
        ProjectDataSourcesPage:
          "projectdatasources_ProjectDataSourcesPage_1IXec",
        ProjectConfigBody: "projectdatasources_ProjectConfigBody_QtJTz",
        Separator: "projectdatasources_Separator_29kZX",
        OptionHeader: "projectdatasources_OptionHeader_1PRMe",
        OptionDesc: "projectdatasources_OptionDesc_3zBVN",
        OptionBlock: "projectdatasources_OptionBlock_3pnEa",
        OptionDetails: "projectdatasources_OptionDetails_313Ne",
        AddDataSourceDialog: "projectdatasources_AddDataSourceDialog_1mNGX",
        AddDataSourceDialogContents:
          "projectdatasources_AddDataSourceDialogContents_3RAxT",
        Header: "projectdatasources_Header_2pxHa",
        DataSourceListContainer:
          "projectdatasources_DataSourceListContainer_3LgNX",
        DataSourceOption: "projectdatasources_DataSourceOption_25NX7",
        Selected: "projectdatasources_Selected_38mwl",
        Name: "projectdatasources_Name_3Hj5D",
        Description: "projectdatasources_Description_1Obgc",
        Version: "projectdatasources_Version_3y0tt",
        ProjectConfigDataSourceElement:
          "projectdatasources_ProjectConfigDataSourceElement_yhrLn",
        IsOldDataSourceVersion:
          "projectdatasources_IsOldDataSourceVersion_1rvbT",
        Remove: "projectdatasources_Remove_3sDBJ",
        ProjectConfigDataSourceDataElementRoutingList:
          "projectdatasources_ProjectConfigDataSourceDataElementRoutingList_26BWQ",
        ProjectConfigDataSourceElementRoutingWrapper:
          "projectdatasources_ProjectConfigDataSourceElementRoutingWrapper_1epfq",
        DataSourceName: "projectdatasources_DataSourceName_1fr-w",
        ProjectConfigDataSourceElementRouting:
          "projectdatasources_ProjectConfigDataSourceElementRouting_3RUIE",
        LeftSection: "projectdatasources_LeftSection_1B_4D",
        Array: "projectdatasources_Array_1maQe",
        TypeAndExpandCollapse: "projectdatasources_TypeAndExpandCollapse_39Go_",
        Type: "projectdatasources_Type_1yckL",
        Explode: "projectdatasources_Explode_3YW8Y",
        Collapse: "projectdatasources_Collapse_1_0rP",
        InputSection: "projectdatasources_InputSection_2D9cD",
        InputSelect: "projectdatasources_InputSelect_1ptzA",
        NormalizeSection: "projectdatasources_NormalizeSection_1dPgp",
        Option: "projectdatasources_Option_1JgGh",
        ValueInput: "projectdatasources_ValueInput_PLcgR",
        Wide: "projectdatasources_Wide_Max2Z",
        Invalid: "projectdatasources_Invalid_22UX9",
        RightSection: "projectdatasources_RightSection_3GaIb",
      };
    },
    38784: (e) => {
      e.exports = {
        TextButton: "projectevents_TextButton_1fNtA",
        SteamLearnButton: "projectevents_SteamLearnButton_1HUKJ",
        Disabled: "projectevents_Disabled_j67ht",
        Hidden: "projectevents_Hidden_1_hba",
        Large: "projectevents_Large_3zXGw",
        Medium: "projectevents_Medium_294HW",
        Blue: "projectevents_Blue_3zLfs",
        Red: "projectevents_Red_2NUlJ",
        ProjectEventsPage: "projectevents_ProjectEventsPage_bh2lf",
        ProjectEventCapsule: "projectevents_ProjectEventCapsule_3-at1",
        EventCapsuleBody: "projectevents_EventCapsuleBody_WSNDs",
        ProjectName: "projectevents_ProjectName_XKtZB",
        ProjectID: "projectevents_ProjectID_2walF",
        Type: "projectevents_Type_PgSnu",
        Timestamp: "projectevents_Timestamp_2K0VY",
        LabelValue: "projectevents_LabelValue_QVmLj",
        Label: "projectevents_Label_20Vsd",
        Value: "projectevents_Value_1vUuH",
      };
    },
    68763: (e) => {
      e.exports = {
        TextButton: "projectheader_TextButton_j6Csd",
        SteamLearnButton: "projectheader_SteamLearnButton_aJgN_",
        Disabled: "projectheader_Disabled_WHGM5",
        Hidden: "projectheader_Hidden_39_uO",
        Large: "projectheader_Large_2ghHS",
        Medium: "projectheader_Medium_3hLtv",
        Blue: "projectheader_Blue_1EmoV",
        Red: "projectheader_Red_c_07G",
        ProjectHeader: "projectheader_ProjectHeader_3QTZO",
        LeftSection: "projectheader_LeftSection_TEhd0",
        ProjectName: "projectheader_ProjectName_jEE9n",
        EditIcon: "projectheader_EditIcon_1AvVo",
        Description: "projectheader_Description_1OEpk",
        RightSection: "projectheader_RightSection_34BsD",
        PublishInfo: "projectheader_PublishInfo_3KIBw",
      };
    },
    24888: (e) => {
      e.exports = {
        TextButton: "projectinferencetester_TextButton_1TP61",
        SteamLearnButton: "projectinferencetester_SteamLearnButton_2l6JO",
        Disabled: "projectinferencetester_Disabled_119e9",
        Hidden: "projectinferencetester_Hidden_3CNsi",
        Large: "projectinferencetester_Large_3kexf",
        Medium: "projectinferencetester_Medium_36W4d",
        Blue: "projectinferencetester_Blue_19Q5Q",
        Red: "projectinferencetester_Red_1ntkH",
        ProjectInferenceTesterPage:
          "projectinferencetester_ProjectInferenceTesterPage_GW4jm",
        ProjectInferenceTesterBody:
          "projectinferencetester_ProjectInferenceTesterBody_7Qcv3",
        DataSourceElement: "projectinferencetester_DataSourceElement_2ehKi",
        Name: "projectinferencetester_Name_27fjF",
        Separator: "projectinferencetester_Separator_2czS-",
        OptionHeader: "projectinferencetester_OptionHeader_3UF5n",
        OptionDesc: "projectinferencetester_OptionDesc_eCPzp",
        OptionBlock: "projectinferencetester_OptionBlock_BrLKA",
        OptionDetails: "projectinferencetester_OptionDetails_3bVi7",
        ValueInput: "projectinferencetester_ValueInput_1u3oN",
        Wide: "projectinferencetester_Wide_3Vj-G",
        Invalid: "projectinferencetester_Invalid_1d4Zd",
      };
    },
    28425: (e) => {
      e.exports = {
        TextButton: "projectlist_TextButton_1cqhS",
        SteamLearnButton: "projectlist_SteamLearnButton_3pEd7",
        Disabled: "projectlist_Disabled_107Sd",
        Hidden: "projectlist_Hidden_zvAb3",
        Large: "projectlist_Large_1KskQ",
        Medium: "projectlist_Medium_3-zYh",
        Blue: "projectlist_Blue_2ezkO",
        Red: "projectlist_Red_swy6m",
        ProjectListPage: "projectlist_ProjectListPage_XGVzX",
        ProjectListElement: "projectlist_ProjectListElement_d64QC",
        Name: "projectlist_Name_7UoFG",
        Description: "projectlist_Description_2jeKX",
        CreatedDate: "projectlist_CreatedDate_1Ujp5",
        Version: "projectlist_Version_1cT2n",
      };
    },
    40503: (e) => {
      e.exports = {
        TextButton: "projectmanualtrain_TextButton_3t2Zo",
        SteamLearnButton: "projectmanualtrain_SteamLearnButton_3To1N",
        Disabled: "projectmanualtrain_Disabled_Vt0Iy",
        Hidden: "projectmanualtrain_Hidden_1-W3z",
        Large: "projectmanualtrain_Large_3eDOk",
        Medium: "projectmanualtrain_Medium_3Gb_A",
        Blue: "projectmanualtrain_Blue_3SXgJ",
        Red: "projectmanualtrain_Red_1LAYW",
        ProjectManualTrainPage:
          "projectmanualtrain_ProjectManualTrainPage_3izYO",
        StatusMessage: "projectmanualtrain_StatusMessage_2mAjx",
        ProjectTrain: "projectmanualtrain_ProjectTrain_9QaSg",
        Heading: "projectmanualtrain_Heading_2I7kj",
        Desc: "projectmanualtrain_Desc_3-BSA",
        FetchTrainOptionContainer:
          "projectmanualtrain_FetchTrainOptionContainer_wOMGg",
        SaveWarning: "projectmanualtrain_SaveWarning_dA6cM",
      };
    },
    48259: (e) => {
      e.exports = {
        TextButton: "projectmodel_TextButton_x7w6X",
        SteamLearnButton: "projectmodel_SteamLearnButton_2XyTR",
        Disabled: "projectmodel_Disabled_2hCF1",
        Hidden: "projectmodel_Hidden_17HVA",
        Large: "projectmodel_Large_2p4Ep",
        Medium: "projectmodel_Medium_oyUgX",
        Blue: "projectmodel_Blue_3lg-R",
        Red: "projectmodel_Red_e3J0-",
        ProjectModelPage: "projectmodel_ProjectModelPage_2m439",
        ProjectModelReactFlow: "projectmodel_ProjectModelReactFlow_16zi2",
        ReactFlowWrapper: "projectmodel_ReactFlowWrapper_3Qiql",
        DragSourcePanel: "projectmodel_DragSourcePanel_-6BVk",
        DragSource: "projectmodel_DragSource_xN6wI",
        DebugToggle: "projectmodel_DebugToggle_zsiFr",
        Enabled: "projectmodel_Enabled_tWQvN",
        EditOptions: "projectmodel_EditOptions_3TQl6",
        Title: "projectmodel_Title_21Zb4",
        Body: "projectmodel_Body_2qDZq",
        Shape: "projectmodel_Shape_2S-T6",
        Option: "projectmodel_Option_pZE2H",
        OptionInput: "projectmodel_OptionInput_2iqXl",
        Invalid: "projectmodel_Invalid_3Q2pf",
        CheckboxWithLabel: "projectmodel_CheckboxWithLabel_JQcNd",
      };
    },
    77845: (e) => {
      e.exports = {
        TextButton: "projectscheduledtrain_TextButton_6gEa9",
        SteamLearnButton: "projectscheduledtrain_SteamLearnButton_32ivM",
        Disabled: "projectscheduledtrain_Disabled_BRTSe",
        Hidden: "projectscheduledtrain_Hidden_2XOUQ",
        Large: "projectscheduledtrain_Large_1k1kU",
        Medium: "projectscheduledtrain_Medium_2eS-3",
        Blue: "projectscheduledtrain_Blue_2yq0t",
        Red: "projectscheduledtrain_Red_xqg1g",
        ProjectScheduledTrainPage:
          "projectscheduledtrain_ProjectScheduledTrainPage_30fEb",
        StatusMessage: "projectscheduledtrain_StatusMessage_1qQt0",
        ProjectTrain: "projectscheduledtrain_ProjectTrain_1h7Ic",
        Heading: "projectscheduledtrain_Heading_2OBI3",
        Desc: "projectscheduledtrain_Desc_1A02c",
        OptionBlock: "projectscheduledtrain_OptionBlock_2giaA",
        OptionDetails: "projectscheduledtrain_OptionDetails_1WVpE",
        ValueInput: "projectscheduledtrain_ValueInput_b99J4",
        Wide: "projectscheduledtrain_Wide_3nqBj",
        Invalid: "projectscheduledtrain_Invalid_1lBiR",
      };
    },
    51495: (e) => {
      e.exports = {
        TextButton: "projectsnapshotfilter_TextButton_3dxVs",
        SteamLearnButton: "projectsnapshotfilter_SteamLearnButton_3nDD4",
        Disabled: "projectsnapshotfilter_Disabled_3iV8n",
        Hidden: "projectsnapshotfilter_Hidden_3Tw1p",
        Large: "projectsnapshotfilter_Large_2TCVd",
        Medium: "projectsnapshotfilter_Medium_1hkKy",
        Blue: "projectsnapshotfilter_Blue_KFlCp",
        Red: "projectsnapshotfilter_Red_2GfpX",
        ProjectSnapshotFilterPage:
          "projectsnapshotfilter_ProjectSnapshotFilterPage_3ePLX",
        ProjectConfigBody: "projectsnapshotfilter_ProjectConfigBody_2PIbe",
        Separator: "projectsnapshotfilter_Separator_1bgGe",
        OptionHeader: "projectsnapshotfilter_OptionHeader_tftnl",
        OptionDesc: "projectsnapshotfilter_OptionDesc_3fiqg",
        OptionBlock: "projectsnapshotfilter_OptionBlock_3e9Vm",
        OptionDetails: "projectsnapshotfilter_OptionDetails_2IjtN",
        ValueInput: "projectsnapshotfilter_ValueInput_1t2jN",
        Wide: "projectsnapshotfilter_Wide_1Dxyp",
        Invalid: "projectsnapshotfilter_Invalid_2kBDQ",
        RemoveComparison: "projectsnapshotfilter_RemoveComparison_24D2M",
      };
    },
    69747: (e) => {
      e.exports = {
        TextButton: "projecttrainsettings_TextButton_2_0va",
        SteamLearnButton: "projecttrainsettings_SteamLearnButton_P4V_S",
        Disabled: "projecttrainsettings_Disabled_1JSCt",
        Hidden: "projecttrainsettings_Hidden_JMdN2",
        Large: "projecttrainsettings_Large_2lDvg",
        Medium: "projecttrainsettings_Medium_bxNJ-",
        Blue: "projecttrainsettings_Blue_17CWD",
        Red: "projecttrainsettings_Red_Gt8Uc",
        ProjectTrainSettingsPage:
          "projecttrainsettings_ProjectTrainSettingsPage_3K9vg",
        ProjectTrainSettingsBody:
          "projecttrainsettings_ProjectTrainSettingsBody_t-dKb",
        Separator: "projecttrainsettings_Separator_14Ln1",
        OptionHeader: "projecttrainsettings_OptionHeader_3TfFK",
        OptionDesc: "projecttrainsettings_OptionDesc_3r6c2",
        OptionBlock: "projecttrainsettings_OptionBlock_2YkQA",
        OptionDetails: "projecttrainsettings_OptionDetails_1noWK",
        ValueInput: "projecttrainsettings_ValueInput_121zx",
        Wide: "projecttrainsettings_Wide_3a-QX",
        Invalid: "projecttrainsettings_Invalid_xnCGX",
      };
    },
    81093: (e) => {
      e.exports = {
        TextButton: "projecttrainstatus_TextButton_3JVbF",
        SteamLearnButton: "projecttrainstatus_SteamLearnButton_1eKJ4",
        Disabled: "projecttrainstatus_Disabled_3520o",
        Hidden: "projecttrainstatus_Hidden_1AuVm",
        Large: "projecttrainstatus_Large_c8gky",
        Medium: "projecttrainstatus_Medium_dYGW3",
        Blue: "projecttrainstatus_Blue_2sM8Q",
        Red: "projecttrainstatus_Red_2jKXY",
        ProjectTrainStatusPage:
          "projecttrainstatus_ProjectTrainStatusPage_32ydn",
        ProjectTrainStatusBody:
          "projecttrainstatus_ProjectTrainStatusBody_2as9M",
        Separator: "projecttrainstatus_Separator_2BerN",
        StatusMessage: "projecttrainstatus_StatusMessage_2IP1F",
        FetchStatusPanel: "projecttrainstatus_FetchStatusPanel_1_188",
        TopSection: "projecttrainstatus_TopSection_2bD-7",
        TopLeft: "projecttrainstatus_TopLeft_2_woo",
        OverallStatus: "projecttrainstatus_OverallStatus_2f7nt",
        StatusString: "projecttrainstatus_StatusString_2jqJc",
        Unknown: "projecttrainstatus_Unknown_3ZX3h",
        Unstarted: "projecttrainstatus_Unstarted_tgiSl",
        InProgress: "projecttrainstatus_InProgress_j3V3-",
        Complete: "projecttrainstatus_Complete_2Qp75",
        Error: "projecttrainstatus_Error_1vQlP",
        TopRight: "projecttrainstatus_TopRight_kr6zM",
        StatusProgress: "projecttrainstatus_StatusProgress_330b2",
        RowProgress: "projecttrainstatus_RowProgress_1ZH7S",
        RowCurrent: "projecttrainstatus_RowCurrent_3nCub",
        RowSlash: "projecttrainstatus_RowSlash_16F4J",
        RowTotal: "projecttrainstatus_RowTotal_4wyui",
        ProgressBar: "projecttrainstatus_ProgressBar_3t51f",
        ProgressBarInner: "projecttrainstatus_ProgressBarInner_3ASjU",
        ProgressPct: "projecttrainstatus_ProgressPct_1SBOv",
        ShowWorkers: "projecttrainstatus_ShowWorkers_3yfLa",
        WorkersContainer: "projecttrainstatus_WorkersContainer_tTO2P",
        Worker: "projecttrainstatus_Worker_f9kQ7",
        WorkerNumber: "projecttrainstatus_WorkerNumber_1wKjW",
        ShowWorkersTextButton: "projecttrainstatus_ShowWorkersTextButton_3cmDG",
        TrainStatusPanel: "projecttrainstatus_TrainStatusPanel_BbjEt",
        EpochSelectorSection: "projecttrainstatus_EpochSelectorSection_duyKv",
        EpochOption: "projecttrainstatus_EpochOption_2FOCh",
        Selected: "projecttrainstatus_Selected_3-01t",
        BatchStatus: "projecttrainstatus_BatchStatus_3ReQo",
        BatchStatusRow: "projecttrainstatus_BatchStatusRow_3depk",
        PhaseLabel: "projecttrainstatus_PhaseLabel_Dh04R",
        PhaseValues: "projecttrainstatus_PhaseValues_3k0j2",
        Total: "projecttrainstatus_Total_37a21",
        CurrentEpoch: "projecttrainstatus_CurrentEpoch_1YeRP",
        GraphPair: "projecttrainstatus_GraphPair_3_XEa",
        TrainGraph: "projecttrainstatus_TrainGraph_1KZ1T",
        GraphTitle: "projecttrainstatus_GraphTitle_3cZuU",
        LineValues: "projecttrainstatus_LineValues_1Lo07",
        Value: "projecttrainstatus_Value_28cVs",
      };
    },
    94172: (e) => {
      e.exports = {
        TextButton: "steamlearn_TextButton_VES62",
        SteamLearnButton: "steamlearn_SteamLearnButton_OFzkO",
        Disabled: "steamlearn_Disabled_1iwPS",
        Hidden: "steamlearn_Hidden_Gxife",
        Large: "steamlearn_Large_3opGK",
        Medium: "steamlearn_Medium_1esFK",
        Blue: "steamlearn_Blue_1KZpc",
        Red: "steamlearn_Red_Y0JrW",
      };
    },
    48113: (e) => {
      e.exports = {
        TextButton: "steamlearn_routing_TextButton_asdUZ",
        SteamLearnButton: "steamlearn_routing_SteamLearnButton_L3Xej",
        Disabled: "steamlearn_routing_Disabled_3De8F",
        Hidden: "steamlearn_routing_Hidden_3VPpD",
        Large: "steamlearn_routing_Large_vRT03",
        Medium: "steamlearn_routing_Medium_1mg8L",
        Blue: "steamlearn_routing_Blue_naj_v",
        Red: "steamlearn_routing_Red_2fLZd",
        SteamLearnApp: "steamlearn_routing_SteamLearnApp_1Q7MN",
        MainAppContainer: "steamlearn_routing_MainAppContainer_1oyJJ",
        LeftMenuBar: "steamlearn_routing_LeftMenuBar_1SMWl",
        LeftMenuBarSectionHeader:
          "steamlearn_routing_LeftMenuBarSectionHeader_3KH7g",
        LeftMenuBarItem: "steamlearn_routing_LeftMenuBarItem_1jUn8",
        Active: "steamlearn_routing_Active_vb7ei",
      };
    },
    51078: (e, t, a) => {
      "use strict";
      a.r(t),
        a.d(t, {
          SteamLearnRoutes: () => _a,
          SwitchToVersion: () => da,
          default: () => Ea,
        });
      var n = a(96927),
        o = a(89526),
        r = a(59934),
        s = a(565),
        c = a(48113),
        i = a(19304),
        l = a(14826),
        _ = a(33940),
        d = a(2486),
        m = a(32765),
        u = a(19094),
        E = a(23801);
      class p {
        constructor() {
          this.m_SteamInterface = null;
        }
        static Get() {
          return (
            p.s_SteamLearnStore ||
              ((p.s_SteamLearnStore = new p()), p.s_SteamLearnStore.Init()),
            p.s_SteamLearnStore
          );
        }
        Init() {
          const e = (0, m.kQ)("webapi_token", "application_config");
          (0, E.X)(Boolean(e), "require webapi_token"),
            "dev" == m.De.WEB_UNIVERSE &&
              console.log(
                "DEV_DEBUG Initializing CSteamLearnStore with access token ",
                e,
              ),
            (this.m_SteamInterface = new u.J(m.De.WEBAPI_BASE_URL, e));
        }
        GetServiceTransport() {
          return this.m_SteamInterface.GetServiceTransport();
        }
      }
      var S = a(5615),
        N = a(42735),
        g = a(67328),
        v = a(32930),
        T = a(86900);
      function L(e) {
        return `handle_${e}`;
      }
      function f(e) {
        return `node_${e}`;
      }
      function h(e) {
        return parseInt(e.replace("handle_", ""));
      }
      function D(e) {
        return parseInt(e.replace("node_", ""));
      }
      function C(e, t) {
        return `edge_${e}_${t}`;
      }
      const A = "SteamLearnDataSource",
        I = "SteamLearnProjectList",
        P = "SteamLearnProject",
        O = "SteamLearnFetchStatusVersions",
        x = "SteamLearnTrainStatusVersions",
        j = "SteamLearnFetchStatus",
        b = "SteamLearnTrainStatus",
        y = "SteamLearnDataSourceHMAC",
        R = "SteamLearnCacheDataHMAC",
        k = "SteamLearnSnapshotHMAC";
      function M(e) {
        return `SteamLearnWorkingProject_${e}`;
      }
      function X() {
        return (0, S.useQuery)(
          ["SteamLearnDataSourceList"],
          () =>
            (function () {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let e = g.gA.Init(v.Vyd);
                const t = yield v.NG.ListDataSources(
                  p.Get().GetServiceTransport(),
                  e,
                );
                if (t.BIsValid() && t.GetEResult() == N.s.k_EResultOK)
                  return (
                    t
                      .Body()
                      .data_sources()
                      .forEach((e) => {
                        T.U.setQueryData([A, e.id()], e);
                      }),
                    T.U.setQueryData(
                      [y],
                      t.Body().register_data_source_hmac_key(),
                    ),
                    t
                      .Body()
                      .cache_data_hmac_keys()
                      .forEach((e, a) => {
                        T.U.setQueryData(
                          [R, t.Body().data_sources()[a].id()],
                          e,
                        );
                      }),
                    t.Body().data_sources()
                  );
                throw "Failed FetchDataSourceList";
              });
            })(),
          { staleTime: 1 / 0 },
        );
      }
      function B(e) {
        return (0, S.useQuery)(
          [A, e],
          () =>
            (function (e) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let t = g.gA.Init(v.OzA);
                t.Body().set_data_source_id(e);
                const a = yield v.NG.GetDataSource(
                  p.Get().GetServiceTransport(),
                  t,
                );
                if (a.BIsValid() && a.GetEResult() == N.s.k_EResultOK)
                  return a.Body().data_source();
                throw `Failed FetchDataSource ${e}`;
              });
            })(e),
          { staleTime: 1 / 0 },
        );
      }
      function w(e, t) {
        const a = B(e);
        if (!a.isSuccess) return;
        return W(a.data.structure(), "", t);
      }
      function W(e, t, a) {
        for (const n of e.elements())
          for (let e = 0; e < n.count(); e++) {
            const o = t + `${t.length > 0 ? "/" : ""}${n.name()}#${e}`;
            if (o == a) return n;
            if (n.data_type() == v.rSG.STEAMLEARN_DATATYPE_OBJECT) {
              const e = W(n.object(), o, a);
              if (e) return e;
            }
          }
      }
      function V(e) {
        return (0, _.mG)(this, void 0, void 0, function* () {
          const t = yield (function (e) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let t = g.gA.Init(v.DYT);
                t.Body().set_project_id(e);
                const a = yield v.NG.GetProject(
                  p.Get().GetServiceTransport(),
                  t,
                );
                if (a.BIsValid() && a.GetEResult() == N.s.k_EResultOK)
                  return a.Body().project();
                throw `Failed FetchProject ${e}`;
              });
            })(e),
            a = M(e);
          null === localStorage.getItem(a) &&
            localStorage.setItem(a, t.serializeBase64String());
          const n = v.mgi.deserializeBinary(
            Uint8Array.from(d.lW.from(localStorage.getItem(a), "base64")),
          );
          for (const e of t.published_configs())
            for (const t of n.published_configs())
              e.published_version() == t.published_version() &&
                (t.set_fetch_infos(e.fetch_infos()),
                t.set_train_infos(e.train_infos()));
          return [t, n];
        });
      }
      function H() {
        return (0, S.useQuery)(
          [I],
          () =>
            (function () {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let e = g.gA.Init(v.W3l);
                const t = yield v.NG.ListProjects(
                  p.Get().GetServiceTransport(),
                  e,
                );
                if (t.BIsValid() && t.GetEResult() == N.s.k_EResultOK)
                  return (
                    t
                      .Body()
                      .snapshot_hmac_keys()
                      .forEach((e, a) => {
                        T.U.setQueryData(
                          [k, t.Body().projects()[a].project_id()],
                          e,
                        );
                      }),
                    t.Body().projects()
                  );
                throw "Failed FetchProjectList";
              });
            })(),
          { staleTime: 1 / 0 },
        );
      }
      function F(e) {
        return (0, S.useQuery)(
          [P, e],
          () =>
            (0, _.mG)(this, void 0, void 0, function* () {
              return V(e);
            }),
          { staleTime: 1 / 0 },
        );
      }
      function G(e, t) {
        return (0, S.useQuery)(
          [O, e, t],
          () =>
            (function (e, t) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let a = g.gA.Init(v.wN3);
                a.Body().set_project_id(e), a.Body().set_published_version(t);
                const n = yield v.NG.GetFetchStatusVersions(
                  p.Get().GetServiceTransport(),
                  a,
                );
                if (n.BIsValid() && n.GetEResult() == N.s.k_EResultOK)
                  return n.Body();
                throw `Failed FetchFetchVersions: Project ${e}`;
              });
            })(e, t),
          { staleTime: 1 / 0 },
        );
      }
      function U(e, t) {
        return (0, S.useQuery)(
          [x, e, t],
          () =>
            (function (e, t) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let a = g.gA.Init(v.yuy);
                a.Body().set_project_id(e), a.Body().set_published_version(t);
                const n = yield v.NG.GetTrainStatusVersions(
                  p.Get().GetServiceTransport(),
                  a,
                );
                if (n.BIsValid() && n.GetEResult() == N.s.k_EResultOK)
                  return n.Body();
                throw `Failed FetchTrainVersions: Project ${e}`;
              });
            })(e, t),
          { staleTime: 1 / 0 },
        );
      }
      function Y(e, t) {
        return (0, S.useQuery)(
          [j, e, t],
          () =>
            (function (e, t) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let a = g.gA.Init(v.kKo);
                a.Body().set_project_id(e), a.Body().set_fetch_id(t);
                const n = yield v.NG.GetFetchStatus(
                  p.Get().GetServiceTransport(),
                  a,
                );
                if (n.BIsValid() && n.GetEResult() == N.s.k_EResultOK)
                  return n.Body();
                throw `Failed FetchFetchStatus: Project ${e}`;
              });
            })(e, t),
          { staleTime: 1 / 0 },
        );
      }
      function $(e, t) {
        return (0, S.useQuery)(
          [b, e, t],
          () =>
            (function (e, t) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let a = g.gA.Init(v.uKj);
                a.Body().set_project_id(e), a.Body().set_train_id(t);
                const n = yield v.NG.GetTrainStatus(
                  p.Get().GetServiceTransport(),
                  a,
                );
                if (n.BIsValid() && n.GetEResult() == N.s.k_EResultOK)
                  return n.Body();
                throw `Failed FetchTrainStatus: Project ${e}`;
              });
            })(e, t),
          { staleTime: 1 / 0 },
        );
      }
      function Z(e, t) {
        return (0, S.useQuery)(
          ["SteamLearnTrainLogEvents", e, t],
          () =>
            (function (e, t) {
              return (0, _.mG)(this, void 0, void 0, function* () {
                let a = g.gA.Init(v.cJ3);
                a.Body().set_look_behind_days(e),
                  a.Body().set_look_ahead_days(t);
                const n = yield v.NG.GetLogEvents(
                  p.Get().GetServiceTransport(),
                  a,
                );
                if (n.BIsValid() && n.GetEResult() == N.s.k_EResultOK)
                  return n.Body();
                throw `Failed FetchLogEvents: ${e} to ${t} `;
              });
            })(e, t),
          { staleTime: 600 },
        );
      }
      function K(e, t) {
        return (0, _.mG)(this, void 0, void 0, function* () {
          let a = g.gA.Init(v.S$J);
          a.Body().set_project(e), a.Body().set_published_version(t);
          const n = yield v.NG.EditProject(p.Get().GetServiceTransport(), a);
          return (
            n &&
              n.GetEResult() == N.s.k_EResultOK &&
              (localStorage.removeItem(M(e.project_id())),
              T.U.invalidateQueries([P, e.project_id()])),
            n.Body().result()
          );
        });
      }
      function z(e) {
        localStorage.removeItem(M(e)),
          T.U.invalidateQueries([P, e]),
          T.U.invalidateQueries([O, e]),
          T.U.invalidateQueries([x, e]);
      }
      function Q(e, t) {
        let a;
        for (const n of e.project_nodes())
          n.type() == t && (!a || n.node_id() > a.node_id()) && (a = n);
        return a ? [a.location_x() + 100, a.location_y()] : [0, 0];
      }
      function J(e) {
        const t = e
          .project_nodes()
          .map((e) => e.node_id())
          .sort((e, t) => e - t);
        for (let e = 0; e < t.length; e++) if (t[e] != e + 1) return e + 1;
        return t.length + 1;
      }
      function q(e, t) {
        let a = [];
        for (const t of e.project_nodes())
          a.push(...t.connectors().map((e) => e.connector_id()));
        let n = [];
        for (let e = 1; a.includes(e) || (n.push(e), n.length != t); e++);
        return n;
      }
      function ee(e) {
        return q(e, 1)[0];
      }
      function te(e, t, a, n, o, r) {
        let s = t.project_nodes().find((e) => e.node_id() == a),
          c = t.project_nodes().find((e) => e.node_id() == o);
        if (
          ((0, E.X)(s, `AddEdgeToConfig: Failed to find source node: ${a}`),
          (0, E.X)(c, `AddEdgeToConfig: Failed to find target node: ${o}`),
          !s || !c)
        )
          return;
        let i = s.connectors().find((e) => e.connector_id() == n),
          l = c.connectors().find((e) => e.connector_id() == r);
        (0, E.X)(
          i,
          `AddEdgeToConfig: Failed to find source connector: ${a}, ${n}`,
        ),
          (0, E.X)(
            l,
            `AddEdgeToConfig: Failed to find target connector: ${o}, ${r}`,
          ),
          i.add_linked_connector_ids(r),
          se(e);
      }
      function ae(e, t) {
        for (const a of e.project_nodes())
          for (const e of a.connectors())
            for (const n of e.linked_connector_ids())
              if (n == t)
                return {
                  msgIncomingNode: a,
                  nIncomingConnectorID: e.connector_id(),
                };
        return { msgIncomingNode: void 0, nIncomingConnectorID: 0 };
      }
      function ne(e, t, a) {
        var n, o;
        let r = [];
        switch (t.type()) {
          case v.scw.STEAMLEARN_NODE_TYPE_INPUT: {
            let a = 0;
            for (const n of e.data_source_element_usages())
              n.input() == t.input().input_num() && a++;
            r.push(a);
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_DENSE:
            r.push(t.dense().width());
            break;
          case v.scw.STEAMLEARN_NODE_TYPE_DENSE_STACK:
            r.push(t.dense_stack().width()[t.dense_stack().width().length - 1]);
            break;
          case v.scw.STEAMLEARN_NODE_TYPE_DROPOUT: {
            const { msgIncomingNode: a, nIncomingConnectorID: n } = ae(
              e,
              t.connectors()[0].connector_id(),
            );
            if (a) {
              const t = ne(e, a, n);
              (0, E.X)(
                1 == t.length,
                `Input tensor to STEAMLEARN_NODE_TYPE_DROPOUT not one-dimensional! (node ${a}, connector ${n}`,
              ),
                r.push(t[0]);
            }
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_EMBEDDING: {
            const a =
              null ===
                (n = t.connectors().find((e) => e.is_input_connector())) ||
              void 0 === n
                ? void 0
                : n.connector_id();
            if (!a) {
              (0, E.X)(!1, `No input connector on node ${t.toObject()}`);
              break;
            }
            const { msgIncomingNode: o, nIncomingConnectorID: s } = ae(e, a);
            if (o)
              if (t.embedding().flatten()) {
                const a = ne(e, o, s);
                (0, E.X)(
                  1 == a.length,
                  `Input tensor to STEAMLEARN_NODE_TYPE_EMBEDDING not one-dimensional! (node ${o.toObject()}, connector ${s}`,
                ),
                  r.push(a[0] * t.embedding().embedding_width());
              } else {
                const a = ne(e, o, s);
                (0, E.X)(
                  1 == a.length,
                  `Input tensor to STEAMLEARN_NODE_TYPE_EMBEDDING not one-dimensional! (node ${o.toObject()}, connector ${s}`,
                ),
                  r.push(a[0]),
                  r.push(t.embedding().embedding_width());
              }
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_CONCATENATE: {
            let a = 0;
            for (const n of t.connectors())
              if (n.is_input_connector()) {
                const { msgIncomingNode: t, nIncomingConnectorID: o } = ae(
                  e,
                  n.connector_id(),
                );
                if (t) {
                  const n = ne(e, t, o);
                  (0, E.X)(
                    1 == n.length,
                    `Input tensor to STEAMLEARN_NODE_TYPE_CONCATENATE not one-dimensional! (node ${t.toObject()}, connector ${o}`,
                  ),
                    (a += n[0]);
                }
              }
            r.push(a);
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_COMBINE: {
            let a = 0;
            for (const n of t.connectors())
              if (n.is_input_connector()) {
                const { msgIncomingNode: t, nIncomingConnectorID: o } = ae(
                  e,
                  n.connector_id(),
                );
                if (t) {
                  const n = ne(e, t, o);
                  (0, E.X)(
                    1 == n.length,
                    `Input tensor to STEAMLEARN_NODE_TYPE_COMBINE not one-dimensional! (node ${t.toObject()}, connector ${o}`,
                  ),
                    (a += n[0]);
                }
              }
            r.push(a);
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_SHUFFLE: {
            const a =
              null ===
                (o = t.connectors().find((e) => e.is_input_connector())) ||
              void 0 === o
                ? void 0
                : o.connector_id();
            if (!a) {
              (0, E.X)(!1, `No input connector on node ${t.toObject()}`);
              break;
            }
            const { msgIncomingNode: n, nIncomingConnectorID: s } = ae(e, a);
            if (n) {
              const t = ne(e, n, s);
              (0, E.X)(
                1 == t.length,
                `Input tensor to STEAMLEARN_NODE_TYPE_SHUFFLE not one-dimensional! (node ${n}, connector ${s}`,
              ),
                r.push(t[0]);
            }
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE: {
            const n = t
                .connectors()
                .filter((e) => e.is_input_connector())
                .map((e) => e.connector_id()),
              o = t
                .connectors()
                .filter((e) => !e.is_input_connector())
                .map((e) => e.connector_id());
            (0, E.X)(
              n.length == o.length,
              `Synced shuffle node with different number of input and output connectors: ${t.toObject()}`,
            );
            const s = n[o.findIndex((e) => e == a)],
              { msgIncomingNode: c, nIncomingConnectorID: i } = ae(e, s);
            if (c) {
              const t = ne(e, c, i);
              (0, E.X)(
                1 == t.length,
                `Input tensor to STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE not one-dimensional! (node ${c}, connector ${i}`,
              ),
                r.push(t[0]);
            }
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_ONEHOT:
            if (t.onehot().compact_table().length > 0) {
              r.push(void 0);
              break;
            }
            r.push(t.onehot().width());
            break;
          case v.scw.STEAMLEARN_NODE_TYPE_EXPLODE:
            r.push(1);
            break;
          case v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_SWAP: {
            const a = t
              .connectors()
              .filter((e) => e.is_input_connector())
              .map((e) => e.connector_id());
            (0, E.X)(
              3 == a.length,
              "Conditional swap node with other than 3 input connectors:",
              t.toObject(),
            );
            const { msgIncomingNode: n, nIncomingConnectorID: o } = ae(e, a[1]);
            if (n) {
              const t = ne(e, n, o);
              r.push(...t);
            }
            break;
          }
          case v.scw.STEAMLEARN_NODE_TYPE_KMEANS:
            r.push(1);
            break;
          default:
            (0, E.X)(
              !1,
              `GetNodeOutputShape - NEED TO IMPLEMENT node type ${t.type()}`,
            );
        }
        return r;
      }
      function oe(e, t, a) {
        const n = t.project_nodes().findIndex((e) => e.node_id() == a);
        if (-1 == n) return;
        const o = t
          .project_nodes()
          [n].connectors()
          .map((e) => e.connector_id());
        for (let e of t.project_nodes())
          for (let t of e.connectors())
            t.set_linked_connector_ids(
              t.linked_connector_ids().filter((e) => !o.includes(e)),
            );
        t.project_nodes().splice(n, 1), se(e);
      }
      function re(e) {
        let t = [];
        for (const a of e.data_source_element_usages())
          0 != a.input() && (t.includes(a.input()) || t.push(a.input()));
        return t.sort();
      }
      function se(e) {
        !(function (e) {
          let t = re(e);
          for (; t.length > 0; ) {
            const a = t[0];
            if (
              null ==
              e
                .project_nodes()
                .find(
                  (e) =>
                    e.type() == v.scw.STEAMLEARN_NODE_TYPE_INPUT &&
                    e.input().input_num() == a,
                )
            ) {
              const [t, n] = Q(e, v.scw.STEAMLEARN_NODE_TYPE_INPUT);
              let o = new v.UYo();
              o.set_connector_id(ee(e)), o.set_is_input_connector(!1);
              let r = new v._ur();
              r.set_node_id(J(e)),
                r.set_type(v.scw.STEAMLEARN_NODE_TYPE_INPUT),
                r.set_location_x(t),
                r.set_location_y(n),
                r.set_comment(""),
                r.input().set_input_num(a),
                r.add_connectors(o),
                e.add_project_nodes(r);
            }
            t.shift();
          }
          t = re(e);
          const a = e
            .project_nodes()
            .filter(
              (e) =>
                e.type() != v.scw.STEAMLEARN_NODE_TYPE_INPUT ||
                t.includes(e.input().input_num()),
            );
          if (
            (e.set_project_nodes(a),
            !(
              null !=
              e
                .project_nodes()
                .find((e) => e.type() == v.scw.STEAMLEARN_NODE_TYPE_TRAIN)
            ))
          ) {
            const [t, a] = Q(e, v.scw.STEAMLEARN_NODE_TYPE_TRAIN),
              n = q(e, 2);
            let o = new v.UYo();
            o.set_connector_id(n[0]), o.set_is_input_connector(!0);
            let r = new v.UYo();
            r.set_connector_id(n[1]), r.set_is_input_connector(!0);
            let s = new v._ur();
            s.set_node_id(J(e)),
              s.set_type(v.scw.STEAMLEARN_NODE_TYPE_TRAIN),
              s.set_location_x(t),
              s.set_location_y(a),
              s.set_comment(""),
              s.train().set_input_count(1),
              s
                .train()
                .set_activation(v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SIGMOID),
              s.train().set_compact_table(""),
              s.train().set_width(0),
              s.train().set_optimizer(v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADAM),
              s
                .train()
                .set_loss(v.abR.STEAMLEARN_TRAIN_LOSS_BINARY_CROSSENTROPY),
              s.add_connectors(o),
              s.add_connectors(r),
              e.add_project_nodes(s);
          }
        })(e.unpublished_config()),
          localStorage.setItem(M(e.project_id()), e.serializeBase64String()),
          T.U.invalidateQueries([P, e.project_id()]);
      }
      function ce(e, t) {
        const a = (function (e) {
          return T.U.getQueryData([A, e]);
        })(t);
        if (!a) return !1;
        for (const n of a.structure().elements())
          ie(e.unpublished_config(), "", t, n);
        return e.unpublished_config().add_data_source_ids(t), !0;
      }
      function ie(e, t, a, n) {
        for (let o = 0; o < n.count(); o++) {
          const r = `${t}${0 == t.length ? "" : "/"}${n.name()}#${o}`;
          if (n.data_type() == v.rSG.STEAMLEARN_DATATYPE_OBJECT)
            for (const t of n.object().elements()) ie(e, r, a, t);
          else {
            let t = new v.Y0T();
            t.set_data_source_id(a),
              t.set_input(0),
              t.set_data_element_path(r),
              t.set_is_string(
                n.data_type() == v.rSG.STEAMLEARN_DATATYPE_STRING,
              ),
              t.set_preprocessing_type(v.foW.STEAMLEARN_ELEMENT_PROCESS_NONE),
              t.set_min_range(0),
              t.set_max_range(0),
              t.set_std_dev(1),
              t.set_compact_table(""),
              e.add_data_source_element_usages(t);
          }
        }
      }
      function le(e, t, a) {
        return (
          e.length > 0 &&
          /^[\d]*$/.test(e) &&
          (void 0 === t || parseInt(e) >= t) &&
          (void 0 === a || parseInt(e) <= a)
        );
      }
      function _e(e, t, a) {
        return (
          /^[\d]*\.?[\d]*$/.test(e) &&
          (void 0 === t || parseFloat(e) >= t) &&
          (void 0 === a || parseFloat(e) <= a)
        );
      }
      function de(e, t) {
        for (const a of e.data_source_element_usages())
          if (a.compact_table() == t) return !0;
        for (const a of e.project_nodes())
          if (
            a.type() == v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_EXTRACT &&
            a.conditional_extract().extracted_compact_table() == t
          )
            return !0;
        return !1;
      }
      function me(e, t, a, n) {
        return (0, _.mG)(this, void 0, void 0, function* () {
          console.log(`Comparing ${e}, ${t} to ${a}, ${n}`);
          try {
            const [o, r] = yield T.U.fetchQuery([P, e], () => V(e)),
              [s, c] = yield T.U.fetchQuery([P, a], () => V(a));
            let i = o
                .published_configs()
                .find((e) => e.published_version() == t),
              l = s.published_configs().find((e) => e.published_version() == n);
            if (
              (0 == t && (i = o.unpublished_config()),
              0 == n && (l = s.unpublished_config()),
              null == i || null == l)
            )
              return !1;
            if (
              i.data_source_element_usages().length !=
              l.data_source_element_usages().length
            )
              return !1;
            for (const e of i.data_source_element_usages())
              if (
                null ==
                l
                  .data_source_element_usages()
                  .find(
                    (t) =>
                      e.input() == t.input() &&
                      e.data_source_id() == t.data_source_id() &&
                      e.data_element_path() == t.data_element_path(),
                  )
              )
                return !1;
            return !0;
          } catch (e) {
            return console.log(e), !1;
          }
        });
      }
      var ue = a(80810),
        Ee = a(64403),
        pe = a.n(Ee);
      const Se = (e) => {
          const t = B(e.nDataSourceID);
          if (!t.isSuccess) return null;
          const a = t.data,
            n = ((r = e.nDataSourceID), T.U.getQueryData([R, r]) || "");
          var r;
          return o.createElement(
            "div",
            { className: ue.DataSourceListElement },
            o.createElement("div", { className: ue.Name }, a.name()),
            o.createElement(
              "div",
              { className: ue.Version },
              `v${a.version()}`,
            ),
            o.createElement(
              "div",
              { className: ue.Description },
              a.source_description(),
            ),
            a.cache_duration_seconds() > 0 &&
              o.createElement(
                o.Fragment,
                null,
                o.createElement(
                  "div",
                  { className: ue.CacheDuration },
                  (0, l.Xx)(
                    "#SteamLearn_DataSource_CacheDuration",
                    a.cache_duration_seconds(),
                  ),
                ),
                o.createElement(
                  "div",
                  {
                    className: ue.TextButton,
                    onClick: () => navigator.clipboard.writeText(n),
                  },
                  (0, l.Xx)("#SteamLearn_DataSource_HMACKey"),
                ),
              ),
            0 == a.cache_duration_seconds() &&
              o.createElement(
                "div",
                { className: ue.CacheDuration },
                (0, l.Xx)("#SteamLearn_DataSource_Uncached"),
              ),
            o.createElement(
              s.rU,
              { to: _a.SteamLearnDataSourceInspect(a.id()) },
              (0, l.Xx)("#SteamLearn_DataSource_ViewStructure"),
            ),
          );
        },
        Ne = () => {
          const e = X();
          if (!e.isSuccess) return null;
          const t = T.U.getQueryData([y]) || "",
            a = e.data;
          return o.createElement(
            "div",
            { className: ue.DataSourceListPage },
            o.createElement(
              "div",
              { className: ue.DataSourceList },
              a.map((e) =>
                o.createElement(Se, { key: e.id(), nDataSourceID: e.id() }),
              ),
            ),
            o.createElement(
              "div",
              { className: ue.RegistrationKey },
              (0, l.Xx)("#SteamLearn_DataSources_HMACKey"),
              o.createElement(
                "div",
                {
                  className: pe()(ue.SteamLearnButton, ue.Blue),
                  onClick: () => navigator.clipboard.writeText(t),
                },
                (0, l.Xx)("#SteamLearn_DataSources_HMACKey_Copy"),
              ),
            ),
          );
        };
      var ge = a(31546),
        ve = a(75962);
      const Te = (e) => {
          const t =
              e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_FLOAT32,
            a = e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_BOOL,
            n = e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_INT32,
            r = e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_STRING,
            s = e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_OBJECT;
          return o.createElement(
            "div",
            { className: ge.DataSourceElement },
            o.createElement(
              "div",
              { className: ge.ElementInfo },
              (0, ve.bE)(1, e.nIndent).map((t) => {
                const a = e.bFirstSubElement && t == e.nIndent,
                  n = e.bLastSubElement && t == e.nIndent;
                return o.createElement(
                  "div",
                  {
                    key: `${e.msgElement.name()}_${e.nIndent}_${t}`,
                    className: (0, i.Z)(
                      ge.IndentBarContainer,
                      a && ge.ShortTop,
                      n && ge.ShortBottom,
                    ),
                  },
                  o.createElement("div", { className: ge.IndentBar }),
                );
              }),
              o.createElement(
                "div",
                { className: ge.Details },
                o.createElement(
                  "div",
                  { className: ge.ElementName },
                  e.msgElement.name(),
                ),
                o.createElement(
                  "div",
                  {
                    className: (0, i.Z)(
                      ge.Type,
                      ge.DataSourceType,
                      t && ge.Float,
                      a && ge.Bool,
                      n && ge.Int,
                      r && ge.String,
                      s && ge.Object,
                    ),
                  },
                  t &&
                    (0, l.Xx)(
                      "#SteamLearn_DataSource_Type_Float",
                      e.msgElement.count() > 1
                        ? ` [${e.msgElement.count()}]`
                        : "",
                    ),
                  a &&
                    (0, l.Xx)(
                      "#SteamLearn_DataSource_Type_Bool",
                      e.msgElement.count() > 1
                        ? ` [${e.msgElement.count()}]`
                        : "",
                    ),
                  n &&
                    (0, l.Xx)(
                      "#SteamLearn_DataSource_Type_Int",
                      e.msgElement.count() > 1
                        ? ` [${e.msgElement.count()}]`
                        : "",
                    ),
                  r &&
                    (0, l.Xx)(
                      "#SteamLearn_DataSource_Type_String",
                      e.msgElement.count() > 1
                        ? ` [${e.msgElement.count()}]`
                        : "",
                    ),
                  s &&
                    (0, l.Xx)(
                      "#SteamLearn_DataSource_Type_Object",
                      e.msgElement.count() > 1
                        ? ` [${e.msgElement.count()}]`
                        : "",
                    ),
                ),
              ),
            ),
            e.msgElement.data_type() == v.rSG.STEAMLEARN_DATATYPE_OBJECT &&
              o.createElement(
                "div",
                { className: ge.SubObjectContainer },
                e.msgElement
                  .object()
                  .elements()
                  .map((t, a) =>
                    o.createElement(Te, {
                      key: `${e.nIndent}_${a}`,
                      msgElement: t,
                      nIndent: e.nIndent + 1,
                      bFirstSubElement: 0 == a,
                      bLastSubElement:
                        a == e.msgElement.object().elements().length - 1,
                    }),
                  ),
              ),
          );
        },
        Le = () => {
          const e = (0, r.UO)(),
            t = B(parseInt(e.id));
          if (t.isError)
            return o.createElement(
              "div",
              { className: ge.Error },
              (0, l.Xx)("#SteamLearn_DataSourceInspect_Error"),
            );
          if (t.isLoading)
            return o.createElement(
              "div",
              { className: ge.Loading },
              (0, l.Xx)("#SteamLearn_Loading"),
            );
          if (!t.isSuccess) return null;
          const a = t.data;
          return o.createElement(
            "div",
            { className: ge.DataSourceInspectPage },
            o.createElement(
              "div",
              { className: ge.DataSourceHeader },
              o.createElement("div", { className: ge.Name }, a.name()),
              o.createElement(
                "div",
                { className: ge.Description },
                a.source_description(),
              ),
              o.createElement(
                "div",
                { className: ge.Version },
                `v${a.version()}`,
              ),
              a.cache_duration_seconds() > 0 &&
                o.createElement(
                  "div",
                  { className: ge.CacheDuration },
                  (0, l.Xx)(
                    "#SteamLearn_DataSource_CacheDuration",
                    a.cache_duration_seconds(),
                  ),
                ),
              0 == a.cache_duration_seconds() &&
                o.createElement(
                  "div",
                  { className: ge.CacheDuration },
                  (0, l.Xx)("#SteamLearn_DataSource_Uncached"),
                ),
            ),
            o.createElement(
              "div",
              { className: ge.DataSourceDetailsContainer },
              a
                .structure()
                .elements()
                .map((e, t) =>
                  o.createElement(Te, {
                    key: `root_${t}`,
                    msgElement: e,
                    nIndent: 0,
                  }),
                ),
            ),
          );
        };
      var fe = a(28425);
      const he = (e) => {
          const t = F(e.nProjectID);
          if (!t.isSuccess) return null;
          const a = t.data[0],
            n = ((r = e.nProjectID), T.U.getQueryData([k, r]) || "");
          var r;
          const c = Math.max(
            0,
            ...a.published_configs().map((e) => e.published_version()),
          );
          return o.createElement(
            "div",
            { className: fe.ProjectListElement },
            o.createElement("div", { className: fe.Name }, a.project_name()),
            o.createElement(
              "div",
              { className: fe.Description },
              a.project_description(),
            ),
            o.createElement(
              "div",
              { className: fe.CreatedDate },
              (0, l.Xx)(
                "#SteamLearn_Project_Create_Time",
                (0, l.$1)(a.create_time()),
              ),
            ),
            o.createElement(
              "div",
              { className: fe.Version },
              a.published_configs().length || "Unpublished",
            ),
            o.createElement(
              "div",
              {
                className: fe.TextButton,
                onClick: () => navigator.clipboard.writeText(n),
              },
              (0, l.Xx)("#SteamLearn_Project_Snapshot_HMACKey"),
            ),
            o.createElement(
              s.rU,
              {
                to: _a.SteamLearnProjectDataSources(a.project_id(), c),
                className: (0, i.Z)(fe.SteamLearnButton, fe.Blue),
              },
              (0, l.Xx)("#SteamLearn_Project_Select"),
            ),
          );
        },
        De = () => {
          const e = H();
          return e.isLoading
            ? o.createElement(
                "div",
                { className: fe.InitStatus },
                (0, l.Xx)("#SteamLearn_Status_Loading"),
              )
            : e.isSuccess
            ? o.createElement(
                "div",
                { className: fe.ProjectListPage },
                e.data.map((e) =>
                  o.createElement(he, {
                    key: e.project_id(),
                    nProjectID: e.project_id(),
                  }),
                ),
                0 == e.data.length &&
                  o.createElement(
                    "div",
                    null,
                    (0, l.Xx)("#SteamLearn_Project_Empty"),
                  ),
                o.createElement(
                  s.rU,
                  {
                    to: _a.SteamLearnProjectCreate(),
                    className: (0, i.Z)(
                      "btn_blue_white_innerfade btn_medium",
                      fe.SteamLearnButton,
                    ),
                  },
                  (0, l.Xx)("#SteamLearn_Project_CreateNewProject"),
                ),
              )
            : o.createElement(
                "div",
                { className: fe.InitStatus },
                (0, l.Xx)("#SteamLearn_Status_Error"),
              );
        };
      var Ce = a(38784);
      const Ae = (e) => {
          let t = {
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            hour12: !0,
          };
          switch (e.msgEvent.event_type()) {
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_STARTED:
              return o.createElement(
                "div",
                {
                  className: (0, i.Z)(
                    Ce.EventCapsuleBody,
                    Ce.EventTrainStarted,
                  ),
                },
                o.createElement(
                  "div",
                  { className: Ce.ProjectName },
                  o.createElement(
                    "span",
                    { className: Ce.ProjectID },
                    `${e.nProjectID} - `,
                  ),
                  e.strProjectName,
                ),
                o.createElement(
                  "div",
                  { className: Ce.Type },
                  (0, l.Xx)("#SteamLearn_Event_Type_TrainStarted"),
                ),
                o.createElement(
                  "div",
                  { className: Ce.Timestamp },
                  new Date(1e3 * e.msgEvent.timestamp()).toLocaleString(
                    "en-US",
                    t,
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_FetchID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_started().fetch_id(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_TrainID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_started().train_id(),
                  ),
                ),
              );
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_ENDED:
              return o.createElement(
                "div",
                {
                  className: (0, i.Z)(
                    Ce.EventCapsuleBody,
                    Ce.EventTrainStarted,
                  ),
                },
                o.createElement(
                  "div",
                  { className: Ce.ProjectName },
                  o.createElement(
                    "span",
                    { className: Ce.ProjectID },
                    `${e.nProjectID} - `,
                  ),
                  e.strProjectName,
                ),
                o.createElement(
                  "div",
                  { className: Ce.Type },
                  (0, l.Xx)("#SteamLearn_Event_Type_TrainEnded"),
                ),
                o.createElement(
                  "div",
                  { className: Ce.Timestamp },
                  new Date(1e3 * e.msgEvent.timestamp()).toLocaleString(
                    "en-US",
                    t,
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_FetchID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_ended().fetch_id(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_TrainID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_ended().train_id(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_Loss"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_ended().loss().toFixed(5),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_Accuracy"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_ended().accuracy().toFixed(5),
                  ),
                ),
              );
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_SET_LIVE:
              return o.createElement(
                "div",
                {
                  className: (0, i.Z)(
                    Ce.EventCapsuleBody,
                    Ce.EventTrainStarted,
                  ),
                },
                o.createElement(
                  "div",
                  { className: Ce.Type },
                  (0, l.Xx)("#SteamLearn_Event_Type_TrainSetLive"),
                ),
                o.createElement(
                  "div",
                  { className: Ce.ProjectName },
                  e.strProjectName,
                ),
                o.createElement(
                  "div",
                  { className: Ce.Timestamp },
                  e.msgEvent.timestamp().toLocaleString("en-US", t),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_FetchID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_set_live().train_id(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_TrainID"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_set_live().train_id(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_ManualSetLive"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    (0, l.Xx)(
                      (e.msgEvent.train_set_live().manual_set_live(),
                      "#SteamLearn_Yes"),
                    ),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_Loss"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_set_live().accuracy_difference(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: Ce.LabelValue },
                  o.createElement(
                    "div",
                    { className: Ce.Label },
                    (0, l.Xx)("#SteamLearn_Event_Accuracy"),
                  ),
                  o.createElement(
                    "div",
                    { className: Ce.Value },
                    e.msgEvent.train_set_live().accuracy_threshold(),
                  ),
                ),
              );
            case v.L$A.STEAMLEARN_LOG_EVENT_SCHEDULED_TRAIN:
              return o.createElement(
                "div",
                {
                  className: (0, i.Z)(
                    Ce.EventCapsuleBody,
                    Ce.EventTrainStarted,
                  ),
                },
                o.createElement(
                  "div",
                  { className: Ce.ProjectName },
                  o.createElement(
                    "span",
                    { className: Ce.ProjectID },
                    `${e.nProjectID} - `,
                  ),
                  e.strProjectName,
                ),
                o.createElement(
                  "div",
                  { className: Ce.Type },
                  (0, l.Xx)("#SteamLearn_Event_Type_ScheduledTrain"),
                ),
                o.createElement(
                  "div",
                  { className: Ce.Timestamp },
                  new Date(1e3 * e.msgEvent.timestamp()).toLocaleString(
                    "en-US",
                    t,
                  ),
                ),
              );
            default:
              return null;
          }
        },
        Ie = (e) => {
          let t = 0;
          switch (e.msgEvent.event_type()) {
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_STARTED:
              t = e.msgEvent.train_started().project_id();
              break;
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_ENDED:
              t = e.msgEvent.train_ended().project_id();
              break;
            case v.L$A.STEAMLEARN_LOG_EVENT_TRAIN_SET_LIVE:
              t = e.msgEvent.train_set_live().project_id();
              break;
            case v.L$A.STEAMLEARN_LOG_EVENT_SCHEDULED_TRAIN:
              t = e.msgEvent.scheduled_train().project_id();
          }
          const a = F(t);
          let n = "";
          if (a.isSuccess) {
            const [e, t] = a.data;
            n = e.project_name();
          }
          return o.createElement(
            "div",
            { className: Ce.ProjectEventCapsule },
            o.createElement(Ae, {
              nProjectID: t,
              strProjectName: n,
              msgEvent: e.msgEvent,
            }),
          );
        },
        Pe = () => {
          const e = Z(2, 7);
          if (e.isLoading)
            return o.createElement(
              "div",
              { className: Ce.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Loading"),
            );
          if (!e.isSuccess)
            return o.createElement(
              "div",
              { className: Ce.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Error"),
            );
          const t = e.data;
          return o.createElement(
            "div",
            { className: Ce.ProjectEventsPage },
            t
              .event_list()
              .map((e, t) =>
                o.createElement(Ie, { key: `event_${t}`, msgEvent: e }),
              ),
          );
        };
      var Oe = a(2089),
        xe = a(22444),
        je = a(57742),
        be = a(89156);
      const ye = () => {
          const [e, t] = o.useState(""),
            [a, n] = o.useState(""),
            [r, s] = o.useState(!1);
          return o.createElement(
            "div",
            { className: Oe.ProjectCreatePage },
            o.createElement(
              "div",
              { className: Oe.EditSection },
              o.createElement(
                "div",
                { className: Oe.InputTitle },
                (0, l.Xx)("#SteamLearn_Project_Create_Name"),
              ),
              o.createElement("input", {
                className: Oe.InputWide,
                type: "text",
                value: e,
                onChange: (e) => {
                  t(e.target.value), s(e.target.value.length > 0);
                },
              }),
              o.createElement(
                "div",
                { className: Oe.InputTitle },
                (0, l.Xx)("#SteamLearn_Project_Create_Desc"),
              ),
              o.createElement("textarea", {
                className: Oe.InputAreaWide,
                value: a,
                onChange: (e) => n(e.target.value),
              }),
            ),
            o.createElement(
              "div",
              { className: Oe.GuideText },
              (0, l.Xx)("#SteamLearn_Project_Create_Guidance"),
            ),
            o.createElement(
              "div",
              {
                className: (0, i.Z)(
                  "btn_blue_white_innerfade btn_medium",
                  Oe.SteamLearnButton,
                  !r && "btn_disabled",
                ),
                onClick: () =>
                  (0, _.mG)(void 0, void 0, void 0, function* () {
                    s(!1);
                    const [t, n] = yield (function (e, t) {
                      return (0, _.mG)(this, void 0, void 0, function* () {
                        let a = g.gA.Init(v.zuF);
                        a.Body().set_project_name(e),
                          a.Body().set_project_description(t);
                        const n = yield v.NG.CreateProject(
                          p.Get().GetServiceTransport(),
                          a,
                        );
                        return (
                          n &&
                            n.GetEResult() == N.s.k_EResultOK &&
                            (T.U.setQueryData(
                              [P, n.Body().project().project_id()],
                              n.Body().project(),
                            ),
                            T.U.invalidateQueries([I])),
                          [n.Body().result(), n.Body().project().project_id()]
                        );
                      });
                    })(e, a);
                    switch (t) {
                      case v.$VX.STEAMLEARN_CREATEPROJECT_SUCCESS: {
                        const e =
                          m.De.PARTNER_BASE_URL +
                          _a.SteamLearnBase() +
                          _a.SteamLearnProjectDataSources(n, 0);
                        (0, je.AM)(
                          o.createElement(Re, {
                            strResult: "Success!",
                            strRedirect: e,
                          }),
                          window,
                        );
                        break;
                      }
                      case v.$VX
                        .STEAMLEARN_CREATEPROJECT_ERROR_INVALID_PROJECT_NAME:
                        (0, je.AM)(
                          o.createElement(Re, { strResult: "Bad Name!" }),
                          window,
                        );
                        break;
                      case v.$VX.STEAMLEARN_CREATEPROJECT_ERROR_GENERIC:
                        (0, je.AM)(
                          o.createElement(Re, { strResult: "Nope!" }),
                          window,
                        );
                    }
                    s(!0);
                  }),
              },
              (0, l.Xx)("#SteamLearn_Project_Create"),
            ),
          );
        },
        Re = (e) => {
          const t = () => {
            e.strRedirect && (window.location.href = e.strRedirect),
              e.closeModal();
          };
          return o.createElement(
            be.R,
            {
              className: Oe.CreateProjectResultDialog,
              onCancel: t,
              closeModal: t,
            },
            o.createElement(
              "div",
              { className: Oe.CreateProjectResultDialogContents },
              e.strResult,
              o.createElement(xe.zx, { onClick: t }, (0, l.Xx)("#Button_OK")),
            ),
          );
        };
      var ke = a(94172);
      const Me = o.createContext(null),
        Xe = () => o.useContext(Me);
      function Be(e) {
        return o.createElement(
          Me.Provider,
          { value: e.steamLearnContext },
          e.children,
        );
      }
      const we = (e) => {
          const t = B(e.nDataSourceID);
          if (!e.nDataSourceID)
            return o.createElement(Be, { steamLearnContext: {} }, e.children);
          if (t.isLoading)
            return o.createElement(
              "div",
              { className: ke.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Loading"),
            );
          if (t.isError)
            return o.createElement(
              "div",
              { className: ke.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Error"),
            );
          const a = t.data;
          return o.createElement(
            Be,
            {
              steamLearnContext: {
                nDataSourceID: e.nDataSourceID,
                msgDataSource: a,
              },
            },
            e.children,
          );
        },
        We = (e) => {
          const t = F(e.nProjectID);
          if (!e.nProjectID)
            return o.createElement(Be, { steamLearnContext: {} }, e.children);
          if (t.isLoading)
            return o.createElement(
              "div",
              { className: ke.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Loading"),
            );
          if (t.isError)
            return o.createElement(
              "div",
              { className: ke.InitStatus },
              (0, l.Xx)("#SteamLearn_Status_Error"),
            );
          const [a, n] = t.data,
            r =
              0 == e.nPublishedVersion
                ? n.unpublished_config()
                : n
                    .published_configs()
                    .find((t) => t.published_version() == e.nPublishedVersion);
          return o.createElement(
            Be,
            {
              steamLearnContext: {
                nProjectID: e.nProjectID,
                nPublishedVersion: e.nPublishedVersion,
                msgProject: a,
                msgWorkingProject: n,
                msgWorkingProjectConfig: r,
              },
            },
            e.children,
          );
        },
        Ve = (e) => {
          const t = (0, r.TH)(),
            a = t.pathname.includes(`/${_a.SteamLearnDataSource()}/`),
            n = t.pathname.includes(`/${_a.SteamLearnProject()}/`);
          let s, c, i;
          for (const e of Object.values(_a)) {
            const a = e(void 0, void 0, void 0, void 0),
              n = (0, r.LX)(t.pathname, a);
            n &&
              (a.includes(`/${_a.SteamLearnDataSource()}/`) &&
                void 0 !== n.params.id &&
                (s = parseInt(n.params.id)),
              a.includes(`/${_a.SteamLearnProject()}/`) &&
                (void 0 !== n.params.id && (c = parseInt(n.params.id)),
                void 0 !== n.params.version &&
                  (i = parseInt(n.params.version))));
          }
          return a && void 0 !== s
            ? o.createElement(we, { nDataSourceID: s }, e.children)
            : n && void 0 !== c
            ? o.createElement(
                We,
                { nProjectID: c, nPublishedVersion: i },
                e.children,
              )
            : o.createElement(Be, { steamLearnContext: {} }, e.children);
        };
      var He = a(67736),
        Fe = a(68763);
      const Ge = (e) => {
          const [t, a] = o.useState(e.arrVersions[0]);
          return o.createElement(
            He.RG,
            { closeModal: e.closeModal },
            o.createElement(
              xe.h4,
              null,
              " ",
              (0, l.Xx)("#SteamLearn_Project_CopyPublished") ||
                o.createElement(o.Fragment, null, " "),
              " ",
            ),
            o.createElement(
              xe.uT,
              null,
              o.createElement(
                xe.Ac,
                null,
                (0, l.Xx)("#SteamLearn_Project_CopyPublished_Warning"),
              ),
              o.createElement(
                "select",
                { onChange: (e) => a(parseInt(e.target.value)) },
                e.arrVersions.map((e) =>
                  o.createElement(
                    "option",
                    { key: e, value: e },
                    `Version ${e}`,
                  ),
                ),
              ),
              o.createElement(
                xe.$_,
                null,
                o.createElement(xe.o9, {
                  onCancel: e.closeModal,
                  onOK: () =>
                    ((t) => {
                      const a = e.msgWorkingProject
                        .published_configs()
                        .find((e) => e.published_version() == t);
                      a &&
                        (e.msgWorkingProject.set_unpublished_config(
                          a.cloneMessage(),
                        ),
                        e.msgWorkingProject
                          .unpublished_config()
                          .set_published_version(0),
                        se(e.msgWorkingProject),
                        K(e.msgWorkingProject, 0)),
                        e.closeModal();
                    })(t),
                }),
              ),
            ),
          );
        },
        Ue = (e) => {
          const t = (0, r.k6)(),
            a = (0, r.UO)(),
            {
              msgProject: n,
              msgWorkingProject: s,
              nProjectID: c,
              nPublishedVersion: d,
            } = Xe(),
            [m, u] = o.useState(!1),
            [E, S] = o.useState(""),
            [T, L] = o.useState(!1),
            [f, h] = o.useState("");
          let D = [
            {
              label: (0, l.Xx)("#SteamLearn_Header_Version_Unpublished"),
              value: 0,
            },
          ];
          for (const e of s.published_configs())
            D.push({
              label: (0, l.Xx)(
                "#SteamLearn_Header_Version_PublishedVersion",
                e.published_version(),
              ),
              value: e.published_version(),
            });
          if (!s) return null;
          const C = () => {
              s.set_project_name(E), se(s), u(!1);
            },
            A = () => {
              s.set_project_description(f), se(s), L(!1);
            },
            I =
              n && s && s.serializeBase64String() != n.serializeBase64String();
          return o.createElement(
            "div",
            { className: Fe.ProjectHeader },
            o.createElement(
              "div",
              { className: Fe.LeftSection },
              o.createElement(
                "div",
                { className: Fe.ProjectName },
                m &&
                  o.createElement("input", {
                    type: "text",
                    autoFocus: !0,
                    className: (0, i.Z)(Fe.ValueInput),
                    value: E,
                    onChange: (e) => S(e.target.value),
                    onBlur: C,
                    onKeyDown: (e) => {
                      switch (e.key) {
                        case "Enter":
                          C();
                          break;
                        case "Escape":
                          u(!1);
                      }
                    },
                  }),
                !m && s.project_name(),
                !m &&
                  o.createElement("div", {
                    className: (0, i.Z)(
                      Fe.IconMedium,
                      Fe.EditIcon,
                      "icon_steamworks",
                    ),
                    onClick: () => {
                      S(s.project_name()), u(!0);
                    },
                  }),
              ),
              o.createElement(
                "div",
                { className: Fe.Description },
                T &&
                  o.createElement("textarea", {
                    autoFocus: !0,
                    className: (0, i.Z)(Fe.InputAreaWide),
                    value: f,
                    onChange: (e) => h(e.target.value),
                    onBlur: A,
                    onKeyDown: (e) => {
                      switch (e.key) {
                        case "Enter":
                          e.shiftKey || A();
                          break;
                        case "Escape":
                          L(!1);
                      }
                    },
                  }),
                !T &&
                  (s.project_description().length > 0
                    ? s.project_description()
                    : (0, l.Xx)("#SteamLearn_Config_NoDescription")),
                !T &&
                  o.createElement("div", {
                    className: (0, i.Z)(
                      Fe.IconSmall,
                      Fe.EditIcon,
                      "icon_steamworks",
                    ),
                    onClick: () => {
                      h(s.project_description()), L(!0);
                    },
                  }),
              ),
            ),
            o.createElement(
              "div",
              { className: Fe.RightSection },
              o.createElement(
                "div",
                { className: Fe.PublishInfo },
                0 == d &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        Fe.SteamLearnButton,
                        Fe.Blue,
                        Fe.Large,
                        I && Fe.Hidden,
                      ),
                      onClick: () => {
                        (0, je.AM)(
                          o.createElement(He.uH, {
                            strTitle: (0, l.Xx)("#SteamLearn_Project_Publish"),
                            strDescription: (0, l.Xx)(
                              "#SteamLearn_Project_Publish_Warning",
                            ),
                            onOK: () =>
                              (0, _.mG)(void 0, void 0, void 0, function* () {
                                const e =
                                    Math.max(
                                      0,
                                      ...n
                                        .published_configs()
                                        .map((e) => e.published_version()),
                                    ) + 1,
                                  o = yield (function (e) {
                                    return (0, _.mG)(
                                      this,
                                      void 0,
                                      void 0,
                                      function* () {
                                        let t = g.gA.Init(v.FBh);
                                        t.Body().set_project_id(e);
                                        const a = yield v.NG.PublishProject(
                                          p.Get().GetServiceTransport(),
                                          t,
                                        );
                                        return a.BIsValid() &&
                                          a.GetEResult() == N.s.k_EResultOK
                                          ? (a.Body().result() ==
                                              v.zAA
                                                .STEAMLEARN_PUBLISHPROJECT_SUCCESS &&
                                              z(e),
                                            a.Body().result())
                                          : v.zAA
                                              .STEAMLEARN_PUBLISHPROJECT_ERROR_GENERIC;
                                      },
                                    );
                                  })(s.project_id());
                                o == v.zAA.STEAMLEARN_PUBLISHPROJECT_SUCCESS &&
                                  setInterval(() => da(t, a, e), 500);
                              }),
                          }),
                          window,
                        );
                      },
                    },
                    (0, l.Xx)("#SteamLearn_Project_Publish"),
                  ),
                o.createElement(
                  "select",
                  {
                    className: Fe.InputSelect,
                    value: d,
                    onChange: (e) => da(t, a, parseInt(e.target.value)),
                  },
                  D.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
              ),
              o.createElement(
                "div",
                {
                  className: (0, i.Z)(
                    Fe.SteamLearnButton,
                    Fe.Blue,
                    Fe.Large,
                    !I && "btn_disabled",
                  ),
                  onClick: () => {
                    K(s, d);
                  },
                },
                (0, l.Xx)("#SteamLearn_Project_Save"),
              ),
              I &&
                o.createElement(
                  "div",
                  {
                    className: (0, i.Z)(Fe.SteamLearnButton, Fe.Red, Fe.Large),
                    onClick: () => {
                      (0, je.AM)(
                        o.createElement(He.uH, {
                          strTitle: (0, l.Xx)("#SteamLearn_Project_Discard"),
                          strDescription: (0, l.Xx)(
                            "#SteamLearn_Project_Discard_Warning",
                          ),
                          onOK: () => z(s.project_id()),
                        }),
                        window,
                      );
                    },
                  },
                  (0, l.Xx)("#SteamLearn_Project_Discard"),
                ),
              0 == d &&
                s.published_configs().length > 0 &&
                !I &&
                o.createElement(
                  "div",
                  {
                    className: (0, i.Z)(Fe.SteamLearnButton, Fe.Blue),
                    onClick: () => {
                      const e = n
                        .published_configs()
                        .map((e) => e.published_version());
                      (0, je.AM)(
                        o.createElement(Ge, {
                          arrVersions: e,
                          msgWorkingProject: s,
                        }),
                        window,
                      );
                    },
                  },
                  (0, l.Xx)("#SteamLearn_Project_CopyPublished"),
                ),
            ),
          );
        };
      var Ye = a(95917);
      const $e = () => {
          const {
              msgWorkingProject: e,
              msgWorkingProjectConfig: t,
              nProjectID: a,
              nPublishedVersion: n,
            } = Xe(),
            r = 0 == n,
            s = (t) => {
              for (const a of t) ce(e, a);
              se(e);
            },
            c = (t) => {
              !(function (e, t) {
                const a = e.unpublished_config().data_source_ids().indexOf(t);
                if (-1 == t) return !1;
                let n = e
                  .unpublished_config()
                  .data_source_element_usages()
                  .filter((e) => e.data_source_id() != t);
                (e
                  .unpublished_config()
                  .data_source_element_usages().length = 0),
                  e
                    .unpublished_config()
                    .data_source_element_usages()
                    .push(...n),
                  e.unpublished_config().data_source_ids().splice(a, 1);
              })(e, t),
                se(e);
            };
          return o.createElement(
            "div",
            { className: Ye.ProjectDataSourcesPage },
            o.createElement(Ue, { nProjectID: a }),
            o.createElement(
              "div",
              { className: Ye.ProjectConfigBody },
              o.createElement(
                "div",
                { className: Ye.OptionHeader },
                (0, l.Xx)("#SteamLearn_Config_DataSources"),
              ),
              o.createElement(
                "div",
                { className: Ye.OptionDesc },
                (0, l.Xx)("#SteamLearn_Config_DataSourcesDesc"),
              ),
              o.createElement(
                "div",
                { className: Ye.OptionBlock },
                0 == t.data_source_ids().length &&
                  o.createElement(
                    "div",
                    { className: Ye.OptionDetails },
                    (0, l.Xx)("#SteamLearn_Config_DataSources_None"),
                  ),
                t
                  .data_source_ids()
                  .map((e) =>
                    o.createElement(Qe, {
                      key: e,
                      nDataSourceID: e,
                      fnRemoveDataSource: r ? c : void 0,
                    }),
                  ),
                0 == t.published_version() &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        "btn_grey_white_innerfade btn_small",
                        Ye.SteamLearnButton,
                        Ye.Medium,
                      ),
                      onClick: () => {
                        (0, je.AM)(
                          o.createElement(Je, {
                            fnAddSelectedDataSources: s,
                            arrAlreadyAddedDataSourceIDs: t.data_source_ids(),
                          }),
                          window,
                        );
                      },
                    },
                    (0, l.Xx)("#SteamLearn_Config_DataSources_Add"),
                  ),
              ),
              o.createElement("div", { className: Ye.Separator }),
              o.createElement(
                "div",
                { className: Ye.OptionHeader },
                (0, l.Xx)("#SteamLearn_Config_DataSource_Inputs"),
              ),
              o.createElement(
                "div",
                { className: Ye.OptionDesc },
                (0, l.Xx)("#SteamLearn_Config_DataSource_InputsDesc"),
              ),
              o.createElement(Ze, null),
            ),
          );
        },
        Ze = () => {
          const { msgWorkingProjectConfig: e } = Xe();
          let t = [];
          for (const a of e.data_source_element_usages())
            t.includes(a.data_source_id()) || t.push(a.data_source_id());
          return o.createElement(
            "div",
            { className: Ye.ProjectConfigDataSourceDataElementRoutingList },
            t.map((e) => o.createElement(Ke, { key: e, nDataSourceID: e })),
          );
        },
        Ke = (e) => {
          const [t, a] = o.useState([]),
            n = B(e.nDataSourceID),
            { msgWorkingProject: r, msgWorkingProjectConfig: s } = Xe();
          if (!n.isSuccess) return null;
          const c = (e) => {
              a([...t, e]);
            },
            i = (e) => {
              a([...t.filter((t) => t != e)]);
            },
            l = n.data;
          let _ = new Map();
          for (const a of s.data_source_element_usages()) {
            if (a.data_source_id() != e.nDataSourceID) continue;
            const n = a.data_element_path().split("/"),
              o = n.map((e) => e.split("#")[0]),
              r = n.map((e) => parseInt(e.split("#")[1]));
            let s = "",
              c = "";
            for (let n = 0; n < o.length; n++) {
              (s = `${s}${0 != n ? "/" : ""}${o[n]}`),
                (c = `${c}${0 != n ? "/" : ""}${o[n]}#${r[n]}`);
              const i = n < o.length - 1,
                l = t.includes(s);
              l && (s += `#${r[n]}`);
              let d = _.get(s);
              null == d
                ? _.set(s, {
                    strName: s,
                    nCount: l ? 1 : r[n] + 1,
                    bHasChildren: i,
                    bArrayExpanded: l,
                    nIndex: l ? r[n] + 1 : void 0,
                    nDataSourceID: e.nDataSourceID,
                    arrDataElementUsagePathNames: i
                      ? [c]
                      : [a.data_element_path()],
                  })
                : d.bArrayExpanded ||
                  ((d.nCount = Math.max(d.nCount, r[n] + 1)),
                  (d.bHasChildren = i),
                  i ||
                    d.arrDataElementUsagePathNames.includes(
                      a.data_element_path(),
                    ) ||
                    d.arrDataElementUsagePathNames.push(a.data_element_path()));
            }
          }
          const d = Array.from(_.values()).sort((e, t) => {
            const a = e.strName.split("/"),
              n = t.strName.split("/"),
              o = Math.min(a.length, n.length);
            for (let e = 0; e < o; e++) {
              const t = a[e].split("#"),
                o = n[e].split("#"),
                r = t.length > 1 ? parseInt(t[1]) : 0,
                s = o.length > 1 ? parseInt(o[1]) : 0;
              if (t[0] == o[0]) {
                if (r == s) continue;
                if (r < s) return -1;
                if (r > s) return 1;
              }
              return a[e] < n[e] ? -1 : 1;
            }
            return a.length < n.length ? -1 : 1;
          });
          return o.createElement(
            "div",
            { className: Ye.ProjectConfigDataSourceElementRoutingWrapper },
            o.createElement("div", { className: Ye.DataSourceName }, l.name()),
            d.map((e, t) => {
              const a = e.strName.split("/"),
                n = 20 * a.length,
                r = a[a.length - 1];
              return o.createElement(ze, {
                key: t,
                strRenderName: r,
                nIndentSize: n,
                rgSettings: e,
                fnExpandPath: c,
                fnCollapsePath: i,
              });
            }),
          );
        },
        ze = (e) => {
          const {
              msgWorkingProject: t,
              msgWorkingProjectConfig: a,
              nPublishedVersion: n,
            } = Xe(),
            r = w(
              e.rgSettings.nDataSourceID,
              e.rgSettings.arrDataElementUsagePathNames[0],
            ),
            s = (function (e) {
              const t = F(e);
              if (!t.isSuccess) return;
              const [a, n] = t.data;
              let o = 0;
              return (
                n
                  .unpublished_config()
                  .data_source_element_usages()
                  .forEach((e) => (o = Math.max(o, e.input()))),
                o
              );
            })(a.project_id());
          let c = a
            .data_source_element_usages()
            .find(
              (t) =>
                t.data_element_path() ==
                  e.rgSettings.arrDataElementUsagePathNames[0] &&
                t.data_source_id() == e.rgSettings.nDataSourceID,
            );
          const [_, d] = o.useState(""),
            [m, u] = o.useState(!1),
            [E, p] = o.useState(!1),
            [S, N] = o.useState(""),
            [g, T] = o.useState(!1),
            [L, f] = o.useState(!1),
            [h, D] = o.useState(""),
            [C, A] = o.useState(!1),
            [I, P] = o.useState(!1),
            O = 0 == n;
          o.useEffect(() => {
            c &&
              r &&
              (m ||
                (u(!0),
                d(
                  c
                    .min_range()
                    .toFixed(
                      r.data_type() == v.rSG.STEAMLEARN_DATATYPE_FLOAT32
                        ? 2
                        : 0,
                    ),
                ),
                p(!0)),
              g ||
                (T(!0),
                N(
                  c
                    .max_range()
                    .toFixed(
                      r.data_type() == v.rSG.STEAMLEARN_DATATYPE_FLOAT32
                        ? 2
                        : 0,
                    ),
                ),
                f(!0)),
              C ||
                (A(!0),
                D(
                  c
                    .std_dev()
                    .toFixed(
                      r.data_type() == v.rSG.STEAMLEARN_DATATYPE_FLOAT32
                        ? 2
                        : 0,
                    ),
                ),
                P(!0)));
          }, [m, g, C, c, r]);
          const x = (e, t, a, n) => {
            t(e), /^-?[\d]*\.?[\d]{0,2}$/.test(e) ? (a(!0), V(n)) : a(!1);
          };
          if (!r || null == s)
            return (
              console.log(
                "couldn't find",
                e.rgSettings.arrDataElementUsagePathNames[0],
              ),
              null
            );
          const j = r.data_type() == v.rSG.STEAMLEARN_DATATYPE_FLOAT32,
            b = r.data_type() == v.rSG.STEAMLEARN_DATATYPE_BOOL,
            y = r.data_type() == v.rSG.STEAMLEARN_DATATYPE_INT32,
            R = r.data_type() == v.rSG.STEAMLEARN_DATATYPE_STRING,
            k = r.data_type() == v.rSG.STEAMLEARN_DATATYPE_OBJECT;
          let M = "";
          switch (r.data_type()) {
            case v.rSG.STEAMLEARN_DATATYPE_INT32:
              M = (0, l.Xx)("#SteamLearn_DataSource_Type_Int", "");
              break;
            case v.rSG.STEAMLEARN_DATATYPE_FLOAT32:
              M = (0, l.Xx)("#SteamLearn_DataSource_Type_Float", "");
              break;
            case v.rSG.STEAMLEARN_DATATYPE_BOOL:
              M = (0, l.Xx)("#SteamLearn_DataSource_Type_Bool", "");
              break;
            case v.rSG.STEAMLEARN_DATATYPE_STRING:
              M = (0, l.Xx)("#SteamLearn_DataSource_Type_String", "");
              break;
            case v.rSG.STEAMLEARN_DATATYPE_OBJECT:
              M = (0, l.Xx)("#SteamLearn_DataSource_Type_Object", "");
          }
          let X = "";
          if (c)
            switch (c.preprocessing_type()) {
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_NONE:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_None_Desc",
                );
                break;
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_COMPACT_TABLE:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_CompactTable_Desc",
                );
                break;
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_FULL:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormAuto_Desc",
                );
                break;
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_RANGE:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormRange_Desc",
                );
                break;
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_STDDEV:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormStdDev_Desc",
                );
                break;
              case v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_LOG_RANGE:
                X = (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormLogRange_Desc",
                );
            }
          let B = [
            {
              label: (0, l.Xx)("#SteamLearn_Config_DataSource_Input_Exclude"),
              value: 0,
            },
          ];
          for (let e = 1; e < s + 2; e++)
            B.push({
              label: (0, l.Xx)("#SteamLearn_Config_DataSource_Input_Number", e),
              value: e,
            });
          const W = [
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_None",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_NONE,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_CompactTable",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_COMPACT_TABLE,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormAuto",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_FULL,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormRange",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_RANGE,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormStdDev",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_STDDEV,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_DataSource_Input_Preprocess_NormLogRange",
                ),
                value: v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_LOG_RANGE,
              },
            ],
            V = (n) => {
              e.rgSettings.arrDataElementUsagePathNames.forEach((e) => {
                let t = a
                  .data_source_element_usages()
                  .find((t) => t.data_element_path() == e);
                n(t);
              }),
                se(t);
            },
            H =
              (null == c ? void 0 : c.preprocessing_type()) ==
                v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_RANGE ||
              (null == c ? void 0 : c.preprocessing_type()) ==
                v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_LOG_RANGE;
          return o.createElement(
            "div",
            { className: Ye.ProjectConfigDataSourceElementRouting },
            o.createElement(
              "div",
              {
                className: Ye.LeftSection,
                style: { paddingLeft: e.nIndentSize },
              },
              o.createElement(
                "div",
                { className: Ye.Name },
                e.strRenderName,
                e.rgSettings.nCount > 1 &&
                  e.rgSettings.bArrayExpanded &&
                  o.createElement(
                    "div",
                    { className: Ye.Array },
                    `[${e.rgSettings.nCount}]`,
                  ),
              ),
              o.createElement(
                "div",
                { className: Ye.TypeAndExpandCollapse },
                o.createElement(
                  "div",
                  {
                    className: (0, i.Z)(
                      Ye.Type,
                      Ye.DataSourceType,
                      j && Ye.Float,
                      b && Ye.Bool,
                      y && Ye.Int,
                      R && Ye.String,
                      k && Ye.Object,
                    ),
                  },
                  M,
                  e.rgSettings.nCount > 1 &&
                    !e.rgSettings.bArrayExpanded &&
                    o.createElement(
                      "div",
                      { className: Ye.Array },
                      `[${e.rgSettings.nCount}]`,
                    ),
                ),
                e.rgSettings.nCount > 1 &&
                  !e.rgSettings.bArrayExpanded &&
                  o.createElement(
                    "div",
                    {
                      className: Ye.Explode,
                      title: (0, l.Xx)(
                        "#SteamLearn_Config_DataSource_Input_ExplodeDesc",
                      ),
                      onClick: () => e.fnExpandPath(e.rgSettings.strName),
                    },
                    (0, l.Xx)("#SteamLearn_Config_DataSource_Input_Explode"),
                  ),
                e.rgSettings.bArrayExpanded &&
                  o.createElement(
                    "div",
                    {
                      className: Ye.Collapse,
                      title: (0, l.Xx)(
                        "#SteamLearn_Config_DataSource_Input_CollapseDesc",
                      ),
                      onClick: () =>
                        e.fnCollapsePath(e.rgSettings.strName.split("#")[0]),
                    },
                    (0, l.Xx)("#SteamLearn_Config_DataSource_Input_Collapse"),
                  ),
              ),
            ),
            o.createElement(
              "div",
              { className: Ye.InputSection },
              c &&
                o.createElement(
                  "select",
                  {
                    className: Ye.InputSelect,
                    disabled: !O,
                    value: c.input(),
                    onChange: (e) =>
                      V((t) => t.set_input(parseInt(e.target.value))),
                  },
                  B.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
            ),
            o.createElement(
              "div",
              { className: Ye.NormalizeSection },
              c &&
                0 != c.input() &&
                o.createElement(
                  o.Fragment,
                  null,
                  o.createElement(
                    "select",
                    {
                      className: Ye.InputSelect,
                      disabled: !1,
                      value: c.preprocessing_type(),
                      onChange: (e) =>
                        V((t) =>
                          t.set_preprocessing_type(parseInt(e.target.value)),
                        ),
                    },
                    W.map((e) =>
                      o.createElement(
                        "option",
                        { key: e.value, value: e.value },
                        e.label,
                      ),
                    ),
                  ),
                  o.createElement("div", {
                    className: (0, i.Z)(Ye.IconSmall, "icon_help"),
                    title: X,
                  }),
                ),
              H &&
                0 != c.input() &&
                o.createElement(
                  "div",
                  { className: Ye.Option },
                  o.createElement(
                    "div",
                    { className: Ye.Label },
                    (0, l.Xx)(
                      "#SteamLearn_Config_DataSource_Input_Preprocess_MinRange",
                    ),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(Ye.ValueInput, !E && Ye.Invalid),
                    disabled: !1,
                    value: _,
                    onChange: (e) =>
                      x(e.target.value, d, p, (t) =>
                        t.set_min_range(parseFloat(e.target.value)),
                      ),
                  }),
                ),
              H &&
                0 != c.input() &&
                o.createElement(
                  "div",
                  { className: Ye.Option },
                  o.createElement(
                    "div",
                    { className: Ye.Label },
                    (0, l.Xx)(
                      "#SteamLearn_Config_DataSource_Input_Preprocess_MaxRange",
                    ),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(Ye.ValueInput, !L && Ye.Invalid),
                    disabled: !1,
                    value: S,
                    onChange: (e) =>
                      x(e.target.value, N, f, (t) =>
                        t.set_max_range(parseFloat(e.target.value)),
                      ),
                  }),
                ),
              (null == c ? void 0 : c.preprocessing_type()) ==
                v.foW.STEAMLEARN_ELEMENT_PROCESS_NORMALIZE_STDDEV &&
                0 != c.input() &&
                o.createElement(
                  "div",
                  { className: Ye.Option },
                  o.createElement(
                    "div",
                    { className: Ye.Label },
                    (0, l.Xx)(
                      "#SteamLearn_Config_DataSource_Input_Preprocess_StdDev",
                    ),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(Ye.ValueInput, !I && Ye.Invalid),
                    disabled: !1,
                    value: h,
                    onChange: (e) =>
                      x(e.target.value, D, P, (t) =>
                        t.set_std_dev(parseFloat(e.target.value)),
                      ),
                  }),
                ),
              (null == c ? void 0 : c.preprocessing_type()) ==
                v.foW.STEAMLEARN_ELEMENT_PROCESS_COMPACT_TABLE &&
                0 != c.input() &&
                o.createElement(
                  "div",
                  { className: Ye.Option },
                  o.createElement(
                    "div",
                    { className: Ye.Label },
                    (0, l.Xx)(
                      "#SteamLearn_Config_DataSource_Input_Preprocess_TableName",
                    ),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(
                      Ye.ValueInput,
                      Ye.Wide,
                      !I && Ye.Invalid,
                    ),
                    disabled: !1,
                    value: c.compact_table(),
                    onChange: (e) =>
                      V((t) => t.set_compact_table(e.target.value)),
                  }),
                ),
            ),
          );
        },
        Qe = (e) => {
          const t = B(e.nDataSourceID),
            a = X();
          if (!t.isSuccess || !a.isSuccess) return null;
          const n = t.data;
          let r = !1;
          for (const e of a.data)
            if (n.name() == e.name() && n.version() < e.version()) {
              r = !0;
              break;
            }
          return o.createElement(
            "div",
            {
              className: (0, i.Z)(
                Ye.ProjectConfigDataSourceElement,
                r && Ye.IsOldDataSourceVersion,
              ),
            },
            o.createElement("div", { className: Ye.Name }, n.name()),
            o.createElement(
              "div",
              { className: Ye.Description },
              n.source_description(),
            ),
            o.createElement("div", { className: Ye.Version }, "v", n.version()),
            e.fnRemoveDataSource &&
              o.createElement(
                "div",
                {
                  className: Ye.Remove,
                  onClick: () => e.fnRemoveDataSource(e.nDataSourceID),
                },
                (0, l.Xx)("#SteamLearn_Config_DataSources_Remove"),
              ),
          );
        },
        Je = (e) => {
          const [t, a] = o.useState([]),
            n = X();
          if (n.isError) return e.closeModal(), null;
          if (!n.isSuccess) return null;
          const r = n.data;
          let s = new Map();
          for (const e of r)
            (!s.has(e.name()) || s.get(e.name()).version() < e.version()) &&
              s.set(e.name(), e);
          const c = Array.from(s.values()).sort((e, t) =>
            e.name() < t.name() ? -1 : 1,
          );
          let _ = "";
          return (
            (_ =
              0 == t.length
                ? (0, l.Xx)("#SteamLearn_Config_DataSourcesDialog_Add")
                : 1 == t.length
                ? (0, l.Xx)("#SteamLearn_Config_DataSourcesDialog_Add_1")
                : (0, l.Xx)(
                    "#SteamLearn_Config_DataSourcesDialog_Add_Multiple",
                    t.length,
                  )),
            o.createElement(
              be.R,
              {
                className: Ye.AddDataSourceDialog,
                onCancel: e.closeModal,
                closeModal: e.closeModal,
              },
              o.createElement(
                "div",
                { className: Ye.AddDataSourceDialogContents },
                o.createElement(
                  "div",
                  { className: Ye.Header },
                  (0, l.Xx)("#SteamLearn_Config_DataSources_Add_Header"),
                ),
                o.createElement(
                  "div",
                  { className: Ye.DataSourceListContainer },
                  c.map((n) =>
                    e.arrAlreadyAddedDataSourceIDs.includes(n.id())
                      ? null
                      : o.createElement(
                          "div",
                          {
                            key: n.id(),
                            className: (0, i.Z)(
                              Ye.DataSourceOption,
                              t.includes(n.id()) && Ye.Selected,
                            ),
                            onClick: () =>
                              ((e) => {
                                const n = t.indexOf(e);
                                a(
                                  -1 == n
                                    ? [...t, e]
                                    : [
                                        ...t.slice(void 0, n),
                                        ...t.slice(n + 1, void 0),
                                      ],
                                );
                              })(n.id()),
                          },
                          o.createElement(
                            "div",
                            { className: Ye.Name },
                            n.name(),
                          ),
                          o.createElement(
                            "div",
                            { className: Ye.Description },
                            n.source_description(),
                          ),
                          o.createElement(
                            "div",
                            { className: Ye.Version },
                            "v",
                            n.version(),
                          ),
                        ),
                  ),
                ),
                o.createElement(
                  xe.zx,
                  {
                    disabled: 0 == t.length,
                    onClick: () => {
                      e.fnAddSelectedDataSources(t), e.closeModal();
                    },
                  },
                  _,
                ),
              ),
            )
          );
        };
      var qe = a(48259),
        et = a(28445),
        tt = a(67923),
        at = a(427);
      const nt = (e) => {
          const t = e.data.msgNode,
            a = t.connectors().filter((e) => e.is_input_connector()),
            n = t.connectors().filter((e) => !e.is_input_connector()),
            {
              msgWorkingProject: r,
              msgWorkingProjectConfig: s,
              nPublishedVersion: c,
            } = Xe(),
            _ = 0 == c;
          let d = 0,
            m = [];
          for (const e of s.data_source_element_usages())
            e.input() == t.input().input_num() &&
              ((d += 1), m.push(e.data_element_path()));
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.InputNode) },
            a.map((e, t) => {
              const n = Math.floor(((t + 1) / (a.length + 1)) * 200),
                r = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: r,
                  type: "target",
                  position: tt.P.Top,
                  id: r,
                  style: { left: n },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)(
                  "#SteamLearn_Config_Node_Title_Input",
                  e.data.msgNode.input().input_num(),
                ),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              _ &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(ot, {
                        msgNode: t,
                        msgWorkingProject: r,
                        msgWorkingProjectConfig: s,
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Width"),
                  ),
                  o.createElement("div", { className: at.Value }, d),
                ),
              ),
            ),
            n.map((e, t) => {
              const a = Math.floor(((t + 1) / (n.length + 1)) * 200),
                r = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: r,
                  type: "source",
                  position: tt.P.Bottom,
                  id: r,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        ot = (e) => {
          const [t, a] = o.useState(e.msgNode.comment());
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)(
                "#SteamLearn_Config_Node_Title_Input",
                e.msgNode.input().input_num(),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () => (
                  e.msgNode.set_comment(t),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        };
      var rt = a(16749);
      const st = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = t.connectors().filter((e) => e.is_input_connector()),
            _ = t.connectors().filter((e) => !e.is_input_connector()),
            d = t.embedding().compact_table().length > 0;
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.EmbeddingNode) },
            c.map((e, t) => {
              const a = Math.floor(((t + 1) / (c.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Embedding"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              o.createElement("div", {
                className: at.EditGear,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(ct, {
                      msgNode: t,
                      msgWorkingProject: a,
                      msgWorkingProjectConfig: n,
                    }),
                    window,
                  ),
              }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Embedding_MaxValue"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    d
                      ? t.embedding().compact_table()
                      : t.embedding().max_value(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Embedding_Width"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    t.embedding().embedding_width(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Embedding_Flatten"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    t.embedding().flatten()
                      ? (0, l.Xx)("#SteamLearn_Yes")
                      : (0, l.Xx)("#SteamLearn_No"),
                  ),
                ),
              ),
            ),
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        ct = (e) => {
          const [t, a] = o.useState(e.msgNode.comment()),
            [n, r] = o.useState(
              e.msgNode.embedding().compact_table().length > 0
                ? e.msgNode.embedding().compact_table()
                : e.msgNode.embedding().max_value().toString(),
            ),
            [s, c] = o.useState(!0),
            [_, d] = o.useState(
              e.msgNode.embedding().embedding_width().toString(),
            ),
            [m, u] = o.useState(!0),
            [E, p] = o.useState(e.msgNode.embedding().flatten()),
            S = o.useCallback(
              (t) => {
                const a = le(t, 1),
                  n = de(e.msgWorkingProjectConfig, t);
                c(a || n), r(t);
              },
              [e],
            ),
            N = o.useCallback((e) => {
              u(le(e, 1)), d(e);
            }, []);
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Embedding"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_EmbeddingEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Embedding_MaxValue"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Embedding_MaxValueDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !s && at.Invalid),
                  value: n,
                  onChange: (e) => S(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Embedding_Width"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Embedding_WidthDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !m && at.Invalid),
                  value: _,
                  onChange: (e) => N(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Embedding_OutputShape"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_Embedding_OutputShapeDesc",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.CheckboxWithLabel },
                  o.createElement("input", {
                    type: "checkbox",
                    id: "editflatten",
                    checked: E,
                    onChange: () => p(!E),
                  }),
                  o.createElement(
                    "label",
                    { htmlFor: "editflatten" },
                    (0, l.Xx)("#SteamLearn_Config_Node_Embedding_Flatten"),
                  ),
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !s || !m,
                onOK: () =>
                  (() => {
                    const a = le(n, 1),
                      o = de(e.msgWorkingProjectConfig, n);
                    a
                      ? (e.msgNode
                          .embedding()
                          .set_max_value(parseInt(n.length > 0 ? n : "100")),
                        e.msgNode.embedding().set_compact_table(""))
                      : o &&
                        (e.msgNode.embedding().set_compact_table(n),
                        e.msgNode.embedding().set_max_value(0)),
                      e.msgNode.embedding().set_embedding_width(parseInt(_)),
                      e.msgNode.embedding().set_flatten(E),
                      e.msgNode.set_comment(t),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        };
      var it = a(23295);
      const lt = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = (0, it.Z)(),
            _ = e.data.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()),
            d = e.data.msgNode
              .connectors()
              .filter((e) => !e.is_input_connector());
          return (
            o.useEffect(() => {
              setTimeout(() => {
                for (const e of n.project_nodes())
                  e.type() == v.scw.STEAMLEARN_NODE_TYPE_CONCATENATE &&
                    c(f(e.node_id()));
              }, 0.1);
            }, [n, c]),
            o.createElement(
              "div",
              { className: (0, i.Z)(at.FlowNode, at.ConcatNode) },
              _.map((e, t) => {
                const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "target",
                    position: tt.P.Top,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
              o.createElement(
                "div",
                { className: at.Title },
                o.createElement(
                  "div",
                  { className: at.TitleText },
                  (0, l.Xx)("#SteamLearn_Config_Node_Title_Concat"),
                ),
                o.createElement("div", { className: at.NodeID }, t.node_id()),
                s &&
                  o.createElement("div", {
                    className: at.EditGear,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(_t, {
                          msgNode: t,
                          msgWorkingProject: a,
                          msgWorkingProjectConfig: n,
                        }),
                        window,
                      ),
                  }),
                s &&
                  o.createElement("div", {
                    className: at.Delete,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(rt.uH, {
                          strTitle: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_Node",
                          ),
                          strDescription: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_NodeDetails",
                          ),
                          onOK: () => oe(a, n, t.node_id()),
                        }),
                        window,
                      ),
                  }),
              ),
              o.createElement("div", { className: at.TitleUnderBar }),
              o.createElement(
                "div",
                { className: at.Body },
                o.createElement(
                  "div",
                  { className: at.CenterSection },
                  t.comment().length > 0 &&
                    o.createElement(
                      "div",
                      { className: at.Comment },
                      t.comment(),
                    ),
                ),
              ),
              d.map((e, t) => {
                const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "source",
                    position: tt.P.Bottom,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
            )
          );
        },
        _t = (e) => {
          const t = e.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()).length,
            [a, n] = o.useState(e.msgNode.comment()),
            [r, s] = o.useState(t.toString()),
            [c, _] = o.useState(!0),
            d = o.useCallback((e) => {
              _(le(e, 1, 8)), s(e);
            }, []);
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Concat"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_ConcatEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: a,
                  onChange: (e) => n(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Concat_NumInputs"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Concat_NumInputsDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !c && at.Invalid),
                  value: r,
                  onChange: (e) => d(e.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !c,
                onOK: () =>
                  (() => {
                    const n = parseInt(r);
                    if (n > t) {
                      const a = n - t,
                        o = q(e.msgWorkingProjectConfig, a);
                      for (let t = 0; t < a; t++) {
                        let a = new v.UYo();
                        a.set_connector_id(o[t]),
                          a.set_is_input_connector(!0),
                          e.msgNode.add_connectors(a);
                      }
                    } else if (n < t) {
                      const t = e.msgNode
                        .connectors()
                        .filter((e) => e.is_input_connector())
                        .slice(n)
                        .map((e) => e.connector_id());
                      for (let a of e.msgWorkingProjectConfig.project_nodes())
                        for (let e of a.connectors())
                          e.set_linked_connector_ids(
                            e
                              .linked_connector_ids()
                              .filter((e) => !t.includes(e)),
                          );
                      e.msgNode.set_connectors([
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector()),
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(0, n),
                      ]);
                    }
                    e.msgNode.set_comment(a),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        };
      const dt = (e) => {
          const t = e.data.msgNode,
            a = t.connectors().filter((e) => e.is_input_connector()),
            {
              msgWorkingProject: n,
              msgWorkingProjectConfig: r,
              nPublishedVersion: s,
            } = Xe(),
            c = (0, it.Z)();
          o.useEffect(() => {
            setTimeout(() => {
              for (const e of r.project_nodes())
                e.type() == v.scw.STEAMLEARN_NODE_TYPE_TRAIN &&
                  c(f(e.node_id()));
            }, 0.1);
          }, [r, c]);
          const _ = Math.max(150, 40 + 22 * (a.length - 1));
          return o.createElement(
            "div",
            {
              className: (0, i.Z)(at.FlowNode, at.TrainNode),
              style: { height: _ },
            },
            a.map((e, t) => {
              const n = t > 0,
                r = n ? Math.floor((t / a.length) * (_ - 24)) : (_ - 24) / 2,
                s = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: s,
                  type: "target",
                  position: n ? tt.P.Right : tt.P.Left,
                  id: s,
                  style: { top: r + 24 },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Train"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              o.createElement("div", {
                className: at.EditGear,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(mt, {
                      msgNode: t,
                      msgWorkingProject: n,
                      msgWorkingProjectConfig: r,
                    }),
                    window,
                  ),
              }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: (0, i.Z)(at.SideSection, at.Left) },
                o.createElement(
                  "div",
                  { className: at.SideInput },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Input"),
                ),
              ),
              o.createElement(
                "div",
                { className: at.CenterSection },
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    (function (e) {
                      switch (e) {
                        case v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SIGMOID:
                          return "Sigmoid";
                        case v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SOFTMAX:
                          return "Softmax";
                      }
                      return console.error("Invalid activation", e), "";
                    })(t.train().activation()),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_Loss"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    (function (e) {
                      switch (e) {
                        case v.abR.STEAMLEARN_TRAIN_LOSS_BINARY_CROSSENTROPY:
                          return "Binary Crossentropy";
                        case v.abR
                          .STEAMLEARN_TRAIN_LOSS_CATEGORICAL_CROSSENTROPY:
                          return "Categorical Crossentropy";
                        case v.abR
                          .STEAMLEARN_TRAIN_LOSS_SPARSE_CATEGORICAL_CROSSENTROPY:
                          return "Sparse Categorical Crossentropy";
                      }
                      return console.error("Invalid loss", e), "";
                    })(t.train().loss()),
                  ),
                ),
                t.train().compact_table().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)("#SteamLearn_Config_Node_Train_CompactTable"),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      t.train().compact_table(),
                    ),
                  ),
              ),
              o.createElement(
                "div",
                { className: (0, i.Z)(at.SideSection, at.Right) },
                (0, ve.bE)(1, t.train().input_count()).map((e) =>
                  o.createElement(
                    "div",
                    { key: e, className: at.SideInput },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_Label", e),
                  ),
                ),
              ),
            ),
          );
        },
        mt = (e) => {
          const [t, a] = o.useState(e.msgNode.train().input_count().toString()),
            [n, r] = o.useState(e.msgNode.train().activation()),
            [s, c] = o.useState(e.msgNode.train().optimizer()),
            [_, d] = o.useState(e.msgNode.train().loss()),
            [m, u] = o.useState(e.msgNode.train().compact_table()),
            [p, S] = o.useState(!0),
            [N, g] = o.useState(!0),
            T = Math.floor(
              e.msgNode.connectors().filter((e) => e.is_input_connector())
                .length,
            ),
            L = (t) => {
              g(
                de(e.msgWorkingProjectConfig, t) ||
                  (function (e, t) {
                    for (const a of e.project_nodes())
                      if (
                        a.type() == v.scw.STEAMLEARN_NODE_TYPE_KMEANS &&
                        a.kmeans().name() == t
                      )
                        return !0;
                    return !1;
                  })(e.msgWorkingProjectConfig, t),
              ),
                u(t);
            };
          let f = [
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Activation_Sigmoid",
                ),
                value: v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SIGMOID,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Activation_Softmax",
                ),
                value: v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SOFTMAX,
              },
            ],
            h = [
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Optimizer_Adam",
                ),
                value: v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADAM,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Optimizer_Adadelta",
                ),
                value: v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADADELTA,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Optimizer_Adagrad",
                ),
                value: v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADAGRAD,
              },
              {
                label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Optimizer_SGD"),
                value: v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_SGD,
              },
            ],
            D = [
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Loss_BinaryCrossEntropy",
                ),
                value: v.abR.STEAMLEARN_TRAIN_LOSS_BINARY_CROSSENTROPY,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Loss_CategoricalCrossEntropy",
                ),
                value: v.abR.STEAMLEARN_TRAIN_LOSS_CATEGORICAL_CROSSENTROPY,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_Train_Loss_SparseCategoricalCrossEntropy",
                ),
                value:
                  v.abR.STEAMLEARN_TRAIN_LOSS_SPARSE_CATEGORICAL_CROSSENTROPY,
              },
            ],
            C = !1;
          for (let t = 1; t < e.msgNode.connectors().length; t += 2) {
            const { msgIncomingNode: a, nIncomingConnectorID: n } = ae(
              e.msgWorkingProjectConfig,
              e.msgNode.connectors()[t].connector_id(),
            );
            if (a) {
              const t = ne(e.msgWorkingProjectConfig, a, n);
              if (t.length > 1)
                return (
                  (0, E.X)(
                    !1,
                    `Incoming node/connector ${a.node_id()}, ${n} have a shape with a primary dimension of ${
                      t.length
                    }!`,
                  ),
                  null
                );
              if (t.length > 0 && (t[0] > 1 || void 0 === t[0])) {
                C = !0;
                break;
              }
            }
          }
          const A =
            _ == v.abR.STEAMLEARN_TRAIN_LOSS_SPARSE_CATEGORICAL_CROSSENTROPY ||
            (_ == v.abR.STEAMLEARN_TRAIN_LOSS_BINARY_CROSSENTROPY && C);
          return o.createElement(
            be.R,
            { className: at.TrainNodeEditDialog },
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Train"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_TrainDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Count"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_CountDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !p && at.Invalid),
                  value: t,
                  onChange: (e) => {
                    return (
                      (t = a),
                      (n = S),
                      (o = e.target.value),
                      n(le(o, 1, 9)),
                      void t(o)
                    );
                    var t, n, o;
                  },
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_ActivationDesc"),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: n,
                    onChange: (e) => r(parseInt(e.target.value)),
                  },
                  f.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                n == v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SIGMOID &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_ActivationDescSub1",
                    ),
                  ),
                n == v.GCs.STEAMLEARN_TRAIN_ACTIVATION_SOFTMAX &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_ActivationDescSub2",
                    ),
                  ),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Optimizer"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_OptimizerDesc"),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: s,
                    onChange: (e) => c(parseInt(e.target.value)),
                  },
                  h.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                s == v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADAM &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_OptimizerDescSub1",
                    ),
                  ),
                s == v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADADELTA &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_OptimizerDescSub2",
                    ),
                  ),
                s == v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_ADAGRAD &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_OptimizerDescSub3",
                    ),
                  ),
                s == v.TkO.STEAMLEARN_TRAIN_OPTIMIZER_SGD &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_Train_OptimizerDescSub4",
                    ),
                  ),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Loss"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_LossDesc"),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: _,
                    onChange: (e) => d(parseInt(e.target.value)),
                  },
                  D.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                _ == v.abR.STEAMLEARN_TRAIN_LOSS_BINARY_CROSSENTROPY &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_LossDescSub1"),
                  ),
                _ == v.abR.STEAMLEARN_TRAIN_LOSS_CATEGORICAL_CROSSENTROPY &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_LossDescSub2"),
                  ),
                _ ==
                  v.abR.STEAMLEARN_TRAIN_LOSS_SPARSE_CATEGORICAL_CROSSENTROPY &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_LossDescSub3"),
                  ),
              ),
              A &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_CompactTable"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)("#SteamLearn_Config_Node_Train_CompactTableDesc"),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(at.OptionInput, !N && at.Invalid),
                    value: m,
                    onChange: (e) => L(e.target.value),
                  }),
                ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !p || !N,
                onOK: () =>
                  (() => {
                    const a = parseInt(t) + 1;
                    if (a > T) {
                      const t = a - T,
                        n = q(e.msgWorkingProjectConfig, t);
                      for (let a = 0; a < t; a++) {
                        let t = new v.UYo();
                        t.set_connector_id(n[a]),
                          t.set_is_input_connector(!0),
                          e.msgNode.add_connectors(t);
                      }
                    } else if (a < T) {
                      const t = e.msgNode
                        .connectors()
                        .filter((e) => e.is_input_connector())
                        .slice(a)
                        .map((e) => e.connector_id());
                      for (let a of e.msgWorkingProjectConfig.project_nodes())
                        for (let e of a.connectors())
                          e.set_linked_connector_ids(
                            e
                              .linked_connector_ids()
                              .filter((e) => !t.includes(e)),
                          );
                      e.msgNode.set_connectors([
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector()),
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(0, a),
                      ]);
                    }
                    e.msgNode.train().set_input_count(parseInt(t)),
                      e.msgNode.train().set_activation(n),
                      e.msgNode.train().set_optimizer(s),
                      e.msgNode.train().set_loss(_),
                      e.msgNode.train().set_compact_table(m),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        };
      const ut = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = t.connectors().filter((e) => e.is_input_connector()),
            _ = t.connectors().filter((e) => !e.is_input_connector());
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.DenseNode) },
            c.map((e, t) => {
              const a = Math.floor(((t + 1) / (c.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Dense"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              o.createElement("div", {
                className: at.EditGear,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(Et, { msgNode: t, msgWorkingProject: a }),
                    window,
                  ),
              }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Dense_Width"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    t.dense().width(),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_Activation"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    (function (e) {
                      switch (e) {
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU:
                          return "RELU";
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU:
                          return "ELU";
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH:
                          return "TANH";
                      }
                      return "";
                    })(t.dense().activation()),
                  ),
                ),
              ),
            ),
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        Et = (e) => {
          const [t, a] = o.useState(e.msgNode.comment()),
            [n, r] = o.useState(e.msgNode.dense().width().toString()),
            [s, c] = o.useState(!0),
            [_, d] = o.useState(e.msgNode.dense_stack().activation());
          let m = [
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_RELU"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU,
            },
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_ELU"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU,
            },
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_TANH"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH,
            },
          ];
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_DenseStack"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_DenseStackEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Dense_Width"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Dense_WidthDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !s && at.Invalid),
                  value: n,
                  onChange: (e) => {
                    return (t = e.target.value), c(le(t, 1, 8096)), void r(t);
                    var t;
                  },
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_Activation"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_ActivationDesc"),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: _,
                    onChange: (e) => d(parseInt(e.target.value)),
                  },
                  m.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                _ == v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub1",
                    ),
                  ),
                _ == v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub2",
                    ),
                  ),
                _ == v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub3",
                    ),
                  ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !s,
                onOK: () => (
                  e.msgNode.dense().set_width(parseInt(n)),
                  e.msgNode.dense().set_activation(_),
                  e.msgNode.set_comment(t),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        };
      const pt = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = t.connectors().filter((e) => e.is_input_connector()),
            _ = t.connectors().filter((e) => !e.is_input_connector());
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.DenseStackNode) },
            c.map((e, t) => {
              const a = Math.floor(((t + 1) / (c.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_DenseStack"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              o.createElement("div", {
                className: at.EditGear,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(St, { msgNode: t, msgWorkingProject: a }),
                    window,
                  ),
              }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                (0, ve.bE)(0, t.dense_stack().width().length - 1).map((e) =>
                  o.createElement(
                    "div",
                    { className: at.LabelValue, key: e },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)(
                        "#SteamLearn_Config_Node_DenseStack_LayerWidth",
                        e + 1,
                      ),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      t.dense_stack().width()[e],
                    ),
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_DropoutPct"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    `${t.dense_stack().dropout_pct()}%`,
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_Activation"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    (function (e) {
                      switch (e) {
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU:
                          return "RELU";
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU:
                          return "ELU";
                        case v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH:
                          return "TANH";
                      }
                      return "";
                    })(t.dense_stack().activation()),
                  ),
                ),
              ),
            ),
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        St = (e) => {
          const [t, a] = o.useState(e.msgNode.comment()),
            [n, r] = o.useState(
              e.msgNode.dense_stack().width().length.toString(),
            ),
            [s, c] = o.useState(!0),
            [_, d] = o.useState(
              e.msgNode
                .dense_stack()
                .width()
                .map((e) => e.toString()),
            ),
            [m, u] = o.useState(
              e.msgNode
                .dense_stack()
                .width()
                .map((e) => !0),
            ),
            [E, p] = o.useState(
              e.msgNode.dense_stack().dropout_pct().toString(),
            ),
            [S, N] = o.useState(!0),
            [g, T] = o.useState(e.msgNode.dense_stack().activation());
          let L = [
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_RELU"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU,
            },
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_ELU"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU,
            },
            {
              label: (0, l.Xx)("#SteamLearn_Config_Node_Train_Activation_TANH"),
              value: v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH,
            },
          ];
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_DenseStack"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_DenseStackEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_NumLayers"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !s && at.Invalid),
                  value: n,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 1, 6);
                      if ((r(e), c(t), t)) {
                        const t = parseInt(e);
                        if (t < _.length) _.splice(t);
                        else
                          for (let e = _.length; e < t; e++)
                            _.push(_[_.length - 1]);
                      }
                    })(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_LayerWidths"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_DenseStack_LayerWidthsDesc",
                  ),
                ),
                (0, ve.bE)(0, _.length - 1).map((e) =>
                  o.createElement("input", {
                    key: e,
                    type: "text",
                    className: (0, i.Z)(at.OptionInput, !m[e] && at.Invalid),
                    value: _[e],
                    onChange: (t) =>
                      ((e, t) => {
                        if (e < 0 || e >= _.length) return;
                        let a = [...m];
                        (a[e] = le(t, 1, 8096)), u(a);
                        let n = [..._];
                        (n[e] = t), d(n);
                      })(e, t.target.value),
                  }),
                ),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_DropoutPct"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_DenseStack_DropoutPctDesc",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !S && at.Invalid),
                  value: E,
                  onChange: (e) => {
                    return (
                      (t = p),
                      (a = N),
                      (n = e.target.value),
                      a(le(n, 0, 100)),
                      void t(n)
                    );
                    var t, a, n;
                  },
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_DenseStack_Activation"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_ActivationDesc"),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: g,
                    onChange: (e) => T(parseInt(e.target.value)),
                  },
                  L.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                g == v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub1",
                    ),
                  ),
                g == v.uBn.STEAMLEARN_DENSE_ACTIVATION_ELU &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub2",
                    ),
                  ),
                g == v.uBn.STEAMLEARN_DENSE_ACTIVATION_TANH &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_DenseStack_ActivationDescSub3",
                    ),
                  ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !s || !s,
                onOK: () => (
                  e.msgNode.dense_stack().set_width(_.map((e) => parseInt(e))),
                  e.msgNode.dense_stack().set_dropout_pct(parseInt(E)),
                  e.msgNode.dense_stack().set_activation(g),
                  e.msgNode.set_comment(t),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        Nt = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = t.connectors().filter((e) => e.is_input_connector()),
            _ = t.connectors().filter((e) => !e.is_input_connector());
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.DenseNode) },
            c.map((e, t) => {
              const a = Math.floor(((t + 1) / (c.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Shuffle"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              s &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(gt, { msgNode: t, msgWorkingProject: a }),
                      window,
                    ),
                }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    t.shuffle().exclude_zeroes()
                      ? (0, l.Xx)("#SteamLearn_Yes")
                      : (0, l.Xx)("#SteamLearn_No"),
                  ),
                ),
              ),
            ),
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        gt = (e) => {
          const [t, a] = o.useState(e.msgNode.comment()),
            [n, r] = o.useState(e.msgNode.shuffle().exclude_zeroes());
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Shuffle"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_ShuffleEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_Shuffle_ExcludeZeroesDesc",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.CheckboxWithLabel },
                  o.createElement("input", {
                    type: "checkbox",
                    id: "editflatten",
                    checked: n,
                    onChange: () => r(!n),
                  }),
                  o.createElement(
                    "label",
                    { htmlFor: "editflatten" },
                    (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                  ),
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () => (
                  e.msgNode.set_comment(t),
                  e.msgNode.shuffle().set_exclude_zeroes(n),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        vt = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = (0, it.Z)();
          o.useEffect(() => {
            setTimeout(() => {
              for (const e of n.project_nodes())
                e.type() == v.scw.STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE &&
                  c(f(e.node_id()));
            }, 0.1);
          }, [n, c]);
          const _ = t.connectors().filter((e) => e.is_input_connector()),
            d = t.connectors().filter((e) => !e.is_input_connector());
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.DenseNode) },
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_SyncedShuffle"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              s &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(Tt, {
                        msgNode: t,
                        msgWorkingProject: a,
                        msgWorkingProjectConfig: n,
                      }),
                      window,
                    ),
                }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    t.synced_shuffle().exclude_zeroes()
                      ? (0, l.Xx)("#SteamLearn_Yes")
                      : (0, l.Xx)("#SteamLearn_No"),
                  ),
                ),
              ),
            ),
            d.map((e, t) => {
              const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        Tt = (e) => {
          const t = e.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()).length,
            [a, n] = o.useState(e.msgNode.comment()),
            [r, s] = o.useState(t.toString()),
            [c, _] = o.useState(!0),
            [d, m] = o.useState(e.msgNode.synced_shuffle().exclude_zeroes());
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_SyncedShuffle"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)(
                  "#SteamLearn_Config_Node_Title_SyncedShuffleEditDesc",
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: a,
                  onChange: (e) => n(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_Count"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Train_CountDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !c && at.Invalid),
                  value: r,
                  onChange: (e) => {
                    return (
                      (t = s),
                      (a = _),
                      (n = e.target.value),
                      a(le(n, 1, 9)),
                      void t(n)
                    );
                    var t, a, n;
                  },
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_Shuffle_ExcludeZeroesDesc",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.CheckboxWithLabel },
                  o.createElement("input", {
                    type: "checkbox",
                    id: "editflatten",
                    checked: d,
                    onChange: () => m(!d),
                  }),
                  o.createElement(
                    "label",
                    { htmlFor: "editflatten" },
                    (0, l.Xx)("#SteamLearn_Config_Node_Shuffle_ExcludeZeroes"),
                  ),
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () =>
                  (() => {
                    const n = parseInt(r),
                      o = n;
                    if (n > t) {
                      const a = n - t,
                        o = a,
                        r = q(e.msgWorkingProjectConfig, a + o);
                      for (let t = 0; t < a; t++) {
                        let a = new v.UYo();
                        a.set_connector_id(r[t]),
                          a.set_is_input_connector(!0),
                          e.msgNode.add_connectors(a);
                      }
                      for (let t = 0; t < o; t++) {
                        let n = new v.UYo();
                        n.set_connector_id(r[a + t]),
                          n.set_is_input_connector(!1),
                          e.msgNode.add_connectors(n);
                      }
                    } else if (n < t) {
                      let t = [];
                      t.push(
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(n)
                          .map((e) => e.connector_id()),
                      ),
                        t.push(
                          ...e.msgNode
                            .connectors()
                            .filter((e) => !e.is_input_connector())
                            .slice(o)
                            .map((e) => e.connector_id()),
                        );
                      for (let a of e.msgWorkingProjectConfig.project_nodes())
                        for (let e of a.connectors())
                          e.set_linked_connector_ids(
                            e
                              .linked_connector_ids()
                              .filter((e) => !t.includes(e)),
                          );
                      e.msgNode.set_connectors([
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(0, n),
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector())
                          .slice(0, o),
                      ]);
                    }
                    e.msgNode.set_comment(a),
                      e.msgNode.synced_shuffle().set_exclude_zeroes(d),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        Lt = (e) => {
          var t;
          const a = e.data.msgNode,
            {
              msgWorkingProject: n,
              msgWorkingProjectConfig: r,
              nPublishedVersion: s,
            } = Xe(),
            c = 0 == s,
            _ = a.connectors().filter((e) => e.is_input_connector()),
            d = a.connectors().filter((e) => !e.is_input_connector()),
            m =
              (null === (t = a.onehot().compact_table()) || void 0 === t
                ? void 0
                : t.length) > 0;
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.OnehotNode) },
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Onehot"),
              ),
              o.createElement("div", { className: at.NodeID }, a.node_id()),
              c &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(ft, {
                        msgNode: a,
                        msgWorkingProject: n,
                        msgWorkingProjectConfig: r,
                      }),
                      window,
                    ),
                }),
              c &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(n, r, a.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                a.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    a.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)("#SteamLearn_Config_Node_Onehot_Width"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.Value },
                    m ? a.onehot().compact_table() : a.onehot().width(),
                  ),
                ),
              ),
            ),
            d.map((e, t) => {
              const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        ft = (e) => {
          const [t, a] = o.useState(e.msgNode.comment()),
            [n, r] = o.useState(
              e.msgNode.onehot().compact_table().length > 0
                ? e.msgNode.onehot().compact_table()
                : e.msgNode.onehot().width().toString(),
            ),
            [s, c] = o.useState(!0);
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Onehot"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_OnehotEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Onehot_Width"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Onehot_WidthDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !s && at.Invalid),
                  value: n,
                  onChange: (t) =>
                    ((t) => {
                      const a = le(t, 1, 8096),
                        n = de(e.msgWorkingProjectConfig, t);
                      c(a || n), r(t);
                    })(t.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !s,
                onOK: () =>
                  (() => {
                    const a = le(n, 1, 8096),
                      o = de(e.msgWorkingProjectConfig, n);
                    a
                      ? (e.msgNode.onehot().set_width(parseInt(n)),
                        e.msgNode.onehot().set_compact_table(""))
                      : o &&
                        (e.msgNode.onehot().set_compact_table(n),
                        e.msgNode.onehot().set_width(0)),
                      e.msgNode.set_comment(t),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        ht = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = (0, it.Z)();
          o.useEffect(() => {
            var e;
            const o =
              null ===
                (e = t.connectors().find((e) => e.is_input_connector())) ||
              void 0 === e
                ? void 0
                : e.connector_id();
            if (!o)
              return void (0, E.X)(
                !1,
                `No input connector on node ${t.toObject()}`,
              );
            const { msgIncomingNode: r, nIncomingConnectorID: s } = ae(n, o),
              i = t.connectors().filter((e) => !e.is_input_connector()).length;
            let l = i;
            if (r) {
              const e = ne(n, r, s);
              (0, E.X)(
                1 == e.length,
                `Input tensor to STEAMLEARN_NODE_TYPE_EXPLODE not one-dimensional! ( ${e} ) (node ${r.node_id()}, connector ${s}`,
              ),
                (l = Math.min(9, e[0]));
            } else l = 0;
            if (l > i) {
              const e = l - i,
                a = q(n, e);
              for (let n = 0; n < e; n++) {
                let e = new v.UYo();
                e.set_connector_id(a[n]),
                  e.set_is_input_connector(!1),
                  t.add_connectors(e);
              }
            } else if (l < i) {
              let e = [];
              e.push(
                ...t
                  .connectors()
                  .filter((e) => !e.is_input_connector())
                  .slice(l)
                  .map((e) => e.connector_id()),
              );
              for (let t of n.project_nodes())
                for (let a of t.connectors())
                  a.set_linked_connector_ids(
                    a.linked_connector_ids().filter((t) => !e.includes(t)),
                  );
              t.set_connectors([
                ...t.connectors().filter((e) => e.is_input_connector()),
                ...t
                  .connectors()
                  .filter((e) => !e.is_input_connector())
                  .slice(0, l),
              ]);
            }
            l != i && se(a),
              setTimeout(() => {
                for (const e of n.project_nodes())
                  e.type() == v.scw.STEAMLEARN_NODE_TYPE_EXPLODE &&
                    c(f(e.node_id()));
              }, 0.1);
          }, [a, n, t, c]);
          const _ = t.connectors().filter((e) => e.is_input_connector()),
            d = t.connectors().filter((e) => !e.is_input_connector());
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.ExplodeNode) },
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_Explode"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              s &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(Dt, {
                        msgNode: t,
                        msgWorkingProject: a,
                        msgWorkingProjectConfig: n,
                      }),
                      window,
                    ),
                }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
              ),
            ),
            d.map((e, t) => {
              const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        Dt = (e) => {
          const [t, a] = o.useState(e.msgNode.comment());
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Explode"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_ExplodeEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () => (
                  e.msgNode.set_comment(t),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        Ct = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = t.connectors().filter((e) => e.is_input_connector()),
            _ = t.connectors().filter((e) => !e.is_input_connector()),
            d = c.splice(0, 1)[0];
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.OnehotNode) },
            c.map((e, t) => {
              const a = Math.floor(((t + 1) / (c.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              et.HH,
              {
                type: "target",
                position: tt.P.Left,
                id: L(d.connector_id()),
                style: { top: "50%" },
              },
              o.createElement(
                "div",
                { className: at.ConnectorID },
                d.connector_id(),
              ),
            ),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_ConditionalSwap"),
              ),
              o.createElement("div", { className: at.NodeID }, t.node_id()),
              s &&
                o.createElement("div", {
                  className: at.EditGear,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(At, { msgNode: t, msgWorkingProject: a }),
                      window,
                    ),
                }),
              s &&
                o.createElement("div", {
                  className: at.Delete,
                  onClick: () =>
                    (0, je.AM)(
                      o.createElement(rt.uH, {
                        strTitle: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_Node",
                        ),
                        strDescription: (0, l.Xx)(
                          "#SteamLearn_Config_Node_Delete_NodeDetails",
                        ),
                        onOK: () => oe(a, n, t.node_id()),
                      }),
                      window,
                    ),
                }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                t.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    t.comment(),
                  ),
              ),
            ),
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        At = (e) => {
          const [t, a] = o.useState(e.msgNode.comment());
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_ConditionalSwap"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)(
                  "#SteamLearn_Config_Node_Title_ConditionalSwapEditDesc",
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: t,
                  onChange: (e) => a(e.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () => (
                  e.msgNode.set_comment(t),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        It = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = (0, it.Z)(),
            _ = e.data.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()),
            d = e.data.msgNode
              .connectors()
              .filter((e) => !e.is_input_connector());
          return (
            o.useEffect(() => {
              setTimeout(() => {
                for (const e of n.project_nodes())
                  e.type() == v.scw.STEAMLEARN_NODE_TYPE_COMBINE &&
                    c(f(e.node_id()));
              }, 0.1);
            }, [n, c]),
            o.createElement(
              "div",
              { className: (0, i.Z)(at.FlowNode, at.CombineNode) },
              _.map((e, t) => {
                const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "target",
                    position: tt.P.Top,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
              o.createElement(
                "div",
                { className: at.Title },
                o.createElement(
                  "div",
                  { className: at.TitleText },
                  (0, l.Xx)("#SteamLearn_Config_Node_Title_Combine"),
                ),
                o.createElement("div", { className: at.NodeID }, t.node_id()),
                s &&
                  o.createElement("div", {
                    className: at.EditGear,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(Pt, {
                          msgNode: t,
                          msgWorkingProject: a,
                          msgWorkingProjectConfig: n,
                        }),
                        window,
                      ),
                  }),
                s &&
                  o.createElement("div", {
                    className: at.Delete,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(rt.uH, {
                          strTitle: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_Node",
                          ),
                          strDescription: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_NodeDetails",
                          ),
                          onOK: () => oe(a, n, t.node_id()),
                        }),
                        window,
                      ),
                  }),
              ),
              o.createElement("div", { className: at.TitleUnderBar }),
              o.createElement(
                "div",
                { className: at.Body },
                o.createElement(
                  "div",
                  { className: at.CenterSection },
                  t.comment().length > 0 &&
                    o.createElement(
                      "div",
                      { className: at.Comment },
                      t.comment(),
                    ),
                ),
              ),
              d.map((e, t) => {
                const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "source",
                    position: tt.P.Bottom,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
            )
          );
        },
        Pt = (e) => {
          const t = e.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()).length,
            [a, n] = o.useState(e.msgNode.comment()),
            [r, s] = o.useState(t.toString()),
            [c, _] = o.useState(!0),
            d = o.useCallback((e) => {
              _(le(e, 1, 7)), s(e);
            }, []);
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_Combine"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_CombineEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: a,
                  onChange: (e) => n(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Combine_NumInputs"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_Combine_NumInputsDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !c && at.Invalid),
                  value: r,
                  onChange: (e) => d(e.target.value),
                }),
              ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: !c,
                onOK: () =>
                  (() => {
                    const n = parseInt(r);
                    if (n > t) {
                      const a = n - t,
                        o = q(e.msgWorkingProjectConfig, a);
                      for (let t = 0; t < a; t++) {
                        let a = new v.UYo();
                        a.set_connector_id(o[t]),
                          a.set_is_input_connector(!0),
                          e.msgNode.add_connectors(a);
                      }
                    } else if (n < t) {
                      const t = e.msgNode
                        .connectors()
                        .filter((e) => e.is_input_connector())
                        .slice(n)
                        .map((e) => e.connector_id());
                      for (let a of e.msgWorkingProjectConfig.project_nodes())
                        for (let e of a.connectors())
                          e.set_linked_connector_ids(
                            e
                              .linked_connector_ids()
                              .filter((e) => !t.includes(e)),
                          );
                      e.msgNode.set_connectors([
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector()),
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(0, n),
                      ]);
                    }
                    e.msgNode.set_comment(a),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        Ot = (e) => {
          var t;
          const a = e.data.msgNode,
            {
              msgWorkingProject: n,
              msgWorkingProjectConfig: r,
              nPublishedVersion: s,
            } = Xe(),
            c = (0, it.Z)(),
            _ = a.connectors().filter((e) => e.is_input_connector()),
            d = a.connectors().filter((e) => !e.is_input_connector()),
            m = d.filter((e, t) => t % 2 == 0),
            u = d.filter((e, t) => t % 2 == 1);
          o.useEffect(() => {
            setTimeout(() => {
              for (const e of r.project_nodes())
                e.type() == v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_EXTRACT &&
                  c(f(e.node_id()));
            }, 0.1);
          }, [r, c]);
          const E = Math.max(78, 20 * _.length);
          let p = "";
          switch (a.conditional_extract().extract_filter_type()) {
            case v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_RANDOM:
              p = (0, l.Xx)(
                "#SteamLearn_Config_Node_ConditionalExtract_FilterType_Random",
              );
              break;
            case v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID:
              p = (0, l.Xx)(
                "#SteamLearn_Config_Node_ConditionalExtract_FilterType_AppID",
              );
          }
          const S =
            a.conditional_extract().extract_filter_type() ==
            v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID;
          return o.createElement(
            "div",
            { className: (0, i.Z)(at.FlowNode, at.OnehotNode) },
            _.map((e, t) => {
              const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "target",
                  position: tt.P.Top,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            o.createElement(
              "div",
              { className: at.Title },
              o.createElement(
                "div",
                { className: at.TitleText },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_ConditionalExtract"),
              ),
              o.createElement("div", { className: at.NodeID }, a.node_id()),
              o.createElement("div", {
                className: at.EditGear,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(xt, {
                      msgNode: a,
                      msgWorkingProject: n,
                      msgWorkingProjectConfig: r,
                    }),
                    window,
                  ),
              }),
              o.createElement("div", {
                className: at.Delete,
                onClick: () =>
                  (0, je.AM)(
                    o.createElement(rt.uH, {
                      strTitle: (0, l.Xx)(
                        "#SteamLearn_Config_Node_Delete_Node",
                      ),
                      strDescription: (0, l.Xx)(
                        "#SteamLearn_Config_Node_Delete_NodeDetails",
                      ),
                      onOK: () => oe(n, r, a.node_id()),
                    }),
                    window,
                  ),
              }),
            ),
            o.createElement("div", { className: at.TitleUnderBar }),
            o.createElement(
              "div",
              { className: at.Body },
              o.createElement(
                "div",
                { className: at.CenterSection },
                a.comment().length > 0 &&
                  o.createElement(
                    "div",
                    { className: at.Comment },
                    a.comment(),
                  ),
                o.createElement(
                  "div",
                  { className: at.LabelValue },
                  o.createElement(
                    "div",
                    { className: at.Label },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_FilterType",
                    ),
                  ),
                  o.createElement("div", { className: at.Value }, p),
                ),
                S &&
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)(
                        "#SteamLearn_Config_Node_ConditionalExtract_AppID_Age",
                      ),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      a
                        .conditional_extract()
                        .filter_info()
                        .appid_release_recency_months(),
                    ),
                  ),
                S &&
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)(
                        "#SteamLearn_Config_Node_ConditionalExtract_AppID_BiasFactor",
                      ),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      (null ===
                        (t = a
                          .conditional_extract()
                          .weight_info()
                          .appid_release_recency_bias()) || void 0 === t
                        ? void 0
                        : t.toFixed(2)) || "0",
                    ),
                  ),
                S &&
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)(
                        "#SteamLearn_Config_Node_ConditionalExtract_AppID_CompactTable",
                      ),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      a.conditional_extract().compact_table(),
                    ),
                  ),
                S &&
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)(
                        "#SteamLearn_Config_Node_ConditionalExtract_AppID_ExtractedCompactTable",
                      ),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      a.conditional_extract().extracted_compact_table(),
                    ),
                  ),
              ),
            ),
            m.map((e, t) => {
              const a = Math.floor(((t + 1) / (m.length + 1)) * 200),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Bottom,
                  id: n,
                  style: { left: a },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
            u.map((e, t) => {
              const a = Math.floor(((t + 1) / (u.length + 1)) * (E - 24)),
                n = L(e.connector_id());
              return o.createElement(
                et.HH,
                {
                  key: n,
                  type: "source",
                  position: tt.P.Right,
                  id: n,
                  style: { top: a + 24 },
                },
                o.createElement(
                  "div",
                  { className: at.ConnectorID },
                  e.connector_id(),
                ),
              );
            }),
          );
        },
        xt = (e) => {
          var t, a, n, r;
          const s = e.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()).length,
            [c, _] = o.useState(e.msgNode.comment()),
            [d, m] = o.useState(s.toString()),
            [u, E] = o.useState(!0),
            [p, S] = o.useState(
              e.msgNode.conditional_extract().extract_filter_type(),
            ),
            [N, g] = o.useState(
              e.msgNode.conditional_extract().extract_weight_type(),
            ),
            [T, L] = o.useState(
              (null ===
                (t = e.msgNode
                  .conditional_extract()
                  .filter_info()
                  .appid_release_recency_months()) || void 0 === t
                ? void 0
                : t.toString()) || "0",
            ),
            [f, h] = o.useState(!0),
            [D, C] = o.useState(
              (null ===
                (a = e.msgNode
                  .conditional_extract()
                  .weight_info()
                  .appid_release_recency_bias()) || void 0 === a
                ? void 0
                : a.toFixed(2)) || "0",
            ),
            [A, I] = o.useState(!0),
            [P, O] = o.useState(
              (null ===
                (n = e.msgNode
                  .conditional_extract()
                  .weight_info()
                  .input_number()) || void 0 === n
                ? void 0
                : n.toFixed(0)) || "1",
            ),
            [x, j] = o.useState(!0),
            [b, y] = o.useState(
              (null ===
                (r = e.msgNode
                  .conditional_extract()
                  .weight_info()
                  .input_strength()) || void 0 === r
                ? void 0
                : r.toFixed(2)) || "1.00",
            ),
            [R, k] = o.useState(!0),
            [M, X] = o.useState(
              e.msgNode.conditional_extract().compact_table(),
            ),
            [B, w] = o.useState(!0),
            [W, V] = o.useState(
              e.msgNode.conditional_extract().extracted_compact_table(),
            ),
            [H, F] = o.useState(!0),
            G = o.useCallback((e) => {
              E(le(e, 1, 5)), m(e);
            }, []);
          let U = [
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_ConditionalExtract_FilterType_All",
                ),
                value: v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_ALL,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_ConditionalExtract_FilterType_Random",
                ),
                value: v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_RANDOM,
              },
              {
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_ConditionalExtract_FilterType_AppID",
                ),
                value: v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID,
              },
            ],
            Y = [];
          switch (p) {
            case v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_ALL:
              Y.push({
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_ConditionalExtract_WeightType_Input",
                ),
                value: v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INPUT,
              });
              break;
            case v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID:
              Y.push({
                label: (0, l.Xx)(
                  "#SteamLearn_Config_Node_ConditionalExtract_WeightType_Input",
                ),
                value: v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INPUT,
              }),
                Y.push({
                  label: (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_WeightType_AppIDRecency",
                  ),
                  value:
                    v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_APPID_RECENCY,
                });
          }
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_ConditionalExtract"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)(
                  "#SteamLearn_Config_Node_Title_ConditionalExtractEditDesc",
                ),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: c,
                  onChange: (e) => _(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_NumInputs",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_NumInputsDesc",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, !u && at.Invalid),
                  value: d,
                  onChange: (e) => G(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_FilterType",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_FilterTypeDesc",
                  ),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: p,
                    onChange: (e) => S(parseInt(e.target.value)),
                  },
                  U.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_RANDOM &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_FilterTypeDescSub1",
                    ),
                  ),
                p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_FilterTypeDescSub2",
                    ),
                  ),
                p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_ALL &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_FilterTypeDescSub6",
                    ),
                  ),
              ),
              p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_Age",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_AgeDesc",
                    ),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(at.OptionInput, !f && at.Invalid),
                    value: T,
                    onChange: (e) => {
                      return (t = e.target.value), h(le(t, 0, 360)), void L(t);
                      var t;
                    },
                  }),
                ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_WeightType",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_ConditionalExtract_WeightTypeDesc",
                  ),
                ),
                o.createElement(
                  "select",
                  {
                    className: at.InputSelect,
                    value: N,
                    onChange: (e) => g(parseInt(e.target.value)),
                  },
                  Y.map((e) =>
                    o.createElement(
                      "option",
                      { key: e.value, value: e.value },
                      e.label,
                    ),
                  ),
                ),
                N == v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_APPID_RECENCY &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_WeightTypeDescSub2",
                    ),
                  ),
                N == v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INPUT &&
                  o.createElement(
                    "div",
                    { className: at.OptionDescSub },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_WeightTypeDescSub3",
                    ),
                  ),
              ),
              N == v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_APPID_RECENCY &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_BiasFactor",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_BiasFactorDesc",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(at.OptionInput, !A && at.Invalid),
                      value: D,
                      onChange: (e) => {
                        return (t = e.target.value), I(_e(t, 0, 1)), void C(t);
                        var t;
                      },
                    }),
                  ),
                ),
              N == v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INPUT &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_Input",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_InputDesc",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(at.OptionInput, !x && at.Invalid),
                      value: P,
                      onChange: (t) =>
                        ((t) => {
                          const a = e.msgNode
                            .connectors()
                            .filter((e) => e.is_input_connector());
                          j(le(t, 1, a.length - 1)), O(t);
                        })(t.target.value),
                    }),
                  ),
                ),
              N == v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INPUT &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_InputStr",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_InputStrDesc",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(at.OptionInput, !R && at.Invalid),
                      value: b,
                      onChange: (e) => {
                        return (t = e.target.value), k(_e(t, 0, 20)), void y(t);
                        var t;
                      },
                    }),
                  ),
                ),
              p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_CompactTable",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_CompactTableDesc",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(at.OptionInput, !B && at.Invalid),
                      value: M,
                      onChange: (t) => {
                        return (
                          (a = t.target.value),
                          w(de(e.msgWorkingProjectConfig, a)),
                          void X(a)
                        );
                        var a;
                      },
                    }),
                  ),
                ),
              p == v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_APPID &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_ExtractedCompactTable",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_ConditionalExtract_AppID_ExtractedCompactTableDesc",
                    ),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(at.OptionInput, !H && at.Invalid),
                      value: W,
                      onChange: (t) => {
                        return (
                          (a = t.target.value),
                          F(!de(e.msgWorkingProjectConfig, a)),
                          void V(a)
                        );
                        var a;
                      },
                    }),
                  ),
                ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                onOK: () =>
                  (() => {
                    const t = parseInt(d);
                    if (t > s) {
                      const a = 3 * (t - s),
                        n = q(e.msgWorkingProjectConfig, a);
                      for (let t = 0; t < a; t++) {
                        const a = t % 3 != 0;
                        let o = new v.UYo();
                        o.set_connector_id(n[t]),
                          o.set_is_input_connector(!a),
                          e.msgNode.add_connectors(o);
                      }
                    } else if (t < s) {
                      let a = e.msgNode
                        .connectors()
                        .filter((e) => e.is_input_connector())
                        .slice(t)
                        .map((e) => e.connector_id());
                      a.push(
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector())
                          .slice(2 * t)
                          .map((e) => e.connector_id()),
                      );
                      for (let t of e.msgWorkingProjectConfig.project_nodes())
                        for (let e of t.connectors())
                          e.set_linked_connector_ids(
                            e
                              .linked_connector_ids()
                              .filter((e) => !a.includes(e)),
                          );
                      e.msgNode.set_connectors([
                        ...e.msgNode
                          .connectors()
                          .filter((e) => !e.is_input_connector())
                          .slice(0, 2 * t),
                        ...e.msgNode
                          .connectors()
                          .filter((e) => e.is_input_connector())
                          .slice(0, t),
                      ]);
                    }
                    e.msgNode.set_comment(c),
                      e.msgNode
                        .conditional_extract()
                        .set_extract_filter_type(p),
                      e.msgNode
                        .conditional_extract()
                        .set_extract_weight_type(N),
                      e.msgNode
                        .conditional_extract()
                        .filter_info()
                        .set_appid_release_recency_months(parseInt(T)),
                      e.msgNode
                        .conditional_extract()
                        .weight_info()
                        .set_appid_release_recency_bias(parseFloat(D)),
                      e.msgNode
                        .conditional_extract()
                        .weight_info()
                        .set_input_number(parseInt(P)),
                      e.msgNode
                        .conditional_extract()
                        .weight_info()
                        .set_input_strength(parseFloat(b)),
                      e.msgNode.conditional_extract().set_compact_table(M),
                      e.msgNode
                        .conditional_extract()
                        .set_extracted_compact_table(W),
                      se(e.msgWorkingProject),
                      e.closeModal();
                  })(),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        jt = (e) => {
          const t = e.data.msgNode,
            {
              msgWorkingProject: a,
              msgWorkingProjectConfig: n,
              nPublishedVersion: r,
            } = Xe(),
            s = 0 == r,
            c = (0, it.Z)(),
            _ = e.data.msgNode
              .connectors()
              .filter((e) => e.is_input_connector()),
            d = e.data.msgNode
              .connectors()
              .filter((e) => !e.is_input_connector());
          return (
            o.useEffect(() => {
              setTimeout(() => {
                for (const e of n.project_nodes())
                  e.type() == v.scw.STEAMLEARN_NODE_TYPE_KMEANS &&
                    c(f(e.node_id()));
              }, 0.1);
            }, [n, c]),
            o.createElement(
              "div",
              { className: (0, i.Z)(at.FlowNode, at.KMeansNode) },
              _.map((e, t) => {
                const a = Math.floor(((t + 1) / (_.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "target",
                    position: tt.P.Top,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
              o.createElement(
                "div",
                { className: at.Title },
                o.createElement(
                  "div",
                  { className: at.TitleText },
                  (0, l.Xx)("#SteamLearn_Config_Node_Title_KMeans"),
                ),
                o.createElement("div", { className: at.NodeID }, t.node_id()),
                s &&
                  o.createElement("div", {
                    className: at.EditGear,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(bt, {
                          msgNode: t,
                          msgWorkingProject: a,
                          msgWorkingProjectConfig: n,
                        }),
                        window,
                      ),
                  }),
                s &&
                  o.createElement("div", {
                    className: at.Delete,
                    onClick: () =>
                      (0, je.AM)(
                        o.createElement(rt.uH, {
                          strTitle: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_Node",
                          ),
                          strDescription: (0, l.Xx)(
                            "#SteamLearn_Config_Node_Delete_NodeDetails",
                          ),
                          onOK: () => oe(a, n, t.node_id()),
                        }),
                        window,
                      ),
                  }),
              ),
              o.createElement("div", { className: at.TitleUnderBar }),
              o.createElement(
                "div",
                { className: at.Body },
                o.createElement(
                  "div",
                  { className: at.CenterSection },
                  t.comment().length > 0 &&
                    o.createElement(
                      "div",
                      { className: at.Comment },
                      t.comment(),
                    ),
                  t.kmeans().generate_clusters() &&
                    o.createElement(
                      "div",
                      { className: at.LabelValue },
                      o.createElement(
                        "div",
                        { className: at.Label },
                        (0, l.Xx)("#SteamLearn_Config_Node_KMeans_NumClusters"),
                      ),
                      o.createElement(
                        "div",
                        { className: at.Value },
                        t.kmeans().num_clusters(),
                      ),
                    ),
                  o.createElement(
                    "div",
                    { className: at.LabelValue },
                    o.createElement(
                      "div",
                      { className: at.Label },
                      (0, l.Xx)("#SteamLearn_Config_Node_KMeans_Name"),
                    ),
                    o.createElement(
                      "div",
                      { className: at.Value },
                      t.kmeans().name(),
                    ),
                  ),
                ),
              ),
              d.map((e, t) => {
                const a = Math.floor(((t + 1) / (d.length + 1)) * 200),
                  n = L(e.connector_id());
                return o.createElement(
                  et.HH,
                  {
                    key: n,
                    type: "source",
                    position: tt.P.Bottom,
                    id: n,
                    style: { left: a },
                  },
                  o.createElement(
                    "div",
                    { className: at.ConnectorID },
                    e.connector_id(),
                  ),
                );
              }),
            )
          );
        },
        bt = (e) => {
          var t, a, n;
          e.msgNode.connectors().filter((e) => e.is_input_connector()).length;
          const [r, s] = o.useState(e.msgNode.comment()),
            [c, _] = o.useState(
              (null === (t = e.msgNode.kmeans()) || void 0 === t
                ? void 0
                : t.num_clusters().toString()) || "0",
            ),
            [d, m] = o.useState(!0),
            [u, E] = o.useState(
              null === (a = e.msgNode.kmeans()) || void 0 === a
                ? void 0
                : a.generate_clusters(),
            ),
            [p, S] = o.useState(
              (null === (n = e.msgNode.kmeans()) || void 0 === n
                ? void 0
                : n.name()) || "",
            ),
            N = o.useCallback((e) => {
              m(le(e, 1, 1e4)), _(e);
            }, []);
          return o.createElement(
            be.R,
            null,
            o.createElement(
              xe.h4,
              null,
              (0, l.Xx)("#SteamLearn_Config_Node_Title_KMeans"),
              o.createElement(
                "div",
                { className: at.SubHeader },
                (0, l.Xx)("#SteamLearn_Config_Node_Title_KMeansEditDesc"),
              ),
            ),
            o.createElement(
              "div",
              { className: at.EditOptions },
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_Comment"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_CommentDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(at.OptionInput, at.VeryWide),
                  value: r,
                  onChange: (e) => s(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_KMeans_Name"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)("#SteamLearn_Config_Node_KMeans_NameDesc"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: at.OptionInput,
                  value: p,
                  onChange: (e) => S(e.target.value),
                }),
              ),
              o.createElement(
                "div",
                { className: at.Option },
                o.createElement(
                  "div",
                  { className: at.OptionTitle },
                  (0, l.Xx)("#SteamLearn_Config_Node_KMeans_GenerateClusters"),
                ),
                o.createElement(
                  "div",
                  { className: at.OptionDesc },
                  (0, l.Xx)(
                    "#SteamLearn_Config_Node_KMeans_GenerateClustersDesc",
                  ),
                ),
                o.createElement(
                  "div",
                  { className: at.CheckboxWithLabel },
                  o.createElement("input", {
                    type: "checkbox",
                    id: "editflatten",
                    checked: u,
                    onChange: () => E(!u),
                  }),
                  o.createElement(
                    "label",
                    { htmlFor: "editflatten" },
                    (0, l.Xx)(
                      "#SteamLearn_Config_Node_KMeans_GenerateClusters",
                    ),
                  ),
                ),
              ),
              u &&
                o.createElement(
                  "div",
                  { className: at.Option },
                  o.createElement(
                    "div",
                    { className: at.OptionTitle },
                    (0, l.Xx)("#SteamLearn_Config_Node_KMeans_NumClusters"),
                  ),
                  o.createElement(
                    "div",
                    { className: at.OptionDesc },
                    (0, l.Xx)("#SteamLearn_Config_Node_KMeans_NumClustersDesc"),
                  ),
                  o.createElement("input", {
                    type: "text",
                    className: (0, i.Z)(at.OptionInput, !d && at.Invalid),
                    value: c,
                    onChange: (e) => N(e.target.value),
                  }),
                ),
            ),
            o.createElement(
              "div",
              { className: at.ButtonsContainer },
              o.createElement(xe.o9, {
                bOKDisabled: 0 == p.length,
                onOK: () => (
                  e.msgNode.set_comment(r),
                  e.msgNode.kmeans().set_num_clusters(parseInt(c)),
                  e.msgNode.kmeans().set_name(p),
                  e.msgNode.kmeans().set_generate_clusters(u),
                  se(e.msgWorkingProject),
                  void e.closeModal()
                ),
                onCancel: () => e.closeModal(),
              }),
            ),
          );
        },
        yt = () => {
          const { nProjectID: e } = Xe();
          return o.createElement(
            "div",
            { className: qe.ProjectModelPage },
            o.createElement(Ue, { nProjectID: e }),
            o.createElement(Rt, null),
          );
        },
        Rt = () => {
          const e = o.useRef(null),
            [t, a] = o.useState(null),
            {
              msgWorkingProject: n,
              msgWorkingProjectConfig: r,
              nPublishedVersion: s,
            } = Xe(),
            [c, l] = Mt(r),
            [_, d, m] = (0, et.Rr)(c),
            [u, p, S] = (0, et.ll)(l),
            [N, g] = o.useState(null),
            [T, L] = o.useState(!1),
            f = 0 == s,
            C = o.useMemo(
              () => ({
                nodeInput: nt,
                nodeDenseStack: pt,
                nodeDense: ut,
                nodeConcat: lt,
                nodeCombine: It,
                nodeEmbedding: st,
                nodeTrain: dt,
                nodeShuffle: Nt,
                nodeSyncedShuffle: vt,
                nodeOnehot: Lt,
                nodeExplode: ht,
                nodeConditionalSwap: Ct,
                nodeConditionalExtract: Ot,
                nodeKMeans: jt,
              }),
              [],
            );
          o.useEffect(() => {
            const [e, t] = Mt(r);
            d(e), p(t);
          }, [n, r, d, p]);
          const A = o.useCallback((e, t) => {
              e.dataTransfer.setData("application/reactflow", t),
                (e.dataTransfer.effectAllowed = "move");
            }, []),
            I = o.useCallback((e) => {
              e.preventDefault(), (e.dataTransfer.dropEffect = "move");
            }, []),
            P = o.useCallback(
              (a) => {
                a.preventDefault();
                const o = e.current.getBoundingClientRect(),
                  s = parseInt(a.dataTransfer.getData("application/reactflow"));
                if (void 0 === s || !s) return;
                const c = t.project({
                  x: a.clientX - o.left,
                  y: a.clientY - o.top,
                });
                !(function (e, t, a, n, o) {
                  let r = new v._ur();
                  r.set_node_id(J(t)),
                    r.set_location_x(Math.floor(n)),
                    r.set_location_y(Math.floor(o)),
                    r.set_type(a),
                    r.set_comment("");
                  let s = 0,
                    c = 0;
                  switch (a) {
                    case v.scw.STEAMLEARN_NODE_TYPE_INPUT:
                    case v.scw.STEAMLEARN_NODE_TYPE_TRAIN:
                      return;
                    case v.scw.STEAMLEARN_NODE_TYPE_CONCATENATE:
                    case v.scw.STEAMLEARN_NODE_TYPE_COMBINE:
                      (s = 2), (c = 1);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_DENSE:
                      (s = 1),
                        (c = 1),
                        r.dense().set_width(128),
                        r
                          .dense()
                          .set_activation(
                            v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU,
                          );
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_DENSE_STACK:
                      (s = 1),
                        (c = 1),
                        r.dense_stack().set_width([128, 64]),
                        r.dense_stack().set_dropout_pct(30),
                        r
                          .dense_stack()
                          .set_activation(
                            v.uBn.STEAMLEARN_DENSE_ACTIVATION_RELU,
                          );
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_EMBEDDING:
                      (s = 1),
                        (c = 1),
                        r.embedding().set_max_value(100),
                        r.embedding().set_compact_table(""),
                        r.embedding().set_embedding_width(8),
                        r.embedding().set_flatten(!0);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_SHUFFLE:
                      (s = 1), (c = 1), r.shuffle().set_exclude_zeroes(!1);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE:
                      (s = 2),
                        (c = 2),
                        r.synced_shuffle().set_exclude_zeroes(!1);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_ONEHOT:
                      (s = 1),
                        (c = 1),
                        r.onehot().set_width(16),
                        r.onehot().set_compact_table("");
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_EXPLODE:
                      (s = 1), (c = 0);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_SWAP:
                      (s = 3), (c = 2);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_EXTRACT:
                      (s = 1),
                        (c = 2),
                        r
                          .conditional_extract()
                          .set_extract_filter_type(
                            v.__s.STEAMLEARN_NODE_EXTRACT_TYPE_RANDOM,
                          ),
                        r
                          .conditional_extract()
                          .set_extract_weight_type(
                            v.RyW.STEAMLEARN_NODE_EXTRACT_WEIGHT_TYPE_INVALID,
                          ),
                        r
                          .conditional_extract()
                          .filter_info()
                          .set_appid_release_recency_months(0),
                        r
                          .conditional_extract()
                          .filter_info()
                          .set_appid_publisher_id(0),
                        r
                          .conditional_extract()
                          .filter_info()
                          .set_appid_featured_tag_id(0),
                        r
                          .conditional_extract()
                          .filter_info()
                          .set_appid_theme_tag_id(0),
                        r
                          .conditional_extract()
                          .weight_info()
                          .set_appid_release_recency_bias(0),
                        r
                          .conditional_extract()
                          .weight_info()
                          .set_input_number(0),
                        r
                          .conditional_extract()
                          .weight_info()
                          .set_input_strength(0);
                      break;
                    case v.scw.STEAMLEARN_NODE_TYPE_KMEANS:
                      (s = 1),
                        (c = 1),
                        r.kmeans().set_num_clusters(10),
                        r.kmeans().set_name(""),
                        r.kmeans().set_generate_clusters(!1);
                      break;
                    default:
                      (0, E.X)(!1, `Unhandled type in AddNodeToConfig: ${a}`);
                  }
                  const i = q(t, s + c);
                  if (s > 0)
                    for (let e = 0; e < s; e++) {
                      let t = new v.UYo();
                      t.set_connector_id(i[e]),
                        t.set_is_input_connector(!0),
                        r.add_connectors(t);
                    }
                  if (c > 0)
                    for (let e = 0; e < c; e++) {
                      let t = new v.UYo();
                      t.set_connector_id(i[s + e]),
                        t.set_is_input_connector(!1),
                        r.add_connectors(t);
                    }
                  t.add_project_nodes(r), se(e);
                })(n, r, s, c.x, c.y);
              },
              [t, n, r],
            ),
            O = o.useCallback(
              (e) => {
                m(e);
              },
              [m],
            ),
            x = o.useCallback(
              (e, t, a) => {
                const o = D(t.id);
                let s = r.project_nodes().find((e) => e.node_id() == o);
                s &&
                  (s.set_location_x(Math.floor(t.position.x)),
                  s.set_location_y(Math.floor(t.position.y)),
                  se(n));
              },
              [n, r],
            ),
            j = o.useCallback(
              (e) => {
                S(e);
              },
              [S],
            ),
            b = o.useCallback(() => {
              g(null);
            }, []),
            y = o.useCallback(
              (e, t) => {
                const a = D(t.source),
                  o = h(t.sourceHandle),
                  s = D(t.target),
                  c = h(t.targetHandle);
                te(n, r, a, o, s, c);
              },
              [n, r],
            ),
            R = o.useCallback(
              (e, t) => {
                const a = D(t.source),
                  o = h(t.sourceHandle),
                  s = D(t.target),
                  c = h(t.targetHandle);
                !(function (e, t, a, n, o, r) {
                  let s = t.project_nodes().find((e) => e.node_id() == a),
                    c = t.project_nodes().find((e) => e.node_id() == o);
                  if (
                    ((0, E.X)(
                      s,
                      `RemoveEdgeFromConfig: Failed to find source node: ${a}`,
                    ),
                    (0, E.X)(
                      c,
                      `RemoveEdgeFromConfig: Failed to find target node: ${o}`,
                    ),
                    !s || !c)
                  )
                    return;
                  let i = s.connectors().find((e) => e.connector_id() == n),
                    l = c.connectors().find((e) => e.connector_id() == r);
                  (0, E.X)(
                    i,
                    `RemoveEdgeFromConfig: Failed to find source connector: ${a}, ${n}`,
                  ),
                    (0, E.X)(
                      l,
                      `RemoveEdgeFromConfig: Failed to find target connector: ${o}, ${r}`,
                    ),
                    (0, E.X)(
                      i.linked_connector_ids().includes(r),
                      `RemoveEdgeFromConfig: Failed to find target connector in source linked connectors: ${r}`,
                    ),
                    i.set_linked_connector_ids(
                      i.linked_connector_ids().filter((e) => e != r),
                    ),
                    se(e);
                })(n, r, a, o, s, c);
              },
              [n, r],
            ),
            k = o.useCallback(
              (e) => {
                const t = D(e.source),
                  a = h(e.sourceHandle),
                  o = D(e.target),
                  s = h(e.targetHandle);
                te(n, r, t, a, o, s);
              },
              [r, n],
            );
          return o.createElement(
            "div",
            { className: qe.ProjectModelReactFlow },
            o.createElement(
              et.tV,
              null,
              o.createElement(
                "div",
                {
                  className: (0, i.Z)(qe.ReactFlowWrapper, T && "DebugEnabled"),
                  ref: e,
                },
                o.createElement(
                  "div",
                  { className: qe.DragSourcePanel },
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragConcat),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_CONCATENATE),
                      draggable: !0,
                    },
                    "Concat Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragCombine),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_COMBINE),
                      draggable: !0,
                    },
                    "Combine Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragEmbedding),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_EMBEDDING),
                      draggable: !0,
                    },
                    "Embedding Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragDense),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_DENSE),
                      draggable: !0,
                    },
                    "Dense Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragDenseStack),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_DENSE_STACK),
                      draggable: !0,
                    },
                    "Dense Stack Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragShuffle),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_SHUFFLE),
                      draggable: !0,
                    },
                    "Shuffle Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragSyncedShuffle),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE),
                      draggable: !0,
                    },
                    "Synced Shuffle Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragOnehot),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_ONEHOT),
                      draggable: !0,
                    },
                    "Onehot Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragExplode),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_EXPLODE),
                      draggable: !0,
                    },
                    "Explode Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        qe.DragSource,
                        qe.DragConditionalSwap,
                      ),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_SWAP),
                      draggable: !0,
                    },
                    "Conditional Swap Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        qe.DragSource,
                        qe.DragConditionalExtract,
                      ),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_EXTRACT),
                      draggable: !0,
                    },
                    "Conditional Extract Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DragSource, qe.DragKMeans),
                      onDragStart: (e) =>
                        A(e, v.scw.STEAMLEARN_NODE_TYPE_KMEANS),
                      draggable: !0,
                    },
                    "KMeans Node",
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(qe.DebugToggle, T && qe.Enabled),
                      onClick: () => L(!T),
                    },
                    "Debug",
                  ),
                ),
                o.createElement(et.ZP, {
                  nodeTypes: C,
                  nodes: _,
                  edges: u,
                  onNodesChange: O,
                  onEdgesChange: j,
                  onNodeDragStop: x,
                  onConnect: k,
                  onInit: a,
                  onDrop: P,
                  onDragOver: I,
                  onEdgeUpdate: y,
                  onEdgeUpdateStart: b,
                  onEdgeUpdateEnd: R,
                  nodesDraggable: f,
                  nodesConnectable: f,
                  snapToGrid: !0,
                  snapGrid: [5, 5],
                  fitView: !0,
                  fitViewOptions: { minZoom: 1, maxZoom: 1 },
                }),
              ),
            ),
          );
        };
      function kt(e) {
        switch (e) {
          case v.scw.STEAMLEARN_NODE_TYPE_CONCATENATE:
            return "nodeConcat";
          case v.scw.STEAMLEARN_NODE_TYPE_COMBINE:
            return "nodeCombine";
          case v.scw.STEAMLEARN_NODE_TYPE_DENSE:
            return "nodeDense";
          case v.scw.STEAMLEARN_NODE_TYPE_DENSE_STACK:
            return "nodeDenseStack";
          case v.scw.STEAMLEARN_NODE_TYPE_INPUT:
            return "nodeInput";
          case v.scw.STEAMLEARN_NODE_TYPE_EMBEDDING:
            return "nodeEmbedding";
          case v.scw.STEAMLEARN_NODE_TYPE_TRAIN:
            return "nodeTrain";
          case v.scw.STEAMLEARN_NODE_TYPE_SHUFFLE:
            return "nodeShuffle";
          case v.scw.STEAMLEARN_NODE_TYPE_SYNCED_SHUFFLE:
            return "nodeSyncedShuffle";
          case v.scw.STEAMLEARN_NODE_TYPE_ONEHOT:
            return "nodeOnehot";
          case v.scw.STEAMLEARN_NODE_TYPE_EXPLODE:
            return "nodeExplode";
          case v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_SWAP:
            return "nodeConditionalSwap";
          case v.scw.STEAMLEARN_NODE_TYPE_CONDITIONAL_EXTRACT:
            return "nodeConditionalExtract";
          case v.scw.STEAMLEARN_NODE_TYPE_KMEANS:
            return "nodeKMeans";
          default:
            (0, E.X)(!1, `Unknown type in GetNodeTypeString: ${e}`);
        }
        return "";
      }
      function Mt(e) {
        let t = [],
          a = [];
        for (const n of e.project_nodes()) {
          t.push({
            id: f(n.node_id()),
            type: kt(n.type()),
            position: { x: n.location_x(), y: n.location_y() },
            data: { msgNode: n },
          });
          for (const t of n.connectors())
            for (const o of t.linked_connector_ids()) {
              const r = e
                .project_nodes()
                .find(
                  (e) =>
                    null != e.connectors().find((e) => e.connector_id() == o),
                );
              r
                ? a.push({
                    id: C(t.connector_id(), o),
                    source: f(n.node_id()),
                    sourceHandle: L(t.connector_id()),
                    target: f(r.node_id()),
                    targetHandle: L(o),
                  })
                : console.error(
                    `Failed to find node ${n.node_id()} connector ${t.connector_id()} target ${o}`,
                  );
            }
        }
        return [t, a];
      }
      var Xt = a(69747);
      const Bt = () => {
        var e, t, a, n, r;
        const {
            msgWorkingProject: s,
            msgWorkingProjectConfig: c,
            nProjectID: _,
            nPublishedVersion: d,
          } = Xe(),
          [m, u] = o.useState(
            c.train_config().fetch_workers().toString() || "0",
          ),
          [E, p] = o.useState(!0),
          [S, N] = o.useState(
            (null === (e = c.train_config().fetch_chunk_size()) || void 0 === e
              ? void 0
              : e.toString()) || "0",
          ),
          [g, v] = o.useState(!0),
          [T, L] = o.useState(
            (null === (t = c.train_config().train_batch_size()) || void 0 === t
              ? void 0
              : t.toString()) || "0",
          ),
          [f, h] = o.useState(!0),
          [D, C] = o.useState(
            (null === (a = c.train_config().train_epoch_count()) || void 0 === a
              ? void 0
              : a.toString()) || "0",
          ),
          [A, I] = o.useState(!0),
          [P, O] = o.useState(
            (null ===
              (n = c.train_config().train_loss_improvement_threshold()) ||
            void 0 === n
              ? void 0
              : n.toFixed(5)) || "0.00000",
          ),
          [x, j] = o.useState(!0),
          [b, y] = o.useState(
            (null ===
              (r = c.train_config().train_no_loss_improvement_epoch_limit()) ||
            void 0 === r
              ? void 0
              : r.toString()) || "0",
          ),
          [R, k] = o.useState(!0),
          M = o.useCallback(
            (e) => {
              const t = le(e, 1, 128),
                a = parseInt(e);
              t &&
                a != c.train_config().fetch_workers() &&
                (c.train_config().set_fetch_workers(a), se(s)),
                p(t),
                u(e);
            },
            [s, c],
          ),
          X = o.useCallback(
            (e) => {
              const t = le(e, 100, 5e4),
                a = parseInt(e);
              t &&
                a != c.train_config().fetch_chunk_size() &&
                (c.train_config().set_fetch_chunk_size(a), se(s)),
                v(t),
                N(e);
            },
            [s, c],
          ),
          B = o.useCallback(
            (e) => {
              const t = le(e, 500, 1e4),
                a = parseInt(e);
              t &&
                a != c.train_config().train_batch_size() &&
                (c.train_config().set_train_batch_size(a), se(s)),
                h(t),
                L(e);
            },
            [s, c],
          ),
          w = o.useCallback(
            (e) => {
              const t = le(e, 1, 100),
                a = parseInt(e);
              t &&
                a != c.train_config().train_epoch_count() &&
                (c.train_config().set_train_epoch_count(a), se(s)),
                I(t),
                C(e);
            },
            [s, c],
          ),
          W = o.useCallback(
            (e) => {
              const t = _e(e, 0, 10),
                a = parseInt(e);
              t &&
                a != c.train_config().train_loss_improvement_threshold() &&
                (c.train_config().set_train_loss_improvement_threshold(a),
                se(s)),
                j(t),
                O(e);
            },
            [s, c],
          ),
          V = o.useCallback(
            (e) => {
              const t = le(e, 1, 5),
                a = parseInt(e);
              t &&
                a != c.train_config().train_no_loss_improvement_epoch_limit() &&
                (c.train_config().set_train_no_loss_improvement_epoch_limit(a),
                se(s)),
                k(t),
                y(e);
            },
            [s, c],
          );
        return (
          o.useEffect(() => {
            var e, t, a, n, o;
            M(c.train_config().fetch_workers().toString() || "0"),
              X(
                (null === (e = c.train_config().fetch_chunk_size()) ||
                void 0 === e
                  ? void 0
                  : e.toString()) || "0",
              ),
              B(
                (null === (t = c.train_config().train_batch_size()) ||
                void 0 === t
                  ? void 0
                  : t.toString()) || "0",
              ),
              w(
                (null === (a = c.train_config().train_epoch_count()) ||
                void 0 === a
                  ? void 0
                  : a.toString()) || "0",
              ),
              W(
                (null ===
                  (n = c.train_config().train_loss_improvement_threshold()) ||
                void 0 === n
                  ? void 0
                  : n.toFixed(5)) || "0.00000",
              ),
              V(
                (null ===
                  (o = c
                    .train_config()
                    .train_no_loss_improvement_epoch_limit()) || void 0 === o
                  ? void 0
                  : o.toString()) || "0",
              );
          }, [c, M, X, B, w, W, V]),
          o.createElement(
            "div",
            { className: Xt.ProjectTrainSettingsPage },
            o.createElement(Ue, { nProjectID: _ }),
            o.createElement(
              "div",
              { className: Xt.ProjectTrainSettingsBody },
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)("#SteamLearn_TrainSettings_FetchWorkers"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)("#SteamLearn_TrainSettings_FetchWorkersDesc"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_TrainSettings_FetchWorkersInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !E && Xt.Invalid),
                  value: m,
                  onChange: (e) => M(e.target.value),
                }),
              ),
              o.createElement("div", { className: Xt.Separator }),
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)("#SteamLearn_TrainSettings_FetchChunkSize"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)("#SteamLearn_TrainSettings_FetchChunkSizeDesc"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_TrainSettings_FetchChunkSizeInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !g && Xt.Invalid),
                  value: S,
                  onChange: (e) => X(e.target.value),
                }),
              ),
              o.createElement("div", { className: Xt.Separator }),
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)("#SteamLearn_TrainSettings_TrainBatchSize"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)("#SteamLearn_TrainSettings_TrainBatchSizeDesc"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_TrainSettings_TrainBatchSizeInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !f && Xt.Invalid),
                  value: T,
                  onChange: (e) => B(e.target.value),
                }),
              ),
              o.createElement("div", { className: Xt.Separator }),
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)("#SteamLearn_TrainSettings_TrainEpochCount"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)("#SteamLearn_TrainSettings_TrainEpochCountDesc"),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_TrainSettings_TrainEpochCountInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !A && Xt.Invalid),
                  value: D,
                  onChange: (e) => w(e.target.value),
                }),
              ),
              o.createElement("div", { className: Xt.Separator }),
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)(
                  "#SteamLearn_TrainSettings_TrainLossImprovementThreshold",
                ),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)(
                  "#SteamLearn_TrainSettings_TrainLossImprovementThresholdDesc",
                ),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)(
                    "#SteamLearn_TrainSettings_TrainLossImprovementThresholdInput",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !x && Xt.Invalid),
                  value: P,
                  onChange: (e) => W(e.target.value),
                }),
              ),
              o.createElement("div", { className: Xt.Separator }),
              o.createElement(
                "div",
                { className: Xt.OptionHeader },
                (0, l.Xx)(
                  "#SteamLearn_TrainSettings_TrainNoLossImprovementEpochLimit",
                ),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionDesc },
                (0, l.Xx)(
                  "#SteamLearn_TrainSettings_TrainNoLossImprovementEpochLimitDesc",
                ),
              ),
              o.createElement(
                "div",
                { className: Xt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Xt.OptionDetails },
                  (0, l.Xx)(
                    "#SteamLearn_TrainSettings_TrainNoLossImprovementEpochLimitInput",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Xt.ValueInput, !R && Xt.Invalid),
                  value: b,
                  onChange: (e) => V(e.target.value),
                }),
              ),
            ),
          )
        );
      };
      var wt = a(57112);
      const Wt = () => {
        var e, t;
        const {
            msgWorkingProject: a,
            msgWorkingProjectConfig: n,
            nProjectID: r,
            nPublishedVersion: s,
          } = Xe(),
          [c, _] = o.useState(
            (null ===
              (e = n.data_retention_config().snapshot_keep_duration_days()) ||
            void 0 === e
              ? void 0
              : e.toString()) || "0",
          ),
          [d, m] = o.useState(!0),
          [u, E] = o.useState(
            (null === (t = n.data_retention_config().fetch_keep_count()) ||
            void 0 === t
              ? void 0
              : t.toString()) || "0",
          ),
          [p, S] = o.useState(!0),
          N = o.useCallback(
            (e) => {
              const t = le(e, 1, 30),
                o = parseInt(e);
              t &&
                o != n.data_retention_config().snapshot_keep_duration_days() &&
                (n.data_retention_config().set_snapshot_keep_duration_days(o),
                se(a)),
                m(t),
                _(e);
            },
            [a, n],
          ),
          g = o.useCallback(
            (e) => {
              const t = le(e, 1, 20),
                o = parseInt(e);
              t &&
                o != n.data_retention_config().fetch_keep_count() &&
                (n.data_retention_config().set_fetch_keep_count(o), se(a)),
                S(t),
                E(e);
            },
            [a, n],
          );
        return (
          o.useEffect(() => {
            var e, t;
            N(
              (null ===
                (e = n.data_retention_config().snapshot_keep_duration_days()) ||
              void 0 === e
                ? void 0
                : e.toString()) || "0",
            ),
              g(
                (null === (t = n.data_retention_config().fetch_keep_count()) ||
                void 0 === t
                  ? void 0
                  : t.toString()) || "0",
              );
          }, [n, N, g]),
          o.createElement(
            "div",
            { className: wt.ProjectDataSettingsPage },
            o.createElement(Ue, { nProjectID: r }),
            o.createElement(
              "div",
              { className: wt.ProjectDataSettingsBody },
              o.createElement(
                "div",
                { className: wt.OptionHeader },
                (0, l.Xx)("#SteamLearn_DataSettings_SnapshotDuration"),
              ),
              o.createElement(
                "div",
                { className: wt.OptionDesc },
                (0, l.Xx)("#SteamLearn_DataSettings_SnapshotDurationDesc"),
              ),
              o.createElement(
                "div",
                { className: wt.OptionBlock },
                o.createElement(
                  "div",
                  { className: wt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_DataSettings_SnapshotDurationInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(wt.ValueInput, !d && wt.Invalid),
                  value: c,
                  onChange: (e) => N(e.target.value),
                }),
              ),
              o.createElement("div", { className: wt.Separator }),
              o.createElement(
                "div",
                { className: wt.OptionHeader },
                (0, l.Xx)("#SteamLearn_DataSettings_FetchKeepCount"),
              ),
              o.createElement(
                "div",
                { className: wt.OptionDesc },
                (0, l.Xx)("#SteamLearn_DataSettings_FetchKeepCountDesc"),
              ),
              o.createElement(
                "div",
                { className: wt.OptionBlock },
                o.createElement(
                  "div",
                  { className: wt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_DataSettings_FetchKeepCountInput"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(wt.ValueInput, !p && wt.Invalid),
                  value: u,
                  onChange: (e) => g(e.target.value),
                }),
              ),
            ),
          )
        );
      };
      var Vt = a(40503);
      const Ht = () => {
          const { nProjectID: e } = Xe();
          return o.createElement(
            "div",
            { className: Vt.ProjectManualTrainPage },
            o.createElement(Ue, { nProjectID: e }),
            o.createElement(Ft, null),
          );
        },
        Ft = () => {
          const {
              msgProject: e,
              msgWorkingProject: t,
              msgWorkingProjectConfig: a,
              nProjectID: n,
              nPublishedVersion: s,
            } = Xe(),
            [c, d] = o.useState(0),
            [m, u] = o.useState(0),
            E = G(n, s),
            S = U(n, s),
            T = (0, r.k6)(),
            L = E.data,
            f = S.data,
            h = E.isLoading || S.isLoading,
            D = s > 0,
            C =
              e && t && t.serializeBase64String() == e.serializeBase64String();
          return o.createElement(
            "div",
            { className: Vt.ProjectTrain },
            o.createElement(
              "div",
              { className: Vt.Heading },
              (0, l.Xx)("#SteamLearn_ManualTrain_Heading"),
            ),
            !h &&
              D &&
              o.createElement(
                "div",
                { className: Vt.Desc },
                (0, l.Xx)("#SteamLearn_ManualTrain_Desc"),
              ),
            h &&
              o.createElement(
                "div",
                { className: Vt.StatusMessage },
                (0, l.Xx)("#SteamLearn_ManualTrain_Loading"),
              ),
            !h &&
              !D &&
              o.createElement(
                "div",
                { className: Vt.StatusMessage },
                (0, l.Xx)("#SteamLearn_ManualTrain_Unpublished"),
              ),
            !h &&
              D &&
              o.createElement(
                "div",
                { className: Vt.FetchTrainOptionContainer },
                o.createElement(
                  "select",
                  {
                    className: Vt.TrainDropdown,
                    value: c,
                    onChange: (e) => d(parseInt(e.target.value)),
                  },
                  L.versions().map((e) =>
                    o.createElement(
                      "option",
                      { key: `Fetch_${e}`, value: e },
                      (0, l.Xx)("#SteamLearn_ManualTrain_FetchVersion", e),
                    ),
                  ),
                  o.createElement(
                    "option",
                    { key: "Fetch_0", value: 0 },
                    (0, l.Xx)("#SteamLearn_ManualTrain_FetchNew"),
                  ),
                ),
                o.createElement(
                  "select",
                  {
                    className: Vt.TrainDropdown,
                    value: m,
                    onChange: (e) => u(parseInt(e.target.value)),
                  },
                  f
                    .versions()
                    .map((e) =>
                      o.createElement(
                        "option",
                        { key: `Fetch_${e}`, value: e },
                        (0, l.Xx)("#SteamLearn_ManualTrain_TrainVersion", e),
                      ),
                    ),
                  o.createElement(
                    "option",
                    { key: "Fetch_0", value: 0 },
                    (0, l.Xx)("#SteamLearn_ManualTrain_TrainNew"),
                  ),
                ),
              ),
            !h &&
              C &&
              D &&
              o.createElement(
                "div",
                {
                  className: (0, i.Z)(Vt.SteamLearnButton, Vt.Blue),
                  onClick: () =>
                    (0, _.mG)(void 0, void 0, void 0, function* () {
                      let e = c;
                      if (0 == e) {
                        for (const a of t.published_configs())
                          e = Math.max(
                            e,
                            ...a.fetch_infos().map((e) => e.fetch_id()),
                          );
                        e += 1;
                      }
                      let o = m;
                      if (0 == o) {
                        for (const e of t.published_configs())
                          o = Math.max(
                            o,
                            ...e.train_infos().map((e) => e.train_id()),
                          );
                        o += 1;
                      }
                      let r = g.gA.Init(v.$GS);
                      r.Body().set_project_config(a),
                        r.Body().fetch().set_fetch_id(e),
                        r.Body().fetch().set_request_cancel(!1),
                        r.Body().train().set_train_id(o),
                        r.Body().train().set_request_cancel(!1);
                      const i = yield v.NG.Train(
                        p.Get().GetServiceTransport(),
                        r,
                      );
                      i.BIsValid() &&
                        i.GetEResult() == N.s.k_EResultOK &&
                        (z(t.project_id()),
                        T.push(_a.SteamLearnProjectTrainStatus(n, s, e, o)));
                    }),
                },
                (0, l.Xx)("#SteamLearn_ManualTrain_Start"),
              ),
            !C &&
              o.createElement(
                "div",
                { className: Vt.SaveWarning },
                (0, l.Xx)("#SteamLearn_ManualTrain_NeedSave"),
              ),
          );
        };
      var Gt = a(77845);
      const Ut = () => {
          const { nProjectID: e } = Xe();
          return o.createElement(
            "div",
            { className: Gt.ProjectManualTrainPage },
            o.createElement(Ue, { nProjectID: e }),
            o.createElement(Yt, null),
          );
        },
        Yt = () => {
          var e, t, a, n;
          const {
              msgWorkingProject: r,
              msgWorkingProjectConfig: s,
              nPublishedVersion: c,
            } = Xe(),
            [_, d] = o.useState(s.scheduled_train_config().scheduled_type()),
            [m, u] = o.useState(
              (null ===
                (e = s
                  .scheduled_train_config()
                  .auto_activate_accuracy_threshold()) || void 0 === e
                ? void 0
                : e.toFixed(2)) || "0.0",
            ),
            [E, p] = o.useState(!0),
            [S, N] = o.useState(
              (null === (t = s.scheduled_train_config().scheduled_minute()) ||
              void 0 === t
                ? void 0
                : t.toString()) || "0",
            ),
            [g, T] = o.useState(!0),
            [L, f] = o.useState(
              (null === (a = s.scheduled_train_config().scheduled_hour()) ||
              void 0 === a
                ? void 0
                : a.toString()) || "0",
            ),
            [h, D] = o.useState(!0),
            [C, A] = o.useState(
              s.scheduled_train_config().scheduled_day_of_week(),
            ),
            [I, P] = o.useState(
              (null ===
                (n = s.scheduled_train_config().scheduled_day_of_month()) ||
              void 0 === n
                ? void 0
                : n.toString()) || "0",
            ),
            [O, x] = o.useState(!0),
            j = o.useCallback(
              (e) => {
                s.scheduled_train_config().set_scheduled_type(e), se(r), d(e);
              },
              [r, s],
            ),
            b = o.useCallback(
              (e) => {
                const t = _e(e, 0, 1),
                  a = parseFloat(e);
                t &&
                  a !=
                    s
                      .scheduled_train_config()
                      .auto_activate_accuracy_threshold() &&
                  (s
                    .scheduled_train_config()
                    .set_auto_activate_accuracy_threshold(a),
                  se(r)),
                  p(t),
                  u(e);
              },
              [r, s],
            ),
            y = o.useCallback(
              (e) => {
                const t = le(e, 0, 60),
                  a = parseInt(e);
                t &&
                  a != s.scheduled_train_config().scheduled_minute() &&
                  (s.scheduled_train_config().set_scheduled_minute(a), se(r)),
                  T(t),
                  N(e);
              },
              [r, s],
            ),
            R = o.useCallback(
              (e) => {
                const t = le(e, 0, 24),
                  a = parseInt(e);
                t &&
                  a != s.scheduled_train_config().scheduled_hour() &&
                  (s.scheduled_train_config().set_scheduled_hour(a), se(r)),
                  D(t),
                  f(e);
              },
              [r, s],
            ),
            k = o.useCallback(
              (e) => {
                s.scheduled_train_config().set_scheduled_day_of_week(e),
                  se(r),
                  A(e);
              },
              [r, s],
            ),
            M = o.useCallback(
              (e) => {
                const t = le(e, 0, 31),
                  a = parseInt(e);
                t &&
                  a != s.scheduled_train_config().scheduled_day_of_month() &&
                  (s.scheduled_train_config().set_scheduled_day_of_month(a),
                  se(r)),
                  x(t),
                  P(e);
              },
              [r, s],
            ),
            X = _ != v.S35.STEAM_LEARN_SCHEDULED_TYPE_NONE,
            B =
              _ != v.S35.STEAM_LEARN_SCHEDULED_TYPE_NONE &&
              _ != v.S35.STEAM_LEARN_SCHEDULED_TYPE_HOURLY,
            w = _ == v.S35.STEAM_LEARN_SCHEDULED_TYPE_WEEKLY,
            W = _ == v.S35.STEAM_LEARN_SCHEDULED_TYPE_MONTHLY;
          return o.createElement(
            "div",
            { className: Gt.ProjectTrain },
            o.createElement(
              "div",
              { className: Gt.Heading },
              (0, l.Xx)("#SteamLearn_ScheduledTrain_Heading"),
            ),
            o.createElement(
              "select",
              {
                className: Gt.TrainDropdown,
                value: _,
                onChange: (e) => j(parseInt(e.target.value)),
              },
              o.createElement(
                "option",
                { key: "None", value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_NONE },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalNone"),
              ),
              o.createElement(
                "option",
                {
                  key: "Hourly",
                  value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_HOURLY,
                },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalHourly"),
              ),
              o.createElement(
                "option",
                { key: "Daily", value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_DAILY },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalDaily"),
              ),
              o.createElement(
                "option",
                {
                  key: "Weekly",
                  value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_WEEKLY,
                },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalWeekly"),
              ),
              o.createElement(
                "option",
                {
                  key: "Monthly",
                  value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_MONTHLY,
                },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalMonthly"),
              ),
            ),
            W &&
              o.createElement(
                "div",
                { className: Gt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Gt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfMonth"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Gt.ValueInput, !O && Gt.Invalid),
                  value: I,
                  onChange: (e) => M(e.target.value),
                }),
              ),
            w &&
              o.createElement(
                "div",
                { className: Gt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Gt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek"),
                ),
                o.createElement(
                  "select",
                  {
                    className: Gt.TrainDropdown,
                    value: C,
                    onChange: (e) => k(parseInt(e.target.value)),
                  },
                  o.createElement(
                    "option",
                    { key: "Sunday", value: 0 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Sunday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Monday", value: 1 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Monday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Tuesday", value: 2 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Tuesday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Wednesday", value: 3 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Wednesday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Thursday", value: 4 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Thursday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Friday", value: 5 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Friday"),
                  ),
                  o.createElement(
                    "option",
                    { key: "Saturday", value: 6 },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek_Saturday"),
                  ),
                ),
              ),
            B &&
              o.createElement(
                "div",
                { className: Gt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Gt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_ScheduledTrain_Hour"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Gt.ValueInput, !h && Gt.Invalid),
                  value: L,
                  onChange: (e) => R(e.target.value),
                }),
              ),
            X &&
              o.createElement(
                "div",
                { className: Gt.OptionBlock },
                o.createElement(
                  "div",
                  { className: Gt.OptionDetails },
                  (0, l.Xx)("#SteamLearn_ScheduledTrain_Minute"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(Gt.ValueInput, !g && Gt.Invalid),
                  value: S,
                  onChange: (e) => y(e.target.value),
                }),
              ),
            o.createElement(
              "div",
              { className: Gt.OptionBlock },
              o.createElement(
                "div",
                { className: Gt.OptionDetails },
                (0, l.Xx)("#SteamLearn_ScheduledTrain_ActivateThreshold"),
              ),
              o.createElement("input", {
                type: "text",
                className: (0, i.Z)(Gt.ValueInput, !E && Gt.Invalid),
                value: m,
                onChange: (e) => b(e.target.value),
              }),
            ),
          );
        };
      var $t = a(95424),
        Zt = a(23007),
        Kt = a(58104),
        zt = a(52339),
        Qt = a(81093);
      function Jt(e) {
        let t = "";
        return (
          e > 3600 && ((t += `${Math.floor(e / 3600)}:`), (e %= 3600)),
          (t += `${String(Math.floor(e / 60)).padStart(2, "0")}:`),
          (e %= 60),
          (t += `${String(Math.floor(e)).padStart(2, "0")}`),
          t
        );
      }
      function qt(e, t) {
        if (e.length < t) return e;
        let a = [];
        const n = (e.length - 1) / t;
        for (let t = 0; t + n < e.length; t += n) {
          const o = t + n,
            r = 1 - (t - Math.floor(t)),
            s = o - Math.floor(o);
          let c = 0;
          (c += r * e[Math.floor(t)]), (c += s * e[Math.floor(o)]);
          for (let a = Math.floor(t) + 1; a < Math.floor(o); a++) c += e[a];
          (c /= n), a.push(c);
        }
        return a;
      }
      const ea = (e) => {
          const { nPublishedVersion: t, msgWorkingProjectConfig: a } = Xe(),
            [n, r] = o.useState(!1),
            s = Y(e.nProjectID, e.nFetchID),
            [c, d] = o.useState("");
          o.useEffect(() => {
            const t = setInterval(() => {
              return (
                (t = e.nProjectID),
                (a = e.nFetchID),
                void T.U.invalidateQueries([j, t, a])
              );
              var t, a;
            }, 3e3);
            return () => clearInterval(t);
          }, [e.nProjectID, e.nFetchID]);
          if (0 == t)
            return o.createElement(
              "div",
              { className: Qt.StatusMessage },
              (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Unpublished"),
            );
          if (0 == e.arrAllFetchIDs.length)
            return o.createElement(
              "div",
              { className: Qt.StatusMessage },
              (0, l.Xx)("#SteamLearn_Status_Fetch_Status_None"),
            );
          const m = s.data;
          let u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Unknown"),
            E = Qt.Unknown;
          if (m)
            switch (m.status()) {
              case v.pw9.STEAMLEARN_FETCH_STATUS_UNKNOWN:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Unknown")),
                  (E = Qt.Unknown);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_UNSTARTED:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Unstarted")),
                  (E = Qt.Unstarted);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_METADATA:
                (u = (0, l.Xx)(
                  "#SteamLearn_Status_Fetch_Status_InProgress_Metadata",
                )),
                  (E = Qt.InProgress);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_DATA:
                (u = (0, l.Xx)(
                  "#SteamLearn_Status_Fetch_Status_InProgress_Data",
                )),
                  (E = Qt.InProgress);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_COMPLETE:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Complete")),
                  (E = Qt.Complete);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_ERROR:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Error")),
                  (E = Qt.Error);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_CLEANUP:
                (u = (0, l.Xx)(
                  "#SteamLearn_Status_Fetch_Status_InProgress_Cleanup",
                )),
                  (E = Qt.InProgress);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_CLEANED_UP:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_CleanedUp")),
                  (E = Qt.Complete);
                break;
              case v.pw9.STEAMLEARN_FETCH_STATUS_CANCELED:
                (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Canceled")),
                  (E = Qt.Error);
            }
          const S =
              m &&
              (m.status() ==
                v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_METADATA ||
                m.status() == v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_DATA ||
                m.status() ==
                  v.pw9.STEAMLEARN_FETCH_STATUS_IN_PROGRESS_CLEANUP),
            N = m && m.status() == v.pw9.STEAMLEARN_FETCH_STATUS_CANCELED;
          s.isLoading &&
            (u = (0, l.Xx)("#SteamLearn_Status_Fetch_Status_Loading"));
          let L = "";
          const f = m && m.total_rows() > 0;
          if (m && !N) {
            const e = m.total_rows_processed() / m.total_rows(),
              t = Date.now() / 1e3 - m.start_time(),
              a = t / e;
            if (m.end_time()) {
              const e = (0, l.Xx)(
                "#SteamLearn_Status_Train_Fetch_Duration",
                Jt(m.end_time() - m.start_time()),
              );
              e != c && d(e);
              const t = new Date(1e3 * m.end_time());
              L = (0, l.Xx)(
                "#SteamLearn_Status_Train_Fetch_Completed",
                t.getHours() +
                  ":" +
                  t.getMinutes().toString().padStart(2, "0") +
                  ":" +
                  t.getSeconds().toString().padStart(2, "0") +
                  ", " +
                  t.toDateString(),
              );
            } else {
              let e = a - t;
              if (!isNaN(e) && !s.isFetching) {
                const t = (0, l.Xx)(
                  "#SteamLearn_Status_Train_Fetch_TimeEstimate",
                  Jt(e),
                );
                t != c && d(t);
              }
              const n = new Date(1e3 * m.start_time());
              L = (0, l.Xx)(
                "#SteamLearn_Status_Train_Fetch_Started",
                n.getHours() +
                  ":" +
                  n.getMinutes().toString().padStart(2, "0") +
                  ":" +
                  n.getSeconds().toString().padStart(2, "0") +
                  ", " +
                  n.toDateString(),
              );
            }
          }
          return o.createElement(
            "div",
            { className: Qt.FetchStatusPanel },
            o.createElement(
              "div",
              { className: Qt.TopSection },
              o.createElement(
                "div",
                { className: Qt.TopLeft },
                o.createElement(
                  "div",
                  { className: Qt.OverallStatus },
                  (0, l.Xx)("#SteamLearn_Status_Fetch_Status", e.nFetchID),
                ),
                S &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(Qt.SteamLearnButton, Qt.Blue),
                      onClick: () => (
                        e.nFetchID,
                        (0, _.mG)(void 0, void 0, void 0, function* () {
                          let t = g.gA.Init(v.$GS);
                          t.Body().set_project_config(a),
                            t.Body().fetch().set_fetch_id(e.nFetchID),
                            t.Body().fetch().set_request_cancel(!0),
                            yield v.NG.Train(p.Get().GetServiceTransport(), t);
                        })
                      ),
                    },
                    (0, l.Xx)("#SteamLearn_Status_Fetch_Cancel"),
                  ),
                o.createElement(
                  "div",
                  { className: (0, i.Z)(Qt.StatusString, E) },
                  u,
                ),
              ),
              o.createElement(
                "div",
                { className: Qt.TopRight },
                o.createElement(
                  "select",
                  {
                    value: e.nFetchID,
                    onChange: (t) => e.fnSetFetchID(parseInt(t.target.value)),
                  },
                  e.arrAllFetchIDs.map((e) =>
                    o.createElement(
                      "option",
                      { key: `FetchOption_${e}`, value: e },
                      (0, l.Xx)("#SteamLearn_Status_Train_FetchOption", e),
                    ),
                  ),
                ),
              ),
            ),
            m &&
              m.total_rows() > 0 &&
              o.createElement(
                "div",
                { className: Qt.StatusProgress },
                o.createElement(
                  "div",
                  { className: Qt.RowProgress },
                  o.createElement(
                    "div",
                    { className: Qt.RowCurrent },
                    m.total_rows_processed().toLocaleString(),
                  ),
                  o.createElement("div", { className: Qt.RowSlash }, "/"),
                  o.createElement(
                    "div",
                    { className: Qt.RowTotal },
                    m.total_rows().toLocaleString(),
                  ),
                ),
                m.total_rows_written() != m.total_rows_processed() &&
                  o.createElement(
                    "div",
                    { className: Qt.RowProgress },
                    o.createElement(
                      "div",
                      { className: Qt.RowCurrent },
                      (0, l.Xx)(
                        "#SteamLearn_Status_Train_Fetch_Written",
                        m.total_rows_written().toLocaleString(),
                      ),
                    ),
                  ),
                o.createElement(
                  "div",
                  { className: Qt.RowProgress },
                  o.createElement(
                    "div",
                    { className: Qt.ProgressBar },
                    o.createElement("div", {
                      className: Qt.ProgressBarInner,
                      style: {
                        width:
                          (100 * m.total_rows_processed()) / m.total_rows() +
                          "%",
                      },
                    }),
                  ),
                  f &&
                    o.createElement(
                      "div",
                      { className: Qt.ProgressPct },
                      `${(
                        (100 * m.total_rows_processed()) / m.total_rows() -
                        0.5
                      ).toFixed(0)}%`,
                    ),
                ),
                o.createElement("div", { className: Qt.RowProgress }, c),
                o.createElement("div", { className: Qt.RowProgress }, L),
                o.createElement(
                  "div",
                  { className: Qt.ShowWorkers },
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        Qt.WorkersContainer,
                        n && Qt.Expanded,
                      ),
                      style: {
                        height: (n ? 20 * m.workers().length : 0) + "px",
                      },
                    },
                    m
                      .workers()
                      .map((e, t) =>
                        o.createElement(
                          "div",
                          { className: Qt.Worker, key: `$worker_${t}` },
                          o.createElement(
                            "div",
                            { className: Qt.WorkerNumber },
                            t + 1,
                          ),
                          o.createElement(
                            "div",
                            { className: Qt.ProgressBar },
                            o.createElement("div", {
                              className: Qt.ProgressBarInner,
                              style: {
                                width:
                                  (100 * e.rows_processed()) /
                                    (m.total_rows() / m.workers().length) +
                                  "%",
                              },
                            }),
                          ),
                        ),
                      ),
                  ),
                  f &&
                    o.createElement(
                      "div",
                      {
                        className: Qt.ShowWorkersTextButton,
                        onClick: () => r(!n),
                      },
                      (0, l.Xx)(
                        n
                          ? "#SteamLearn_Status_HideWorkers"
                          : "#SteamLearn_Status_ShowWorkers",
                      ),
                    ),
                ),
              ),
          );
        },
        ta = (e) => {
          let t, a, n, r;
          for (const t of e.lines) {
            const e = Math.min(...t.data.map((e) => e[t.strDataLabel])),
              a = Math.max(...t.data.map((e) => e[t.strDataLabel]));
            (n = Math.min(null == n ? e : n, e)),
              (r = Math.max(null == r ? a : r, a));
          }
          const s = Math.max(0, n - (r - n) * (e.fAxisPaddingPct / 100)),
            c = r + (r - n) * (e.fAxisPaddingPct / 100);
          return (
            (t = Math.floor(100 * s) / 100),
            (a = Math.ceil(100 * c) / 100),
            o.createElement(
              "div",
              { className: Qt.TrainGraph },
              o.createElement(
                "div",
                { className: Qt.GraphTitle },
                e.strHeading,
              ),
              o.createElement(
                "div",
                { className: Qt.LineValues },
                e.lines.map((e, t) =>
                  null == e.nFinalValue
                    ? null
                    : o.createElement(
                        "div",
                        {
                          key: `Legend_${e.strDataLabel}_${t}`,
                          className: Qt.LegendValue,
                          style: { color: e.color },
                        },
                        `${e.strDataLabel}: `,
                        o.createElement(
                          "span",
                          { className: Qt.Value },
                          "" + Math.round(1e4 * e.nFinalValue) / 1e4,
                        ),
                      ),
                ),
              ),
              o.createElement(
                $t.w,
                { width: 500, height: 300 },
                e.lines.map((t, a) =>
                  o.createElement(Zt.K, {
                    key: `${e.strHeading}_${t.strDataLabel}_${a}`,
                    type: "number",
                    dataKey: "index",
                    domain: t.XAxisDomain,
                    xAxisId: `${t.strDataLabel}_${a}`,
                    axisLine: 0 == a || t.bAxisLine,
                    tick: t.bAxisLine,
                    tickCount: t.data.length <= 10 ? t.data.length : void 0,
                  }),
                ),
                o.createElement(Kt.B, {
                  type: "number",
                  tickCount: 5,
                  domain: [t, a],
                }),
                e.lines.map((e, t) =>
                  o.createElement(zt.x, {
                    key: `${e.strDataLabel}_${t}`,
                    type: "monotone",
                    stroke: e.color,
                    dataKey: e.strDataLabel,
                    dot: e.data.length < 10,
                    xAxisId: `${e.strDataLabel}_${t}`,
                    data: e.data,
                  }),
                ),
              ),
            )
          );
        };
      function aa(e) {
        if (null != e)
          return e.length > 0 ? e.reduce((e, t) => e + t) / e.length : 0;
      }
      const na = (e) => {
          const {
              nPublishedVersion: t,
              msgProject: a,
              msgWorkingProjectConfig: n,
              msgWorkingProject: r,
            } = Xe(),
            s = $(e.nProjectID, e.nTrainID),
            [c, d] = o.useState(-1),
            [m, u] = o.useState("");
          o.useEffect(() => {
            -1 == c &&
              s.data &&
              (s.data.status() == v.Nce.STEAMLEARN_TRAIN_STATUS_COMPLETE
                ? d(0)
                : d(s.data.epochs().length));
          }, [s, d, c]),
            o.useEffect(() => {
              const t = setInterval(() => {
                return (
                  (t = e.nProjectID),
                  (a = e.nTrainID),
                  void T.U.invalidateQueries([b, t, a])
                );
                var t, a;
              }, 3e3);
              return () => clearInterval(t);
            }, [e.nProjectID, e.nTrainID]);
          const E = o.useCallback(
            (e) => {
              !(function (e, t, a) {
                (0, _.mG)(this, void 0, void 0, function* () {
                  let n = g.gA.Init(v.SjT);
                  n.Body().set_project_id(e),
                    n.Body().set_published_version(t),
                    n.Body().set_train_id(a);
                  const o = yield v.NG.SetTrainLive(
                    p.Get().GetServiceTransport(),
                    n,
                  );
                  return (
                    o &&
                      o.GetEResult() == N.s.k_EResultOK &&
                      T.U.invalidateQueries([b, e]),
                    o.Body().result()
                  );
                });
              })(n.project_id(), t, e);
            },
            [n, t],
          );
          if (0 == t)
            return o.createElement(
              "div",
              { className: Qt.StatusMessage },
              (0, l.Xx)("#SteamLearn_Status_Train_Status_Unpublished"),
            );
          const S = [...new Set(e.arrAllTrainIDs)];
          if (0 == S.length)
            return o.createElement(
              "div",
              { className: Qt.StatusMessage },
              (0, l.Xx)("#SteamLearn_Status_Train_Status_None"),
            );
          const L = s.data;
          let f,
            h,
            D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Unknown"),
            C = Qt.Unknown;
          if (L)
            switch (L.status()) {
              case v.Nce.STEAMLEARN_TRAIN_STATUS_UNKNOWN:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Unknown")),
                  (C = Qt.Unknown);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_UNSTARTED:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Unstarted")),
                  (C = Qt.Unstarted);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_IN_PROGRESS:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_InProgress")),
                  (C = Qt.InProgress);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_COMPLETE:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Complete")),
                  (C = Qt.Complete);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_ERROR:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Error")),
                  (C = Qt.Error);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_MANUAL_STOPPED_EARLY:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_StoppedEarly")),
                  (C = Qt.Complete);
                break;
              case v.Nce.STEAMLEARN_TRAIN_STATUS_WAITING_ON_AUTO_SNAPSHOT:
                (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_WaitingOnAS")),
                  (C = Qt.InProgress);
            }
          s.isLoading &&
            (D = (0, l.Xx)("#SteamLearn_Status_Train_Status_Loading"));
          let A = 0,
            I = 0,
            P = 0,
            O = 0;
          const x = 500;
          if (L)
            if (0 != c) {
              const e = c > L.epochs().length ? void 0 : L.epochs()[c - 1];
              if (e) {
                (A = e.train_batches().length),
                  (I = L.train_batch_count() / 100),
                  (P = e.validate_batches().length),
                  (O = L.validate_batch_count() / 100);
                const t = A / I,
                  a = P / O,
                  n = (A + P) / (I + O),
                  o = Date.now() / 1e3 - e.start_time(),
                  r = o / n;
                if (e.end_time()) {
                  const t = (0, l.Xx)(
                    "#SteamLearn_Status_Train_BatchCurrent_EpochDuration",
                    Jt(e.end_time() - e.start_time()),
                  );
                  t != m && u(t);
                } else if (!s.isFetching) {
                  let e = r - o;
                  if (!isNaN(e)) {
                    const t = (0, l.Xx)(
                      "#SteamLearn_Status_Train_BatchCurrent_TimeEstimate",
                      Jt(e),
                    );
                    t != m && u(t);
                  }
                }
                const c = qt(
                    e.train_batches().map((e) => e.loss()),
                    x,
                  ).map((e, t) => ({ index: t, Train: e })),
                  i = qt(
                    e.validate_batches().map((e) => e.loss()),
                    x,
                  ).map((e, t) => ({ index: t, Validate: e })),
                  _ =
                    e.train_batches().length > 0
                      ? e.train_batches()[e.train_batches().length - 1]
                      : void 0,
                  d =
                    e.validate_batches().length > 0
                      ? e.validate_batches()[e.validate_batches().length - 1]
                      : void 0;
                f = [
                  {
                    strDataLabel: "Train",
                    XAxisDomain: [0, Math.min(x, e.train_batches().length) / t],
                    data: c,
                    color: "#547d9e",
                    bAxisLine: !1,
                    nFinalValue: null == _ ? void 0 : _.loss(),
                  },
                  {
                    strDataLabel: "Validate",
                    XAxisDomain: [
                      0,
                      Math.min(x, e.validate_batches().length) / a,
                    ],
                    data: i,
                    color: "#609e54",
                    bAxisLine: !1,
                    nFinalValue: null == d ? void 0 : d.loss(),
                  },
                ];
                const E = qt(
                    e.train_batches().map((e) => aa(e.accuracy())),
                    x,
                  ).map((e, t) => ({ index: t, Train: e })),
                  p = qt(
                    e.validate_batches().map((e) => aa(e.accuracy())),
                    x,
                  ).map((e, t) => ({ index: t, Validate: e }));
                h = [
                  {
                    strDataLabel: "Train",
                    XAxisDomain: [0, Math.min(x, e.train_batches().length) / t],
                    data: E,
                    color: "#547d9e",
                    bAxisLine: !1,
                    nFinalValue: aa(null == _ ? void 0 : _.accuracy()),
                  },
                  {
                    strDataLabel: "Validate",
                    XAxisDomain: [
                      0,
                      Math.min(x, e.validate_batches().length) / a,
                    ],
                    data: p,
                    color: "#609e54",
                    bAxisLine: !1,
                    nFinalValue: aa(null == d ? void 0 : d.accuracy()),
                  },
                ];
              }
            } else {
              const e = L.epochs()
                  .map((e, t) => {
                    let a;
                    return (
                      e.validate_batches().length > 0 &&
                        (a =
                          e.validate_batches()[
                            e.validate_batches().length - 1
                          ]),
                      { index: t + 1, Value: null == a ? void 0 : a.loss() }
                    );
                  })
                  .filter((e) => null != e.Value),
                t = L.epochs()
                  .map((e, t) => {
                    let a;
                    return (
                      e.validate_batches().length > 0 &&
                        (a =
                          e.validate_batches()[
                            e.validate_batches().length - 1
                          ]),
                      {
                        index: t + 1,
                        Value: aa(null == a ? void 0 : a.accuracy()),
                      }
                    );
                  })
                  .filter((e) => null != e.Value);
              e.length > 0 &&
                t.length > 0 &&
                ((f = [
                  {
                    strDataLabel: "Value",
                    XAxisDomain: [1, e.length],
                    data: e,
                    color: "#609e54",
                    bAxisLine: !0,
                    nFinalValue: void 0,
                  },
                ]),
                (h = [
                  {
                    strDataLabel: "Value",
                    XAxisDomain: [1, t.length],
                    data: t,
                    color: "#609e54",
                    bAxisLine: !0,
                    nFinalValue: void 0,
                  },
                ]));
            }
          const j = L && L.status() == v.Nce.STEAMLEARN_TRAIN_STATUS_COMPLETE,
            y = L && L.live(),
            R = L && L.status() == v.Nce.STEAMLEARN_TRAIN_STATUS_IN_PROGRESS,
            k =
              a && r && r.serializeBase64String() != a.serializeBase64String();
          return o.createElement(
            "div",
            { className: Qt.TrainStatusPanel },
            o.createElement(
              "div",
              { className: Qt.TopSection },
              o.createElement(
                "div",
                { className: Qt.TopLeft },
                o.createElement(
                  "div",
                  { className: Qt.OverallStatus },
                  (0, l.Xx)("#SteamLearn_Status_Train_Status", e.nTrainID),
                ),
                !k &&
                  j &&
                  !y &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(Qt.SteamLearnButton, Qt.Blue),
                      onClick: () => E(e.nTrainID),
                    },
                    (0, l.Xx)("#SteamLearn_Status_SetInferenceVersion"),
                  ),
                k &&
                  j &&
                  !y &&
                  o.createElement(
                    "div",
                    { className: Qt.WarningMessage },
                    (0, l.Xx)("#SteamLearn_Status_SaveOrDiscardFirst"),
                  ),
                R &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(Qt.SteamLearnButton, Qt.Blue),
                      onClick: () => {
                        return (
                          (t = e.nTrainID),
                          (0, _.mG)(void 0, void 0, void 0, function* () {
                            let e = g.gA.Init(v.$GS);
                            e.Body().set_project_config(n),
                              e.Body().train().set_train_id(t),
                              e.Body().train().set_request_cancel(!0),
                              yield v.NG.Train(
                                p.Get().GetServiceTransport(),
                                e,
                              );
                          })
                        );
                        var t;
                      },
                    },
                    (0, l.Xx)("#SteamLearn_Status_Train_EndEarly"),
                  ),
                y &&
                  o.createElement(
                    "div",
                    { onClick: () => E(0), className: Qt.TrainLive },
                    (0, l.Xx)("#SteamLearn_Status_InferenceLive"),
                  ),
                o.createElement(
                  "div",
                  { className: (0, i.Z)(Qt.StatusString, C) },
                  D,
                ),
              ),
              o.createElement(
                "div",
                { className: Qt.TopRight },
                o.createElement(
                  "select",
                  {
                    value: e.nTrainID,
                    onChange: (t) => e.fnSetTrainID(parseInt(t.target.value)),
                  },
                  S.map((e) =>
                    o.createElement(
                      "option",
                      { key: `TrainOption_${e}`, value: e },
                      (0, l.Xx)("#SteamLearn_Status_Train_TrainOption", e),
                    ),
                  ),
                ),
              ),
            ),
            L &&
              o.createElement(
                "div",
                { className: Qt.EpochSelectorSection },
                L.epochs().length > 0 &&
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(
                        Qt.EpochOption,
                        0 == c && Qt.Selected,
                      ),
                      onClick: () => d(0),
                    },
                    (0, l.Xx)("#SteamLearn_Status_Train_AllEpochs"),
                  ),
                (0, ve.bE)(1, L.epochs().length).map((e) =>
                  o.createElement(
                    "div",
                    {
                      key: `Epoch_${e}`,
                      className: (0, i.Z)(
                        Qt.EpochOption,
                        c == e && Qt.Selected,
                      ),
                      onClick: () => d(e),
                    },
                    (0, l.Xx)("#SteamLearn_Status_Train_EpochOption", e),
                  ),
                ),
              ),
            L &&
              0 != c &&
              o.createElement(
                "div",
                { className: Qt.BatchStatus },
                A > 0 &&
                  o.createElement(
                    "div",
                    { className: Qt.BatchStatusRow },
                    o.createElement(
                      "div",
                      { className: Qt.PhaseLabel },
                      (0, l.Xx)("#SteamLearn_Status_Train_BatchCurrent_Train"),
                    ),
                    I > 0 &&
                      A == I &&
                      o.createElement(
                        "div",
                        { className: Qt.PhaseValues },
                        o.createElement(
                          "span",
                          { className: Qt.Total },
                          (0, l.Xx)("#SteamLearn_Status_Train_Status_Complete"),
                        ),
                      ),
                    I > 0 &&
                      A != I &&
                      o.createElement(
                        "div",
                        { className: Qt.PhaseValues },
                        (100 * A).toLocaleString(),
                        " / ",
                        o.createElement(
                          "span",
                          { className: Qt.Total },
                          (100 * I).toLocaleString(),
                        ),
                      ),
                  ),
                P > 0 &&
                  o.createElement(
                    "div",
                    { className: Qt.BatchStatusRow },
                    o.createElement(
                      "div",
                      { className: Qt.PhaseLabel },
                      (0, l.Xx)(
                        "#SteamLearn_Status_Train_BatchCurrent_Validate",
                      ),
                    ),
                    O > 0 &&
                      P == O &&
                      o.createElement(
                        "div",
                        { className: Qt.PhaseValues },
                        o.createElement(
                          "span",
                          { className: Qt.Total },
                          (0, l.Xx)("#SteamLearn_Status_Train_Status_Complete"),
                        ),
                      ),
                    O > 0 &&
                      P != O &&
                      o.createElement(
                        "div",
                        { className: Qt.PhaseValues },
                        (100 * P).toLocaleString(),
                        " / ",
                        o.createElement(
                          "span",
                          { className: Qt.Total },
                          (100 * O).toLocaleString(),
                        ),
                      ),
                  ),
                o.createElement("div", { className: Qt.BatchStatusRow }, m),
              ),
            L &&
              f &&
              h &&
              o.createElement(
                "div",
                { className: Qt.CurrentEpoch },
                o.createElement(
                  "div",
                  { className: Qt.GraphPair },
                  o.createElement(ta, {
                    strHeading: (0, l.Xx)("#SteamLearn_Status_Train_Axis_Loss"),
                    lines: f,
                    fAxisPaddingPct: 25,
                  }),
                  o.createElement(ta, {
                    strHeading: (0, l.Xx)(
                      "#SteamLearn_Status_Train_Axis_Accuracy",
                    ),
                    lines: h,
                    fAxisPaddingPct: 25,
                  }),
                ),
              ),
          );
        },
        oa = () => {
          const { nProjectID: e } = Xe();
          return o.createElement(
            "div",
            { className: Qt.ProjectTrainStatusPage },
            o.createElement(Ue, { nProjectID: e }),
            o.createElement(
              "div",
              { className: Qt.ProjectTrainStatusBody },
              o.createElement(ra, null),
            ),
          );
        },
        ra = () => {
          const {
              msgWorkingProject: e,
              msgWorkingProjectConfig: t,
              nProjectID: a,
              nPublishedVersion: n,
            } = Xe(),
            s = (0, r.UO)(),
            c = (0, r.k6)(),
            i = G(a, n),
            l = U(a, n),
            _ = i.data,
            d = l.data;
          if (
            (o.useEffect(() => {
              const e = parseInt(s.fetch_id);
              let t = e;
              _ && (isNaN(e) || 0 == e) && (t = Math.max(0, ..._.versions()));
              const a = parseInt(s.train_id);
              let n = a;
              d && (isNaN(a) || 0 == a) && (n = Math.max(0, ...d.versions())),
                (e == t && a == n) ||
                  c.push(
                    _a.SteamLearnProjectTrainStatus(s.id, s.version, t, n),
                  );
            }, [s, _, d, c]),
            i.isLoading || l.isLoading)
          )
            return o.createElement("div", null, "LOADING");
          if (!i.isSuccess || !l.isSuccess) return null;
          const m = parseInt(s.fetch_id);
          return o.createElement(
            "div",
            { className: Qt.ProjectTrain },
            m > 0 &&
              o.createElement(ea, {
                nProjectID: a,
                nFetchID: m,
                arrAllFetchIDs: _.versions(),
                fnSetFetchID: (e) => {
                  c.push(
                    _a.SteamLearnProjectTrainStatus(
                      s.id,
                      s.version,
                      e,
                      s.train_id,
                    ),
                  );
                },
              }),
            o.createElement("div", { className: Qt.Separator }),
            o.createElement(na, {
              nProjectID: a,
              nTrainID: parseInt(s.train_id),
              arrAllTrainIDs: d.versions(),
              fnSetTrainID: (e) => {
                c.push(
                  _a.SteamLearnProjectTrainStatus(
                    s.id,
                    s.version,
                    s.fetch_id,
                    e,
                  ),
                );
              },
            }),
          );
        };
      var sa = a(51495);
      const ca = () => {
        var e, t, a, n, r, s, c;
        const {
            msgWorkingProject: d,
            msgWorkingProjectConfig: m,
            nProjectID: u,
            nPublishedVersion: E,
          } = Xe(),
          [p, S] = o.useState(
            m.snapshot_filter().sample_reduce_percent().toString(),
          ),
          [N, g] = o.useState(!0),
          [T, L] = o.useState(
            m.snapshot_filter().histogram().min_value().toFixed(2),
          ),
          [f, h] = o.useState(!0),
          [D, C] = o.useState(
            m.snapshot_filter().histogram().max_value().toFixed(2),
          ),
          [A, I] = o.useState(!0),
          [P, O] = o.useState(
            m.snapshot_filter().histogram().num_buckets().toString(),
          ),
          [x, j] = o.useState(!0),
          [b, y] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_ACCOUNT_IDS
              ? (null ===
                  (e = m.snapshot_config().config_account_ids().percent()) ||
                void 0 === e
                  ? void 0
                  : e.toString()) || "0"
              : "",
          ),
          [R, k] = o.useState(!0),
          [M, X] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_ACCOUNT_IDS
              ? (null ===
                  (t = m
                    .snapshot_config()
                    .config_account_ids()
                    .activity_recency_days()) || void 0 === t
                  ? void 0
                  : t.toString()) || "0"
              : "",
          ),
          [B, w] = o.useState(!0),
          [W, V] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_APP_IDS
              ? (null ===
                  (a = m.snapshot_config().config_app_ids().percent()) ||
                void 0 === a
                  ? void 0
                  : a.toString()) || "0"
              : "",
          ),
          [H, F] = o.useState(!0),
          [G, U] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_APP_IDS
              ? (null ===
                  (n = m
                    .snapshot_config()
                    .config_app_ids()
                    .release_recency_days()) || void 0 === n
                  ? void 0
                  : n.toString()) || "0"
              : "",
          ),
          [Y, $] = o.useState(!0),
          [Z, K] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_OTHER_PROJECT
              ? (null ===
                  (r = m
                    .snapshot_config()
                    .config_other_project()
                    .project_id()) || void 0 === r
                  ? void 0
                  : r.toString()) || "0"
              : "",
          ),
          [z, Q] = o.useState(
            m.snapshot_config().snapshot_type() ==
              v.Yz$.STEAMLEARN_SNAPSHOT_OTHER_PROJECT
              ? (null ===
                  (s = m
                    .snapshot_config()
                    .config_other_project()
                    .published_version()) || void 0 === s
                  ? void 0
                  : s.toString()) || "0"
              : "",
          ),
          [J, q] = o.useState(!0),
          [ee, te] = o.useState(m.snapshot_config().snapshot_schedule_type()),
          [ae, ne] = o.useState(
            m.snapshot_config().snapshot_schedule_day_of_week(),
          ),
          [oe, re] = o.useState(
            (null ===
              (c = m.snapshot_config().snapshot_schedule_day_of_month()) ||
            void 0 === c
              ? void 0
              : c.toString()) || "0",
          ),
          [ce, ie] = o.useState(!0),
          de = o.useCallback(
            (e) => {
              m.snapshot_config().set_snapshot_schedule_type(e), se(d), te(e);
            },
            [d, m],
          ),
          ue = o.useCallback(
            (e) => {
              m.snapshot_config().set_snapshot_schedule_day_of_week(e),
                se(d),
                ne(e);
            },
            [d, m],
          ),
          Ee = o.useCallback(
            (e) => {
              const t = le(e, 0, 31),
                a = parseInt(e);
              t &&
                a != m.snapshot_config().snapshot_schedule_day_of_month() &&
                (m.snapshot_config().set_snapshot_schedule_day_of_month(a),
                se(d)),
                ie(t),
                re(e);
            },
            [d, m],
          );
        let pe = [];
        for (const e of m.data_source_element_usages())
          pe.push({
            label: e.data_element_path(),
            value: e.data_element_path(),
          });
        let Se = [
          {
            label: (0, l.Xx)(
              "#SteamLearn_SnapshotFilter_Histogram_ElementPathNone",
            ),
            value: "",
          },
          ...pe,
        ];
        const Ne =
            m.snapshot_filter().histogram().data_element_path().length > 0,
          ge =
            m.snapshot_config().snapshot_type() ==
            v.Yz$.STEAMLEARN_SNAPSHOT_ACCOUNT_IDS,
          ve =
            m.snapshot_config().snapshot_type() ==
            v.Yz$.STEAMLEARN_SNAPSHOT_APP_IDS,
          Te =
            m.snapshot_config().snapshot_type() ==
            v.Yz$.STEAMLEARN_SNAPSHOT_OTHER_PROJECT,
          Le = ee == v.S35.STEAM_LEARN_SCHEDULED_TYPE_WEEKLY,
          fe = ee == v.S35.STEAM_LEARN_SCHEDULED_TYPE_MONTHLY;
        return o.createElement(
          "div",
          { className: sa.ProjectSnapshotFilterPage },
          o.createElement(Ue, { nProjectID: u }),
          o.createElement(
            "div",
            { className: sa.ProjectConfigBody },
            o.createElement(
              "div",
              { className: sa.OptionHeader },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_SamplePercent"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionDesc },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_SamplePercentDesc"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionBlock },
              o.createElement(
                "div",
                { className: sa.OptionDetails },
                (0, l.Xx)("#SteamLearn_SnapshotFilter_SamplePercent"),
              ),
              o.createElement("input", {
                type: "text",
                className: (0, i.Z)(sa.ValueInput, !N && sa.Invalid),
                disabled: !1,
                value: p,
                onChange: (e) =>
                  ((e) => {
                    const t = le(e, 0, 99);
                    t &&
                      (m
                        .snapshot_filter()
                        .set_sample_reduce_percent(parseInt(e)),
                      se(d)),
                      g(t),
                      S(e);
                  })(e.target.value),
              }),
            ),
            o.createElement("div", { className: sa.Separator }),
            o.createElement(
              "div",
              { className: sa.OptionHeader },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_Histogram"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionDesc },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_HistogramDesc"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionBlock },
              o.createElement(
                "div",
                { className: sa.OptionDetails },
                (0, l.Xx)("#SteamLearn_SnapshotFilter_Histogram_ElementPath"),
              ),
              o.createElement(
                "select",
                {
                  className: sa.InputSelect,
                  disabled: !1,
                  value: m.snapshot_filter().histogram().data_element_path(),
                  onChange: (e) => {
                    return (
                      (t = e.target.value),
                      m.snapshot_filter().histogram().set_data_element_path(t),
                      void se(d)
                    );
                    var t;
                  },
                },
                Se.map((e) =>
                  o.createElement(
                    "option",
                    { key: e.value, value: e.value },
                    e.label,
                  ),
                ),
              ),
            ),
            Ne &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_HistogramMin"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !f && sa.Invalid),
                  disabled: !Ne,
                  value: T,
                  onChange: (e) =>
                    ((e) => {
                      const t = _e(e);
                      t &&
                        (m
                          .snapshot_filter()
                          .histogram()
                          .set_min_value(parseFloat(e)),
                        se(d)),
                        h(t),
                        L(e);
                    })(e.target.value),
                }),
              ),
            Ne &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_HistogramMax"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !A && sa.Invalid),
                  disabled: !Ne,
                  value: D,
                  onChange: (e) =>
                    ((e) => {
                      const t = _e(e);
                      t &&
                        (m
                          .snapshot_filter()
                          .histogram()
                          .set_max_value(parseFloat(e)),
                        se(d)),
                        I(t),
                        C(e);
                    })(e.target.value),
                }),
              ),
            Ne &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_HistogramBuckets"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !x && sa.Invalid),
                  disabled: !Ne,
                  value: P,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 2);
                      t &&
                        (m
                          .snapshot_filter()
                          .histogram()
                          .set_num_buckets(parseInt(e)),
                        se(d)),
                        j(t),
                        O(e);
                    })(e.target.value),
                }),
              ),
            o.createElement("div", { className: sa.Separator }),
            o.createElement(
              "div",
              { className: sa.OptionHeader },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotType"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionDesc },
              (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotTypeDesc"),
            ),
            o.createElement(
              "div",
              { className: sa.OptionBlock },
              o.createElement(
                "div",
                { className: sa.OptionDetails },
                (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotType"),
              ),
              o.createElement(
                "select",
                {
                  className: sa.InputSelect,
                  disabled: !1,
                  value: m.snapshot_config().snapshot_type(),
                  onChange: (e) => {
                    return (
                      (t = e.target.value),
                      m.snapshot_config().set_snapshot_type(t),
                      void se(d)
                    );
                    var t;
                  },
                },
                o.createElement(
                  "option",
                  { value: v.Yz$.STEAMLEARN_SNAPSHOT_MANUAL },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotType_Manual"),
                ),
                o.createElement(
                  "option",
                  { value: v.Yz$.STEAMLEARN_SNAPSHOT_ACCOUNT_IDS },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotType_AutoAccountIDs",
                  ),
                ),
                o.createElement(
                  "option",
                  { value: v.Yz$.STEAMLEARN_SNAPSHOT_APP_IDS },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotType_AutoAppIDs",
                  ),
                ),
                o.createElement(
                  "option",
                  { value: v.Yz$.STEAMLEARN_SNAPSHOT_OTHER_PROJECT },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotType_OtherProject",
                  ),
                ),
              ),
            ),
            ge &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_Snapshot_Percentage"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !R && sa.Invalid),
                  disabled: !ge,
                  value: b,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 1, 100);
                      t &&
                        (m
                          .snapshot_config()
                          .config_account_ids()
                          .set_percent(parseInt(e)),
                        se(d)),
                        k(t),
                        y(e);
                    })(e.target.value),
                }),
              ),
            ge &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotAccountID_Recency",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !B && sa.Invalid),
                  disabled: !ge,
                  value: M,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 30, 360);
                      t &&
                        (m
                          .snapshot_config()
                          .config_account_ids()
                          .set_activity_recency_days(parseInt(e)),
                        se(d)),
                        w(t),
                        X(e);
                    })(e.target.value),
                }),
              ),
            ve &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_Snapshot_Percentage"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !H && sa.Invalid),
                  disabled: !ve,
                  value: W,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 1, 100);
                      t &&
                        (m
                          .snapshot_config()
                          .config_app_ids()
                          .set_percent(parseInt(e)),
                        se(d)),
                        F(t),
                        V(e);
                    })(e.target.value),
                }),
              ),
            ve &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotAppID_Recency"),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !Y && sa.Invalid),
                  disabled: !ve,
                  value: G,
                  onChange: (e) =>
                    ((e) => {
                      const t = le(e, 6, 360);
                      t &&
                        (m
                          .snapshot_config()
                          .config_app_ids()
                          .set_release_recency_days(parseInt(e)),
                        se(d)),
                        $(t),
                        U(e);
                    })(e.target.value),
                }),
              ),
            Te &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotOther_ProjectID",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !J && sa.Invalid),
                  disabled: !Te,
                  value: Z,
                  onChange: (e) => {
                    return (
                      (t = e.target.value),
                      (0, _.mG)(void 0, void 0, void 0, function* () {
                        const e = le(t, 1),
                          a = yield me(
                            m.project_id(),
                            m.published_version(),
                            parseInt(t),
                            parseInt(z),
                          );
                        e &&
                          a &&
                          (m
                            .snapshot_config()
                            .config_other_project()
                            .set_project_id(parseInt(t)),
                          se(d)),
                          q(e && a),
                          K(t);
                      })
                    );
                    var t;
                  },
                }),
              ),
            Te &&
              o.createElement(
                "div",
                { className: sa.OptionBlock },
                o.createElement(
                  "div",
                  { className: sa.OptionDetails },
                  (0, l.Xx)(
                    "#SteamLearn_SnapshotFilter_SnapshotOther_PublishedVersion",
                  ),
                ),
                o.createElement("input", {
                  type: "text",
                  className: (0, i.Z)(sa.ValueInput, !J && sa.Invalid),
                  disabled: !Te,
                  value: z,
                  onChange: (e) => {
                    return (
                      (t = e.target.value),
                      (0, _.mG)(void 0, void 0, void 0, function* () {
                        const e = le(t, 1),
                          a = yield me(
                            m.project_id(),
                            m.published_version(),
                            parseInt(Z),
                            parseInt(t),
                          );
                        e &&
                          a &&
                          (m
                            .snapshot_config()
                            .config_other_project()
                            .set_published_version(parseInt(t)),
                          se(d)),
                          q(e && a),
                          Q(t);
                      })
                    );
                    var t;
                  },
                }),
              ),
            o.createElement("div", { className: sa.Separator }),
            (ge || ve) &&
              o.createElement(
                "div",
                null,
                o.createElement(
                  "div",
                  { className: sa.OptionHeader },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotSchedule"),
                ),
                o.createElement(
                  "div",
                  { className: sa.OptionDesc },
                  (0, l.Xx)("#SteamLearn_SnapshotFilter_SnapshotScheduleDesc"),
                ),
                o.createElement(
                  "div",
                  { className: sa.Heading },
                  (0, l.Xx)("#SteamLearn_ScheduledTrain_Heading"),
                ),
                o.createElement(
                  "select",
                  {
                    className: sa.TrainDropdown,
                    value: ee,
                    onChange: (e) => de(parseInt(e.target.value)),
                  },
                  o.createElement(
                    "option",
                    {
                      key: "Weekly",
                      value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_WEEKLY,
                    },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalWeekly"),
                  ),
                  o.createElement(
                    "option",
                    {
                      key: "Monthly",
                      value: v.S35.STEAM_LEARN_SCHEDULED_TYPE_MONTHLY,
                    },
                    (0, l.Xx)("#SteamLearn_ScheduledTrain_IntervalMonthly"),
                  ),
                ),
                fe &&
                  o.createElement(
                    "div",
                    { className: sa.OptionBlock },
                    o.createElement(
                      "div",
                      { className: sa.OptionDetails },
                      (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfMonth"),
                    ),
                    o.createElement("input", {
                      type: "text",
                      className: (0, i.Z)(sa.ValueInput, !ce && sa.Invalid),
                      value: oe,
                      onChange: (e) => Ee(e.target.value),
                    }),
                  ),
                Le &&
                  o.createElement(
                    "div",
                    { className: sa.OptionBlock },
                    o.createElement(
                      "div",
                      { className: sa.OptionDetails },
                      (0, l.Xx)("#SteamLearn_ScheduledTrain_DayOfWeek"),
                    ),
                    o.createElement(
                      "select",
                      {
                        className: sa.TrainDropdown,
                        value: ae,
                        onChange: (e) => ue(parseInt(e.target.value)),
                      },
                      o.createElement(
                        "option",
                        { key: "Sunday", value: 0 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Sunday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Monday", value: 1 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Monday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Tuesday", value: 2 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Tuesday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Wednesday", value: 3 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Wednesday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Thursday", value: 4 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Thursday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Friday", value: 5 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Friday",
                        ),
                      ),
                      o.createElement(
                        "option",
                        { key: "Saturday", value: 6 },
                        (0, l.Xx)(
                          "#SteamLearn_ScheduledTrain_DayOfWeek_Saturday",
                        ),
                      ),
                    ),
                  ),
              ),
          ),
        );
      };
      var ia = a(24888);
      const la = () => {
          const {
              msgWorkingProject: e,
              msgWorkingProjectConfig: t,
              nProjectID: a,
              nPublishedVersion: n,
            } = Xe(),
            [r, s] = o.useState({}),
            [c, d] = o.useState(o.createElement("div", null)),
            [m, u] = o.useState(""),
            [E, S] = o.useState(0),
            T = o.useMemo(
              () =>
                Array.from(t.data_source_element_usages().values()).sort(
                  (e, t) => {
                    const a = e.data_element_path().split("/"),
                      n = t.data_element_path().split("/"),
                      o = Math.min(a.length, n.length);
                    for (let e = 0; e < o; e++) {
                      const t = a[e].split("#"),
                        o = n[e].split("#"),
                        r = t.length > 1 ? parseInt(t[1]) : 0,
                        s = o.length > 1 ? parseInt(o[1]) : 0;
                      if (t[0] == o[0]) {
                        if (r == s) continue;
                        if (r < s) return -1;
                        if (r > s) return 1;
                      }
                      return a[e] < n[e] ? -1 : 1;
                    }
                    return a.length < n.length ? -1 : 1;
                  },
                ),
              [t],
            );
          o.useEffect(() => {
            const e = Math.max(...t.train_infos().map((e) => e.train_id()));
            S(e);
          }, [t]),
            o.useEffect(() => {
              for (const e of T)
                s((t) =>
                  Object.assign(Object.assign({}, t), {
                    [e.data_element_path()]: "0",
                  }),
                );
            }, [T]);
          return 0 == Object.keys(r).length
            ? null
            : o.createElement(
                "div",
                { className: ia.ProjectInferenceTesterPage },
                o.createElement(Ue, { nProjectID: a }),
                o.createElement(
                  "div",
                  { className: ia.ProjectInferenceTesterBody },
                  T.map((e) =>
                    0 == e.input()
                      ? null
                      : o.createElement(
                          "div",
                          {
                            className: ia.DataSourceElement,
                            key: e.data_element_path(),
                          },
                          o.createElement(
                            "div",
                            { className: ia.Name },
                            e.data_element_path(),
                          ),
                          o.createElement("input", {
                            type: "text",
                            className: ia.ValueInput,
                            value: r[e.data_element_path()],
                            onChange: (t) =>
                              s(
                                Object.assign(Object.assign({}, r), {
                                  [e.data_element_path()]: t.target.value,
                                }),
                              ),
                          }),
                        ),
                  ),
                  o.createElement("div", { className: ia.Separator }),
                  o.createElement(
                    "div",
                    { className: ia.OptionBlock },
                    o.createElement(
                      "div",
                      { className: ia.OptionDetails },
                      (0, l.Xx)("#SteamLearn_InferenceTester_AdditionalData"),
                    ),
                    o.createElement("input", {
                      type: "text",
                      className: ia.ValueInput,
                      value: m,
                      onChange: (e) => u(e.target.value),
                    }),
                  ),
                  o.createElement(
                    "select",
                    {
                      className: ia.TrainDropdown,
                      value: E,
                      onChange: (e) => S(parseInt(e.target.value)),
                    },
                    t
                      .train_infos()
                      .map((e) => e.train_id())
                      .map((e) =>
                        o.createElement(
                          "option",
                          { key: `Fetch_${e}`, value: e },
                          (0, l.Xx)("#SteamLearn_ManualTrain_TrainVersion", e),
                        ),
                      ),
                  ),
                  o.createElement(
                    "div",
                    {
                      className: (0, i.Z)(ia.SteamLearnButton, ia.Blue),
                      onClick: () =>
                        (0, _.mG)(void 0, void 0, void 0, function* () {
                          var a;
                          let n = g.gA.Init(v.VO_);
                          n.Body().set_project_id(e.project_id());
                          const s = m.split(",").map((e) => parseInt(e));
                          n.Body().set_additional_data(s);
                          const c =
                            (null ===
                              (a = t
                                .train_infos()
                                .find((e) => e.train_id() == E)) || void 0 === a
                              ? void 0
                              : a.fetch_id()) || 0;
                          n.Body().set_fetch_id(c), n.Body().set_train_id(E);
                          const i = T.sort(
                            (e, t) => e.sql_column() - t.sql_column(),
                          );
                          for (const e of i) {
                            if (0 == e.input()) continue;
                            const t = new v.dqE();
                            t.set_float_value(
                              parseFloat(r[e.data_element_path()]),
                            ),
                              n.Body().add_data(t);
                          }
                          const l = yield v.NG.InferenceBackend(
                            p.Get().GetServiceTransport(),
                            n,
                          );
                          if (
                            (console.log(l.Body().toObject()),
                            l.BIsValid() && l.GetEResult() == N.s.k_EResultOK)
                          ) {
                            let e = [];
                            for (const t of l.Body().outputs()) {
                              if (
                                t.multi_binary_crossentropy().value().length > 0
                              ) {
                                e.push(o.createElement("div", null, "OUTPUT"));
                                for (
                                  let a = 0;
                                  a <
                                  t.multi_binary_crossentropy().value().length;
                                  a++
                                )
                                  e.push(
                                    o.createElement(
                                      "div",
                                      null,
                                      `${
                                        t.multi_binary_crossentropy().value()[a]
                                      } - ${(
                                        100 *
                                        t.multi_binary_crossentropy().weight()[
                                          a
                                        ]
                                      ).toFixed(2)}%`,
                                    ),
                                  );
                              }
                              if (
                                t.categorical_crossentropy().value().length > 0
                              )
                                for (
                                  let a = 0;
                                  a <
                                  t.categorical_crossentropy().value().length;
                                  a++
                                )
                                  e.push(
                                    o.createElement(
                                      "div",
                                      null,
                                      `${
                                        t.categorical_crossentropy().value()[a]
                                      } - ${(
                                        100 *
                                        t.categorical_crossentropy().weight()[a]
                                      ).toFixed(2)}%`,
                                    ),
                                  );
                            }
                            d(o.createElement("div", null, e));
                          } else d(o.createElement("div", null, "ERROR"));
                        }),
                    },
                    (0, l.Xx)("#SteamLearn_InferenceTester_Infer"),
                  ),
                  o.createElement("div", { className: ia.Results }, c),
                ),
              );
        },
        _a = {
          SteamLearnBase: () => "steamlearn",
          SteamLearnDataSource: () => "datasource",
          SteamLearnProject: () => "project",
          SteamLearnDataSourceList: () => `/${_a.SteamLearnDataSource()}/list`,
          SteamLearnDataSourceInspect: (e) =>
            `/${_a.SteamLearnDataSource()}/${null != e ? e : ":id"}/inspect`,
          SteamLearnProjectList: () => `/${_a.SteamLearnProject()}/list`,
          SteamLearnProjectEvents: () => `/${_a.SteamLearnProject()}/events`,
          SteamLearnProjectCreate: () => `/${_a.SteamLearnProject()}/create`,
          SteamLearnProjectDataSources: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/datasources`,
          SteamLearnProjectSnapshotFilter: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/snapshotfilter`,
          SteamLearnProjectModel: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/structure`,
          SteamLearnProjectTrainSettings: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/trainsettings`,
          SteamLearnProjectDataSettings: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/datasettings`,
          SteamLearnProjectManualTrain: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/manualtrain`,
          SteamLearnProjectScheduledTrain: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/scheduledtrain`,
          SteamLearnProjectTrainStatus: (e, t, a, n) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/trainstatus/${null != a ? a : ":fetch_id"}/${
              null != n ? n : ":train_id"
            }`,
          SteamLearnProjectInferenceTester: (e, t) =>
            `/${_a.SteamLearnProject()}/${null != e ? e : ":id"}/${
              null != t ? t : ":version"
            }/inferencetester`,
        },
        da = (e, t, a) => {
          location.pathname.includes(
            _a.SteamLearnProjectDataSources(t.id, t.version),
          ) && e.push(_a.SteamLearnProjectDataSources(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectModel(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectModel(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectSnapshotFilter(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectSnapshotFilter(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectModel(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectModel(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectTrainSettings(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectTrainSettings(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectDataSettings(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectDataSettings(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectManualTrain(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectManualTrain(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectScheduledTrain(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectScheduledTrain(t.id, a)),
            location.pathname.includes(
              _a.SteamLearnProjectTrainStatus(
                t.id,
                t.version,
                t.fetch_id,
                t.train_id,
              ),
            ) &&
              e.push(
                _a.SteamLearnProjectTrainStatus(
                  t.id,
                  a,
                  t.fetch_id,
                  t.train_id,
                ),
              ),
            location.pathname.includes(
              _a.SteamLearnProjectInferenceTester(t.id, t.version),
            ) && e.push(_a.SteamLearnProjectInferenceTester(t.id, a));
        },
        ma = (e) => {
          const t = (0, r.TH)(),
            a = null != (0, r.LX)(t.pathname, e.strRoute);
          return o.createElement(
            s.rU,
            {
              to: e.strLink,
              className: (0, i.Z)(
                c.LeftMenuBarItem,
                a && c.Active,
                e.bDisabled && c.Disabled,
              ),
            },
            e.strLabel,
          );
        },
        ua = () => {
          const e = (0, r.TH)();
          let t, a, n;
          for (const o of Object.values(_a)) {
            const s = o(void 0, void 0, void 0, void 0),
              c = (0, r.LX)(e.pathname, s);
            c &&
              c.params.id &&
              (s.includes(`/${_a.SteamLearnDataSource()}/`) &&
                (t = parseInt(c.params.id)),
              s.includes(`/${_a.SteamLearnProject()}/`) &&
                ((a = parseInt(c.params.id)),
                void 0 !== c.params.version &&
                  (n = parseInt(c.params.version))));
          }
          return o.createElement(
            "div",
            { className: c.LeftMenuBar },
            o.createElement(
              "div",
              { className: c.LeftMenuBarSectionHeader },
              (0, l.Xx)("#SteamLearn_DataSources"),
            ),
            o.createElement(ma, {
              bDisabled: !1,
              strRoute: _a.SteamLearnDataSourceList(),
              strLink: _a.SteamLearnDataSourceList(),
              strLabel: (0, l.Xx)("#SteamLearn_DataSources_BrowseList"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === t,
              strRoute: _a.SteamLearnDataSourceInspect(void 0),
              strLink: _a.SteamLearnDataSourceInspect(t || void 0),
              strLabel: (0, l.Xx)("#SteamLearn_DataSources_Inspect"),
            }),
            o.createElement(
              "div",
              { className: c.LeftMenuBarSectionHeader },
              (0, l.Xx)("#SteamLearn_Projects"),
            ),
            o.createElement(ma, {
              bDisabled: !1,
              strRoute: _a.SteamLearnProjectList(),
              strLink: _a.SteamLearnProjectList(),
              strLabel: (0, l.Xx)("#SteamLearn_Project_BrowseList"),
            }),
            o.createElement(ma, {
              bDisabled: !1,
              strRoute: _a.SteamLearnProjectEvents(),
              strLink: _a.SteamLearnProjectEvents(),
              strLabel: (0, l.Xx)("#SteamLearn_Project_Events"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectDataSources(void 0, void 0),
              strLink: _a.SteamLearnProjectDataSources(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_DataSources"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectSnapshotFilter(void 0, void 0),
              strLink: _a.SteamLearnProjectSnapshotFilter(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_SnapshotFilter"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectModel(void 0, void 0),
              strLink: _a.SteamLearnProjectModel(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_ModelStructure"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectTrainSettings(void 0, void 0),
              strLink: _a.SteamLearnProjectTrainSettings(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_TrainSettings"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectDataSettings(void 0, void 0),
              strLink: _a.SteamLearnProjectDataSettings(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_DataSettings"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectManualTrain(void 0, void 0),
              strLink: _a.SteamLearnProjectManualTrain(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_TrainManual"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectScheduledTrain(void 0, void 0),
              strLink: _a.SteamLearnProjectScheduledTrain(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_TrainScheduled"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectTrainStatus(
                void 0,
                void 0,
                void 0,
                void 0,
              ),
              strLink: _a.SteamLearnProjectTrainStatus(a || void 0, n, 0, 0),
              strLabel: (0, l.Xx)("#SteamLearn_Project_TrainStatus"),
            }),
            o.createElement(ma, {
              bDisabled: void 0 === a,
              strRoute: _a.SteamLearnProjectInferenceTester(void 0, void 0),
              strLink: _a.SteamLearnProjectInferenceTester(a || void 0, n),
              strLabel: (0, l.Xx)("#SteamLearn_Project_InferenceTester"),
            }),
          );
        };
      function Ea() {
        return o.createElement(
          "div",
          { className: c.SteamLearnApp },
          o.createElement(
            s.VK,
            { basename: (0, n.l)() + _a.SteamLearnBase() },
            o.createElement(
              Ve,
              null,
              o.createElement(ua, null),
              o.createElement(
                "div",
                { className: c.MainAppContainer },
                o.createElement(
                  r.rs,
                  null,
                  o.createElement(r.AW, {
                    path: _a.SteamLearnDataSourceList(),
                    component: Ne,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnDataSourceInspect(void 0),
                    component: Le,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectList(),
                    component: De,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectEvents(),
                    component: Pe,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectCreate(),
                    component: ye,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectDataSources(void 0, void 0),
                    component: $e,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectSnapshotFilter(void 0, void 0),
                    component: ca,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectModel(void 0, void 0),
                    component: yt,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectTrainSettings(void 0, void 0),
                    component: Bt,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectDataSettings(void 0, void 0),
                    component: Wt,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectManualTrain(void 0, void 0),
                    component: Ht,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectScheduledTrain(void 0, void 0),
                    component: Ut,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectTrainStatus(
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                    ),
                    component: oa,
                  }),
                  o.createElement(r.AW, {
                    path: _a.SteamLearnProjectInferenceTester(void 0, void 0),
                    component: la,
                  }),
                  o.createElement(r.l_, {
                    from: "/",
                    to: _a.SteamLearnProjectList(),
                  }),
                ),
              ),
            ),
          ),
        );
      }
    },
  },
]);
