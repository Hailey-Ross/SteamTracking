/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkappmgmt_storeadmin =
  self.webpackChunkappmgmt_storeadmin || []).push([
  [1264],
  {
    72478: (e) => {
      e.exports = {
        Dummy: "hxIbiGtX85NbMLGBBBW1n",
        Selected: "_12ZI7s69MOlM4o0yAGBxjb",
        HighlightIcon: "_2pQVuzydGOhRfyVsn1Ttnq",
        CustomMarker: "_1ZsnYOXnxmsC0Vy0xj0E5I",
        MarkerBacking: "_36MmS0gvxfqkKTEv76MeSs",
        HighlightIconSVG: "PW5DU-ExnaJrBf-ZkASCU",
        Faded: "Jk9mXULQBRfBT4Tq5BY15",
        Marker: "_1qdzpmJ1SLzMuEMUhdUDTK",
      };
    },
    57003: (e) => {
      e.exports = {
        GoLiveButtonCtn: "_10eOWbwO6HzRXkxNZo4pR0",
        GoLiveButton: "_2umasY4NwuMm9kxnunli8V",
        IsLive: "-kbc0ZfA0R37LIun489Wi",
        JumpToEndIcon: "_3w9FJyNAYTSM9zU-9F4N3z",
      };
    },
    95694: (e) => {
      e.exports = {
        LoadingTimeline: "_1i1LvHqL5jiJ4dAtv-ysGE",
        ScrollAndControlsCtn: "W_zhBYc-09Qr-jiT5wB8t",
        GamepadMode: "l2TaGYb-f5aIKVwbLPaGj",
        Controls: "_3-CtqPgBzhofpi97a4OxNH",
        TimelineScrollContainer: "_36b_KdpGxmn00My3Hq9933",
        ContentContainer: "_1Vt3vvPjL4ROJlZfbsmu-P",
        AbsoluteLayer: "tMyh754QOuFrHgQeJLYvP",
        HideOverflow: "_2nUMnNQATYH8WFMPhqoNAW",
        RelativeLayer: "_108CZvOGWTEQsSO0iit2J-",
        WithPointerEvents: "unNGMCTOK6uIv4QBsZGdE",
        RecordingDecorators: "_1axnxWp5pUYbu8wf1qvS5Y",
        ClipDecorators: "tw5fAsMBX1duf-v2tBuY1",
        GameModes: "_3fweCbZ_WNG5AmEE_UVgIC",
        DateDecorator: "_1_cOsP7g_ohsSDmVrsFwOv",
        BackgroundTicks: "CL4a77uFZfgIIthkMECVG",
        Highlights: "_198JA1uu_LPpDmP0U87BsN",
        Timestamps: "LbQ-iwpSBhAD98LskowDv",
        RangeSelector: "_35tVKvBxXf2f0sznZ4aBOB",
        SeekScrubber: "_1uy0tKNI4LYbTuhxPg4g21",
        PlayHead: "_1hMz0cK3t2HXwascRp3kpM",
        Thumbnails: "_3R28YHCMn9U5NvrdCCHoDz",
        PositionLeft: "_2NbPnlAnjS-b0QxZXJ8bwL",
        PositionRight: "_3kazx_gnbis7RSJi4YPK50",
        ContentAndGradient: "vr6fkB6nND76rVOUeNVVu",
        ScrollbarPlaceholder: "_322WTLrMirBtSCVfVEVnN1",
        LeftControlsAndContent: "_2ZLpFMIf2nd1nqMURYkgx8",
        ScrollGradientCtn: "_1hyEG83F554zl695UOtedY",
        FrontGradient: "_2D5lezOgNVf5PO_vGP6UhK",
        HideGradient: "_2KBvZtOQLnlekkw8XvwvEu",
        EndGradient: "_2HOPEGunXIoRLNzLZMkQ8C",
        ScrollbarAndSiblings: "_3A6_pctR-r38LS9uQsFQi7",
        ScrollBarCtn: "_3dZUYMj_C6yhvxzI0L010s",
        HideScrollBar: "eTpZaxu-1-SfsLemanHFB",
        ScrollTrack: "ypAP4syqquH1Oy48rutpI",
        PlayHeadAnnotation: "VzCqGXR4hfniDKyTLvjSr",
        RangeAnnotation: "_1OHs7b-Lwn32AB1Q3RG4Vd",
        ScrollThumb: "iOMpsnIlVIIiGjiU-kMhb",
        Highlight: "_2upx05vm5lqeHfB5vamfG",
      };
    },
    18877: (e) => {
      e.exports = { MouseListenerContainer: "_2qBcGdMy1CnOEMylo8DlLH" };
    },
    57837: (e) => {
      e.exports = {
        LoadingTimeline: "_2q1bRrGXZcl3LraqPiH8GF",
        ScrollAndControlsCtn: "b4rbIOmKg5RBYCNe1BBey",
        GamepadMode: "_3qkHHTocbcwsl0rGhLJ8S5",
        Controls: "IiKYe6HgROIOZ0WDN0ePu",
        TimelineScrollContainer: "lQDa_dMsxMDxUWu3C9fbM",
        ContentContainer: "_3cS9lOpRUM3HMceo-jnXoI",
        AbsoluteLayer: "_1T_GivtqrUsGgTx99WIyQr",
        HideOverflow: "_3pekeEGnsJLT_vxhrh9VlD",
        RelativeLayer: "_3b9Vm4ARYezTBScaAeKkTk",
        WithPointerEvents: "_3qu76u2uAgXcw2M14jsaZk",
        RecordingDecorators: "rel6LeHbpzUECi85PBXtL",
        ClipDecorators: "zmWGVtLpthMQxYQkLzxvF",
        GameModes: "_3DFg3YTYB9k7o55Q2VPddE",
        DateDecorator: "_3DsmItDR-RV07XU3qUTCxl",
        BackgroundTicks: "_2KJX1Hb8kBD8qiTVDxojD9",
        Highlights: "_1fOidxyNeGo_V_CwKSq3a",
        Timestamps: "_2jDX9bQ9x5G_uBgfjb8UGD",
        RangeSelector: "_1LGsBd7JxNsPlrPE4LnMXA",
        SeekScrubber: "_1z7bJLUVbN2e1t1cWy2Rk-",
        PlayHead: "_1Iku0D2d-Y6vRqVOArdxp-",
        Thumbnails: "_1hMNWJp65A53GmckO--muZ",
        PositionLeft: "_1ATGnFsJ716BreRcFSQcQt",
        PositionRight: "_2qrOXr2sVxG4TONnIQA0su",
      };
    },
    97929: (e) => {
      e.exports = {
        LoadingTimeline: "_2JDrGVSCNiB_z9csVuxLBw",
        ScrollAndControlsCtn: "VOrb9e4nBfhr_dKC0aRoR",
        GamepadMode: "_2aoqyA5Z8rvuKRoETQqeik",
        Controls: "qaanLZxes8kR6Y6sSs8HE",
        TimelineScrollContainer: "_2G_8gY210G9oePy3NN6qkt",
        ContentContainer: "_1uVCCcRhj9e_Pq5mq7WHUg",
        AbsoluteLayer: "_2SFFip095mC_LdncTqFBeO",
        HideOverflow: "cU6wsSwQQh6iHMSHYCzd_",
        RelativeLayer: "_2fDI2OIP_X95Mm8LAuZ9oS",
        WithPointerEvents: "_2-MGG2kBNNE5PTKqc0-b2r",
        RecordingDecorators: "_1NjYZ6hGGIxtXXfWUeAL-7",
        ClipDecorators: "pUy7fXfpWEBMcu58478C7",
        GameModes: "_1sHfwOhqDfqZmDga4SGCR2",
        DateDecorator: "_1VMlB7Qca7Wky8-5-fdl4B",
        BackgroundTicks: "_3IRCxI1CsHatqMDeILis62",
        Highlights: "_1az5e4FEU_sObP4p6BvQvH",
        Timestamps: "_1BzfUKKalUbYd4ngLA7b2N",
        RangeSelector: "fskkoWFHwYaG3p9jxxSA0",
        SeekScrubber: "_2eYekfgDY0ocpm_T_hy_wQ",
        PlayHead: "ULwMTjZzO3t4yQLX19xo2",
        Thumbnails: "_1fW9bdhItVyBg39Al8O6rE",
        PositionLeft: "_2zJY2PWVbFbr0XiPbIxi72",
        PositionRight: "_1sEzm6uphU5uxdOYMC3NyX",
        TimelineBacking: "_3DKuh756N2eENy86JC_4O8",
        TimeTick: "_21gY8PzFWYF-Bw9MlZiXDm",
        TickLine: "_1Yp6JEQWReLrqaHJaRiqTc",
        Major: "_3SvJUvuHZaXpx8hauIzZGR",
        Minor: "ZMQqOTHvTbwX2mMMsVGwv",
      };
    },
    91839: (e) => {
      e.exports = {
        LoadingTimeline: "_2SUXO7Q8OY44wRZOkvQUsz",
        ScrollAndControlsCtn: "_2-ruWLXcMa3TFtTylNwy25",
        GamepadMode: "_2r6w86J0HbRE17NsRwB2Pz",
        Controls: "_28WZ8Ms4KsEjz7injbDBbU",
        TimelineScrollContainer: "_3hZDt4hl1WgO6lLKoYtW0a",
        ContentContainer: "Gg4GcgmaX35B0TTILK8RQ",
        AbsoluteLayer: "_2pPjfp2ERhV59YS0N27-HD",
        HideOverflow: "s7QCXq9tP0S2mHNjtHL7n",
        RelativeLayer: "_3ZcXDNCk6fBrmWBFS8Da8Z",
        WithPointerEvents: "_3swr0YXpNSvpnYAhFwo-Z8",
        RecordingDecorators: "_2Ahakgkm9EZuTKiTePDOI3",
        ClipDecorators: "_3URh6VRj2J27ogqTfu-JPL",
        GameModes: "_3mmUZjIbm3YAdtLnL3Kbbw",
        DateDecorator: "_2rq8pkJzzuYwG1rKzWvv8l",
        BackgroundTicks: "_2DMNthxYGqV_JQAjlSkHpu",
        Highlights: "_34GQ7b3Z9fCEEsCnfhNhQW",
        Timestamps: "_1UiircjVpNIhkl7gzDY_zm",
        RangeSelector: "_3K5gQarYgsGD52orLTd4oz",
        SeekScrubber: "_2veVLgpeVUje03FjjAn8je",
        PlayHead: "_3vRVRJhEq_JL0jiq_MjYzP",
        Thumbnails: "_3gqbjpICatIvBgSpUdkrfM",
        PositionLeft: "_3Gwn_fKxXHAlbiodBNLRdc",
        PositionRight: "_3G86z-gJu_xUKQz-tRSg7t",
        ClipDecorator: "_2F-fi4D6cvKsQbJeaBTtxh",
        gradient: "VZFF--0JJiG73tcElSHLS",
      };
    },
    60024: (e) => {
      e.exports = {
        LoadingTimeline: "_3FP8PzXqYvO6UZrLoH3cLY",
        ScrollAndControlsCtn: "_2QQg8xoOf90VdN1D19MxSB",
        GamepadMode: "XF5__D-X9UHU-V-zci3ip",
        Controls: "_2PkCJh2tnbKUr6dfFfSI4i",
        TimelineScrollContainer: "_2ZjcG9dtwQBEHNC17-Ky9A",
        ContentContainer: "_3DCVC-Oyp6xdTnekwMIKoC",
        AbsoluteLayer: "_215GhsjcKHNP9ZoliJyOF9",
        HideOverflow: "_1cXe_LqWV0WQYbuyu91bSV",
        RelativeLayer: "_2nfZpnzjK4rSH_NWeeLQmX",
        WithPointerEvents: "N6qu15PFEbQQUOhlPlnfR",
        RecordingDecorators: "_2kam9dgRcQYfpvbC8Y6Elr",
        ClipDecorators: "_1TCCxPAW2YBwhg2UCdRNRM",
        GameModes: "QJ50zP3EG2r34afW0Svw6",
        DateDecorator: "_2qeKvZemI5EAxRMvhLIyLf",
        BackgroundTicks: "EjRsHXYXeIgkGsUOMaJrl",
        Highlights: "_3ldb9UOHnJUrJJk4zFCqIf",
        Timestamps: "_1S60e3-kAbGOor0QdQl0Hg",
        RangeSelector: "_32yf9myiPTHAkMuXejCnP6",
        SeekScrubber: "ypfLloOqencLUruzknrzo",
        PlayHead: "_185PbrQQN8rcoDy7qvfQja",
        Thumbnails: "rcepXJXEJG9myUzz2axoa",
        PositionLeft: "_3h2jUntAZ8XJ07Ff90p250",
        PositionRight: "_2-AOTzxQaCTvsa-ukTUk99",
        TimelineRelativeDate: "_3T-pn_0lqENgObgSuijChU",
        Overlay: "_1fN7jOMSZPTStQLx_RFVSs",
      };
    },
    72759: (e) => {
      e.exports = {
        LoadingTimeline: "_37fn0g0YIXOVYH7Fd7Obbm",
        ScrollAndControlsCtn: "_256lw6AVX-maGHX2CKrwlW",
        GamepadMode: "_2AkJFCTHgw_Gr7uYUsZJf",
        Controls: "_25ROFVl-WAD1yh-f-PmIUw",
        TimelineScrollContainer: "pppD3YlfckTXEKh1MP4Ck",
        ContentContainer: "_3vtI4zJh3MEv2It57ShhzB",
        AbsoluteLayer: "_2w4xPZzJ0jPDXPf2fDC6L5",
        HideOverflow: "oJrCOCQssD2MW46TaABN2",
        RelativeLayer: "_3lH9pVyd-UG7mZew_DOvKv",
        WithPointerEvents: "_2hCJgKz_vHLbkiXt4r9lUa",
        RecordingDecorators: "rhw2i1uNHvGyUN72BdeLx",
        ClipDecorators: "_3y2rqaV3_WnurehEbs9skN",
        GameModes: "_3VPJvRFzJWgmtk4FNy7cUK",
        DateDecorator: "_2fovTjodY9jw1_6sq75_W2",
        BackgroundTicks: "_2JyqochWKUZSWnewNTvD8B",
        Highlights: "SKVlmdvO0pFA1u3T7r4Zd",
        Timestamps: "_31dCG11UGhmwgwNzXJ0qJv",
        RangeSelector: "_2TX8kFczqim5FdGZh4al7c",
        SeekScrubber: "FkKviYbBZYNn4xbkNhm0f",
        PlayHead: "_35rsuVSSyqz8MCenYtAtf3",
        Thumbnails: "_1Usensd8h3hob7GdvPLfAm",
        PositionLeft: "_3q5f3PLwEvZizn9GY6M5Qm",
        PositionRight: "_1Cv6XWTZ_sbyaEsr28KP9I",
        GameModeMarker: "_3j3joaC_pMrGSGPfWmGgHw",
        Playing: "hLQ3vEubye6dTV6bKoSwN",
        Staging: "cUeHkWNUKkmoPYRkLrmRU",
        Menus: "_1qcOdpQBqWpE2ITrDqlffU",
        Unspecified: "_616kxsDynJ5NNvNNkdG__",
        GameModeMarkerClip: "Dw51Sygp7SZxey4AOYqYk",
      };
    },
    86946: (e) => {
      e.exports = {
        LoadingTimeline: "_3srjwAjSIoadaRZoyaFa53",
        ScrollAndControlsCtn: "_2AMvj0ATtwwNFFEjOdAoG",
        GamepadMode: "_2MA0fVyKZ3wHRCwvPsM5-3",
        Controls: "w72_zsrCzOjsA885L-hyb",
        TimelineScrollContainer: "_3rWaMF4Uyfpt2IDNkQZJ9M",
        ContentContainer: "_2WuH7aMMQ6LfSwltt_ZBUO",
        AbsoluteLayer: "_3BkCiyzX7RqHSktGKLpRlI",
        HideOverflow: "_2wekEsqv85gRPY-fMh-dWt",
        RelativeLayer: "_2XizskxIJss6fazRlrRH_0",
        WithPointerEvents: "_27oHsznOJ06gYcPpPqueRZ",
        RecordingDecorators: "idjHE83SWQVDbX9vgRFQu",
        ClipDecorators: "_2IhOoWBOzxZPW5DLxTA1jL",
        GameModes: "_2ggxzdoEVAB25NEo8_xVQt",
        DateDecorator: "_2iJsq7fWLJpUC_TPs7xyLs",
        BackgroundTicks: "b-NNc3zHqOvbgRRI_dife",
        Highlights: "_21LpgSpiclfTCGSusz4Q4V",
        Timestamps: "_28JV_GmMM0zy2Oe2cXpMQY",
        RangeSelector: "FYw7K9DyAeRPvuciiLO0x",
        SeekScrubber: "_-7enw3_hcH4KxSXEwJsJY",
        PlayHead: "_3-bdBjV-D0TUH7YSROXpIG",
        Thumbnails: "LHbL6_Zz2dzEZIN4WXNH_",
        PositionLeft: "d-NIuwAflCilKSf0eSOj7",
        PositionRight: "sixNYvTo77tc7uQUOqDf7",
        TimelineMarkerCtn: "_2VPQg_wZtvAyuAXHJB7fVw",
        Faded: "AGNSghYbcwxDFRo-aIxkU",
        TimelineMarker: "_38PoJNOgpYbnjJFNiKMxCB",
        DroplineCtn: "_2j9iQEiM56OIPaJ-OHtjIg",
        TimelineMarkerDropLine: "s8D993IbUMuniyScMGiKm",
        ToolTipSource: "wbDLg6pETsXNeZtxU7NF3",
        TooltipOffset: "BWRwmc6tEOxsalCNUHwyJ",
        TooltipHitBox: "VH_8GBK7k6tMX33VfgIvK",
        Overlay: "tjx4bRTG5swgiXIVyEqBM",
        TooltipContainer: "_1ufF8a7yFkFlQFWpMhXxsh",
        TooltipContents: "_3HcdPfgie7n3WFHRomVBnM",
        ImageHighlightPosition: "_2E2V6dumdegPZQYCSq5T0N",
        ImageHighlightBlock: "_3N9CYgO_azygXSYPk84m5a",
        Hide: "LuZL8gUSEz0xsmKI4H1yD",
        TimestampCtn: "_2hrXIDrivvEUCslIS0OXts",
        Timestamp: "_19yAZzCSzqeeBFatED-Ipb",
        TooltipHighlight: "_2_fsdf90_yz81NJTE210jT",
        HighlightHeader: "n8M-nBecVmusVuTMHIwKG",
        HighlightIcon: "_1V9hLCcICJjspSRzf-rq3U",
        HighlightInfoBlock: "_3mQqFCM7q_7CgYAmlsckHb",
        HighlightTitle: "_1RRuJn0BsYbF8dmcdS4Zq_",
        HighlightDesc: "_3rGunNuowgShWUxm5oGbYX",
        StateDescription: "_2jupFkaPRtd7_iZFRo8emc",
        ThumbnailContainer: "_2xuWLzEGCwoK30aHNHdtvp",
        TooltipButtons: "sr2sY_3ZkHfPnPRiEkLPf",
        Button: "_1yrBdxYswob3tZgIkoR-tm",
        CreateClipButton: "_3bhjhpzJobYKoTXLDDE14y",
        EditMarker: "_2G8lXDOdzcENKYmh1FkRmM",
        DeleteMarker: "_1Bz4fI_JqUI6bWWtdCMOvq",
        GoToClip: "_6lJckM2L71h3JSvC_ndIp",
        ViewScreenshot: "T0uCGIYqm3f0gvyGWgiGj",
        NoRecordedContent: "_1MzuBsFSrpv_Ywcx0CHtmN",
      };
    },
    28349: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_2vJx82PK0eSGctngnNNQCP",
        ScrollAndControlsCtn: "nPIhptLSna2pqprleUiAE",
        GamepadMode: "_1zSJOp1WvRBUzD_mLir1bz",
        Controls: "_1gw3xFxYAwiikcRnKd5zzY",
        TimelineScrollContainer: "STqx_vuQGMDPh2zgmRV3j",
        ContentContainer: "_3QEocNWcdgpS0_jBO2IAhA",
        AbsoluteLayer: "_1k53uDW2jyzuLDpQzPPV-o",
        HideOverflow: "_1nV9B9q4KUOU59tPvxboGb",
        RelativeLayer: "_3UJtVkMBI76g4THupSCJ5N",
        WithPointerEvents: "_2feD2KCXP9yc-MSqUHF5ai",
        RecordingDecorators: "HSQxmKgg_F2JrTS2KkaV",
        ClipDecorators: "_3XbwUtcmHTwg6O6NNLNYWP",
        GameModes: "_2_Y6MDfoLE3drH3MIkIrNC",
        DateDecorator: "_164X_pEdW2ds0mUfbeQxRK",
        BackgroundTicks: "_10KYppgjoWZgEiejvMGNMR",
        Highlights: "_1Y7ULrH9H4Bw_YXP1d8uLF",
        Timestamps: "_3DJgOoVQI4j9s9pzibpW2N",
        RangeSelector: "_2N7tQrta2T0EgaYFaX1qD4",
        SeekScrubber: "anvpNOE3-Hu4P4McYagtL",
        PlayHead: "_23Eh5qj3nKjB4dB0S4gwPC",
        Thumbnails: "og1oPUgQxKgdh5vv6JGiI",
        PositionLeft: "_3Rs7QEarDMh8sHkQaXVWt9",
        PositionRight: "NcBRASyZTzG-N1c1AXdWw",
        PlayheadInteractionCtn: "_2vyRo_23IHqaWsOuPfZzIJ",
        ActiveCtn: "_89rGvqZIoyTXBb23pOmVq",
        PlayHeadContainer: "_2x8YN4RvLu1CEIqCbGNpUL",
        TooltipSource: "VJmWjLFCnyBUeVuyFgRMb",
        Active: "_1xsR-AcQtXC3_NFAcf334m",
        PlayHeadContent: "_1pnAm9mTDE0X4yXe0P_x4Z",
        PlayHeadCurrentTimeContainer: "_2DxZJ3l0PdaN7w_ez5nFFM",
        NoPointer: "vuBYQEBXI89YHbx23aqf7",
        TooltipContents: "_1i1cJIofOAMKbXrtdSnM9M",
        SeekTimeContainer: "_150_6qY6Bfu4cCNuVGLCs9",
        StateDescription: "vDz35Tn2QhcGvppiDndoW",
        TooltipTime: "_3v66aWFVrLHHHk8MXmgQre",
      };
    },
    94314: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_1t3acViXSARRO_6DJr4EDG",
        ScrollAndControlsCtn: "_1QTGk1MU60WBQg_rGl5fEH",
        GamepadMode: "_1U08EgHssn7hkdYOsb--ar",
        Controls: "_1ESz5vhhg313UiIz0CNUpF",
        TimelineScrollContainer: "_2p7wqM-tAQ3zUcJKKl7Si0",
        ContentContainer: "_2a4VQUfdZ_0osMPHJU2To4",
        AbsoluteLayer: "kI13-Ze93f5Nr0IfieBGl",
        HideOverflow: "_1lmBZflwmXMBJFkeczsoj",
        RelativeLayer: "_3X-hzhiM-2nCPmdRQobFjY",
        WithPointerEvents: "_5uPvePR38OWhnDSFAfVjb",
        RecordingDecorators: "_2FrUVjCRFn__OfoqscThzC",
        ClipDecorators: "_3nQCyfz0pPcX6JDYEf2Joz",
        GameModes: "S91J4nhfddEwfzHHSHHFP",
        DateDecorator: "_2l9rTyxx4vXVq0ybAMXfAD",
        BackgroundTicks: "_2ZhoF776kEHn_v4ZWw3n9T",
        Highlights: "_353kPW0r6Dj7i4bH832LMD",
        Timestamps: "_1EQP_FKeO0NKogEoQW0bme",
        RangeSelector: "H9ZalKqiZp9Qof22ZsVBr",
        SeekScrubber: "_3BJnQe-ovyx2JAEa8fqucA",
        PlayHead: "_3NsP08b3MNThSCwAiH-1bK",
        Thumbnails: "c4-WJwdkSXOz55T2D55lt",
        PositionLeft: "rgWqVDQHU4K8AYTEZeyZ3",
        PositionRight: "_2IxK8JKAENaMQCEesyCa8B",
        RangeCtn: "_2oZ5E5eF41tHUQGKGkg0KW",
        RangeControls: "hBMLo4PgbQJvzaHeW0rqb",
        InactiveRangeCtn: "_2gpTUJXchUexmX_gbU2Vk9",
        RangeControl: "_3GVFtvc9U86t7VgWTdphlo",
        RangeIcon: "_2p3OJez0ffOUDI1_3aC4Jv",
        RangeSelectorCtn: "_2a0WEKuu49hGMyKXRwSPAG",
        Active: "_3pSft3L6I9YfJp6WrWhn7X",
        InactiveSelectedRangeControl: "_3RFz2sP-6kCicYywbJM6BT",
        SelectedRangeMask: "_1-ecZ-hTVOYF-etlyrmi9U",
        Hide: "_3C2yR-vIbnChmog6wm7pj6",
        TrackRangeControls: "_3tMryUIyw9M80nbFzItyAm",
        ActiveControl: "_2E0_BnAfugUs1t46fAGVRc",
        RangeMask: "_1PHxKGDM6fEFr86RAcz0xU",
        FullMask: "_3KOU4Vw3aXGm9BdHzasgPH",
        RangeTooltipSource: "_10C1_wfRkan75GU4TCmT-1",
        RangeTooltip: "_1czVWmDNRNJvqcwTOoZVTd",
        RangeTooltipImage: "_3U4mwXorXC5R6GfigkZIUn",
        TooltipContents: "_1yuqavvxA41MQ9_AwWLe6y",
        SeekTimeContainer: "_28BVxSuSrBgOgoZD4bUlAA",
        StateDescription: "_9bLogD3-GUFv2BcQqODJP",
        TooltipTime: "my3ReFmY6JNsz7liJ30Mb",
      };
    },
    64287: (e) => {
      e.exports = {
        LoadingTimeline: "_1_t3nGfqLmkNrWO3kCXGv7",
        ScrollAndControlsCtn: "_2lDH05uT1tcrtS4hH8iilO",
        GamepadMode: "_3zsRM8gmPfu_P2ZN-gkZYq",
        Controls: "_2W7BcAw5LRESe4quCD4p99",
        TimelineScrollContainer: "_1q6-LAgOVF7QAOp7ViyG3U",
        ContentContainer: "_1s9muLhfkGLGvF7VlNbxZ3",
        AbsoluteLayer: "_3uK4Esci-VnBTx4RRTZJ8T",
        HideOverflow: "_1jtc5gMzOqVdAXZY06a9LR",
        RelativeLayer: "ns-PhidF4LmKNgJIjefeI",
        WithPointerEvents: "eaWC--yyKkJ-Kl4tb7mMg",
        RecordingDecorators: "_1Bij-mkv7FTE3RKYqUtzAA",
        ClipDecorators: "_3YTYrWDx5RScj3F6tOiZdl",
        GameModes: "_1iTzuR6dp2RFuM-NfSm3E8",
        DateDecorator: "Iqluh72d7WyDHpfaFejTs",
        BackgroundTicks: "_2_cUlWqyUX43iK7IS9hv87",
        Highlights: "_3u682yrQUqhoWd9E9uibF-",
        Timestamps: "_2ial0TZcvS6K28QhWy1iw7",
        RangeSelector: "AQt-jw9z2zdLSqYb6K_Z7",
        SeekScrubber: "fxHTiNLLNKW2DA8u3POTL",
        PlayHead: "_33Q4JqC7V-Nfg_zVJZgmoE",
        Thumbnails: "_2b6w42S74JsEi3CJG6nf-X",
        PositionLeft: "_3gQtCqX-TFEHrqrdvhe_nd",
        PositionRight: "_22WPcBHXWrcOCi9q5CAFbz",
        RecordingDecorator: "rhzh6oHumH49cw7TgYju5",
        Clip: "_2g6KsUTAG1NHAa5Ggjtwmy",
        ClipMode: "_2mrXFv27psuQQGH4B9zbwE",
        Manual: "_22e2bD68cxAVh6g3F_F67e",
        RecordingDecoratorClip: "_3-b6nUPviEcMhtythX3aen",
        LiveRecordingBuffer: "_9xzyA7LJfa-DZc_IcP_iI",
        IsLive: "_2fTyhIN2bKWSz_mtnIGVzi",
      };
    },
    90254: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "_2h2w_0bHX8FeLuMBJ-LBb4",
        ScrollAndControlsCtn: "_1EJupGrB1I0ZM-y3rAhxUY",
        GamepadMode: "_2XE34TxcYOeFqiY91vzKsi",
        Controls: "_2s8o8uCCbozVj7QOk1Wplk",
        TimelineScrollContainer: "_1nVuqp-g6-YZ9xC4Tn3MAk",
        ContentContainer: "_31xC-zxCLd2A3MnFJgYWKW",
        AbsoluteLayer: "Ov5VEoFVHW4wK8dNBMRbm",
        HideOverflow: "_3pwlG4bW7EkPcKef3kW4xf",
        RelativeLayer: "_3SywbFYLfqT-1ZGyJhv4_V",
        WithPointerEvents: "F7QDhcdpDKLrHt6pH0QeZ",
        RecordingDecorators: "_1yuLK-c1yVn1olYlwKFfsg",
        ClipDecorators: "_1X5z7Cxez_Pi1SIEQ20CPt",
        GameModes: "_2XHYrCxPkwd63ibzXm8gRk",
        DateDecorator: "_3cfYvXdVMimlZlu80qbr2f",
        BackgroundTicks: "sdaoaS207GZbHTeGkG3NX",
        Highlights: "_2-RwpaVDa8Ysl3w2JNmrDx",
        Timestamps: "_3sY9-oCBtXYzshgn-shEUj",
        RangeSelector: "W6nan8FfMfzBLdjiD9Jpb",
        SeekScrubber: "_1ZJdKiRujT3md8duDVBHFu",
        PlayHead: "_32dftrGKhJlUmLEPDhiB2L",
        Thumbnails: "_2DqP8LaKZ2NsEtcqVar4Ir",
        PositionLeft: "_2D6js9kckUF7J85NpRjKKk",
        PositionRight: "_2vZFHLuXgZoaqErukynZkW",
        PlayheadInteractionCtn: "_2uglQE0hmRIhVyVgfF7QOp",
        ActiveCtn: "kYAHfpZFzP1ncrm4XNMek",
        PlayHeadContainer: "LF77_xJGEEtK-ubK9zyop",
        TooltipSource: "NDxeAhFhXFWjpXH7XAo-v",
        Active: "_1F8CRQeU4eLMvj443m52CJ",
        PlayHeadContent: "_29NxDJiEVsfeNKIgfhGQd",
        PlayHeadCurrentTimeContainer: "_3vGJJy9yGuI88W4j7Oi2y2",
        NoPointer: "lPuBxgLVSh168d9lbljmH",
        TooltipContents: "JjQU1EQ85ImGog5zJ8Uvr",
        SeekTimeContainer: "_1aDRjWlw6upeFxnoF6xaQF",
        StateDescription: "_27VMvuyFw8APTeQiCefzTP",
        TooltipTime: "_2AqZ4n5gE5Wo4VVL8nmzMY",
        RangeCtn: "_2wWUfCO1Ow-Wm5pkmxPVNs",
        RangeControls: "_2XSXTU1wLX0Ylefub3lp32",
        InactiveRangeCtn: "s3jxpCWiNa27h6ne_Eo4Q",
        RangeControl: "_1ka6Rm6peDYdoZHQqCiMZN",
        RangeIcon: "_2g3Hn9pbNSnBHtwPMRt5sB",
        RangeSelectorCtn: "_2a8UIEcktPjqEtq17g-ZdF",
        InactiveSelectedRangeControl: "NXvNd0FldTAqqFPcKlqOH",
        SelectedRangeMask: "_1R6Lr7cGMrHXvM54IZLa-6",
        Hide: "_3ZYRMalvZiiUhgv_dTbgiV",
        TrackRangeControls: "_3HuvEE2Uq7s0X3vaaTXlRX",
        ActiveControl: "_10FA3bJ012ik5ZfWJIZ8LH",
        RangeMask: "_1yjoFI-nbZQgT4CXP5AKIE",
        FullMask: "_1D2FvpB3Y5Jma7skfLWXgK",
        RangeTooltipSource: "_1HiUrGmvcAJWgtm9rQhB1q",
        RangeTooltip: "g0sI5m3pZUo5Z0DarnJ5e",
        RangeTooltipImage: "_1wgYraCJ54V4MySO3kxndW",
        GhostPlayheadCtn: "_33YreXWus27I-gdlNhhTF",
        GhostPlayheadHoverSource: "_266BFu1tEL0Bl_s9mCcs0y",
        GhostPlayhead: "_3pYqa_Yf3LzuwNRpF7K_M4",
        TooltipButtons: "_25UGA0iD02180HPTbrfp-f",
        Button: "_3Ro4jQ5vwzUi4_14L-P27K",
        AddMarker: "_1bYd7toTu5io_NyhRhy4t5",
        GoToClip: "_3JjMgLSA55Et_iZB3SsW2v",
      };
    },
    65772: (e) => {
      e.exports = {
        thumbnailWidth: "320",
        LoadingTimeline: "cu2shW-Pn_rpFg4stHWgj",
        ScrollAndControlsCtn: "_3fdLnf6605Jzia6XWQCLUY",
        GamepadMode: "_1f9SSD2oiOY3RNiy9Lo9iS",
        Controls: "_2Hr2MXcOSzucM75af0ban8",
        TimelineScrollContainer: "_2MYQtgH84VoXhKvUl75v7E",
        ContentContainer: "_1G9MizgZy89oJ9ZOCqp6rL",
        AbsoluteLayer: "_11KRb_nssNkEJfQTiV26BC",
        HideOverflow: "lxqpftYnaxIADFBEU3d58",
        RelativeLayer: "BlUAQgz2gLZ1bN2FsEBeQ",
        WithPointerEvents: "_1ZW1MyijGytlVuGokF3kdB",
        RecordingDecorators: "_2Y_wUIzvTM8vmWtT8BoCHu",
        ClipDecorators: "_1b_Bu6IdHVi7vQmsqz564J",
        GameModes: "_2AlPMeTpVzErNXA4zO6iR2",
        DateDecorator: "_3dKK-iYss2ImDOuqzxzHja",
        BackgroundTicks: "_1X_fqPSSgAbWlfcul4jEAl",
        Highlights: "_3kQiblinmz6ip2unkDmM63",
        Timestamps: "_25-UMedjXGY97DNJWBD63g",
        RangeSelector: "_3ZZBxUQXA0XVvYo3uO4g6K",
        SeekScrubber: "_2aeh68IBHjGg9dAnFp0Mvo",
        PlayHead: "bK9uRZEV0zf1fpSOVi8Np",
        Thumbnails: "_1gZkmkA0l31S2du8U7_TG0",
        PositionLeft: "_3BHh4rFtyrIHsyCNvdF5YX",
        PositionRight: "_3YzGJ-fH2T4YBUdylXtUap",
        TooltipOffset: "UaZofqckhvedj_5hec7Km",
        Overlay: "_30u9sU6ivH1Rzj07292vDe",
        TooltipHitBox: "_1xx2XJoygFj4omTZnPr9zY",
        TooltipContents: "LtcGAaEh2SK-2wYDOfSPR",
        TooltipChildren: "_2RqQ4lEV9AKW7N6cgPHoik",
        TooltipImage: "_2KScPiTjuDpx2SKoaLGxC0",
        Hide: "_3dhcJ_fDO8XUjONQLEhCZj",
        TooltipImageCtn: "_3OvX2YaZ9dsxSzCqbsp7df",
      };
    },
    37151: (e) => {
      e.exports = {
        TimelineContextMenuItem: "_1JOi0rRqMHa2w6oYvYJPzE",
        MenuItem: "_3tt4zR7ffwHTPqFsKF_iO-",
        AddUserMarker: "HkXS0q-DNFAC8mtV9Dp18",
        StartEndClip: "_1bAd69jjrHJ0KZ_9SXphNx",
        ViewClip: "_2ro1z6MJrW93vOY5R-cdVD",
        active: "_332WTyTLZSTH7FPPhcGeTY",
      };
    },
    63073: (e, t, r) => {
      "use strict";
      r.d(t, { Z5: () => Nn, _l: () => Ma, bK: () => Ea });
      var i = r(47427),
        n = r(98425),
        a = r(22688),
        o = r(25630);
      function s(e) {
        return (
          "Minified Redux error #" +
          e +
          "; visit https://redux.js.org/Errors?code=" +
          e +
          " for the full message or use the non-minified dev environment for full errors. "
        );
      }
      var l =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable",
        c = function () {
          return Math.random().toString(36).substring(7).split("").join(".");
        },
        u = {
          INIT: "@@redux/INIT" + c(),
          REPLACE: "@@redux/REPLACE" + c(),
          PROBE_UNKNOWN_ACTION: function () {
            return "@@redux/PROBE_UNKNOWN_ACTION" + c();
          },
        };
      function d(e) {
        if ("object" != typeof e || null === e) return !1;
        for (var t = e; null !== Object.getPrototypeOf(t); )
          t = Object.getPrototypeOf(t);
        return Object.getPrototypeOf(e) === t;
      }
      function m(e, t, r) {
        var i;
        if (
          ("function" == typeof t && "function" == typeof r) ||
          ("function" == typeof r && "function" == typeof arguments[3])
        )
          throw new Error(s(0));
        if (
          ("function" == typeof t && void 0 === r && ((r = t), (t = void 0)),
          void 0 !== r)
        ) {
          if ("function" != typeof r) throw new Error(s(1));
          return r(m)(e, t);
        }
        if ("function" != typeof e) throw new Error(s(2));
        var n = e,
          a = t,
          o = [],
          c = o,
          f = !1;
        function p() {
          c === o && (c = o.slice());
        }
        function g() {
          if (f) throw new Error(s(3));
          return a;
        }
        function b(e) {
          if ("function" != typeof e) throw new Error(s(4));
          if (f) throw new Error(s(5));
          var t = !0;
          return (
            p(),
            c.push(e),
            function () {
              if (t) {
                if (f) throw new Error(s(6));
                (t = !1), p();
                var r = c.indexOf(e);
                c.splice(r, 1), (o = null);
              }
            }
          );
        }
        function h(e) {
          if (!d(e)) throw new Error(s(7));
          if (void 0 === e.type) throw new Error(s(8));
          if (f) throw new Error(s(9));
          try {
            (f = !0), (a = n(a, e));
          } finally {
            f = !1;
          }
          for (var t = (o = c), r = 0; r < t.length; r++) {
            (0, t[r])();
          }
          return e;
        }
        return (
          h({ type: u.INIT }),
          ((i = {
            dispatch: h,
            subscribe: b,
            getState: g,
            replaceReducer: function (e) {
              if ("function" != typeof e) throw new Error(s(10));
              (n = e), h({ type: u.REPLACE });
            },
          })[l] = function () {
            var e,
              t = b;
            return (
              ((e = {
                subscribe: function (e) {
                  if ("object" != typeof e || null === e)
                    throw new Error(s(11));
                  function r() {
                    e.next && e.next(g());
                  }
                  return r(), { unsubscribe: t(r) };
                },
              })[l] = function () {
                return this;
              }),
              e
            );
          }),
          i
        );
      }
      function f(e, t) {
        return function () {
          return t(e.apply(this, arguments));
        };
      }
      function p(e, t) {
        if ("function" == typeof e) return f(e, t);
        if ("object" != typeof e || null === e) throw new Error(s(16));
        var r = {};
        for (var i in e) {
          var n = e[i];
          "function" == typeof n && (r[i] = f(n, t));
        }
        return r;
      }
      function g() {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
          t[r] = arguments[r];
        return 0 === t.length
          ? function (e) {
              return e;
            }
          : 1 === t.length
            ? t[0]
            : t.reduce(function (e, t) {
                return function () {
                  return e(t.apply(void 0, arguments));
                };
              });
      }
      var b = i.createContext(null);
      var h = function (e) {
          e();
        },
        _ = function () {
          return h;
        };
      var S = {
        notify: function () {},
        get: function () {
          return [];
        },
      };
      function v(e, t) {
        var r,
          i = S;
        function n() {
          o.onStateChange && o.onStateChange();
        }
        function a() {
          r ||
            ((r = t ? t.addNestedSub(n) : e.subscribe(n)),
            (i = (function () {
              var e = _(),
                t = null,
                r = null;
              return {
                clear: function () {
                  (t = null), (r = null);
                },
                notify: function () {
                  e(function () {
                    for (var e = t; e; ) e.callback(), (e = e.next);
                  });
                },
                get: function () {
                  for (var e = [], r = t; r; ) e.push(r), (r = r.next);
                  return e;
                },
                subscribe: function (e) {
                  var i = !0,
                    n = (r = { callback: e, next: null, prev: r });
                  return (
                    n.prev ? (n.prev.next = n) : (t = n),
                    function () {
                      i &&
                        null !== t &&
                        ((i = !1),
                        n.next ? (n.next.prev = n.prev) : (r = n.prev),
                        n.prev ? (n.prev.next = n.next) : (t = n.next));
                    }
                  );
                },
              };
            })()));
        }
        var o = {
          addNestedSub: function (e) {
            return a(), i.subscribe(e);
          },
          notifyNestedSubs: function () {
            i.notify();
          },
          handleChangeWrapper: n,
          isSubscribed: function () {
            return Boolean(r);
          },
          trySubscribe: a,
          tryUnsubscribe: function () {
            r && (r(), (r = void 0), i.clear(), (i = S));
          },
          getListeners: function () {
            return i;
          },
        };
        return o;
      }
      var y =
        "undefined" != typeof window &&
        void 0 !== window.document &&
        void 0 !== window.document.createElement
          ? i.useLayoutEffect
          : i.useEffect;
      const M = function (e) {
        var t = e.store,
          r = e.context,
          n = e.children,
          a = (0, i.useMemo)(
            function () {
              var e = v(t);
              return { store: t, subscription: e };
            },
            [t],
          ),
          o = (0, i.useMemo)(
            function () {
              return t.getState();
            },
            [t],
          );
        y(
          function () {
            var e = a.subscription;
            return (
              (e.onStateChange = e.notifyNestedSubs),
              e.trySubscribe(),
              o !== t.getState() && e.notifyNestedSubs(),
              function () {
                e.tryUnsubscribe(), (e.onStateChange = null);
              }
            );
          },
          [a, o],
        );
        var s = r || b;
        return i.createElement(s.Provider, { value: a }, n);
      };
      var T = r(76737),
        B = r(43065),
        R = r.n(B),
        E = r(14753),
        w = [
          "getDisplayName",
          "methodName",
          "renderCountProp",
          "shouldHandleStateChanges",
          "storeKey",
          "withRef",
          "forwardRef",
          "context",
        ],
        C = ["reactReduxForwardedRef"],
        G = [],
        P = [null, null];
      function I(e, t) {
        var r = e[1];
        return [t.payload, r + 1];
      }
      function D(e, t, r) {
        y(function () {
          return e.apply(void 0, t);
        }, r);
      }
      function O(e, t, r, i, n, a, o) {
        (e.current = i),
          (t.current = n),
          (r.current = !1),
          a.current && ((a.current = null), o());
      }
      function F(e, t, r, i, n, a, o, s, l, c) {
        if (e) {
          var u = !1,
            d = null,
            m = function () {
              if (!u) {
                var e,
                  r,
                  m = t.getState();
                try {
                  e = i(m, n.current);
                } catch (e) {
                  (r = e), (d = e);
                }
                r || (d = null),
                  e === a.current
                    ? o.current || l()
                    : ((a.current = e),
                      (s.current = e),
                      (o.current = !0),
                      c({ type: "STORE_UPDATED", payload: { error: r } }));
              }
            };
          (r.onStateChange = m), r.trySubscribe(), m();
          return function () {
            if (((u = !0), r.tryUnsubscribe(), (r.onStateChange = null), d))
              throw d;
          };
        }
      }
      var z = function () {
        return [null, 0];
      };
      function x(e, t) {
        void 0 === t && (t = {});
        var r = t,
          n = r.getDisplayName,
          o =
            void 0 === n
              ? function (e) {
                  return "ConnectAdvanced(" + e + ")";
                }
              : n,
          s = r.methodName,
          l = void 0 === s ? "connectAdvanced" : s,
          c = r.renderCountProp,
          u = void 0 === c ? void 0 : c,
          d = r.shouldHandleStateChanges,
          m = void 0 === d || d,
          f = r.storeKey,
          p = void 0 === f ? "store" : f,
          g = (r.withRef, r.forwardRef),
          h = void 0 !== g && g,
          _ = r.context,
          S = void 0 === _ ? b : _,
          y = (0, T.Z)(r, w),
          M = S;
        return function (t) {
          var r = t.displayName || t.name || "Component",
            n = o(r),
            s = (0, a.Z)({}, y, {
              getDisplayName: o,
              methodName: l,
              renderCountProp: u,
              shouldHandleStateChanges: m,
              storeKey: p,
              displayName: n,
              wrappedComponentName: r,
              WrappedComponent: t,
            }),
            c = y.pure;
          var d = c
            ? i.useMemo
            : function (e) {
                return e();
              };
          function f(r) {
            var n = (0, i.useMemo)(
                function () {
                  var e = r.reactReduxForwardedRef,
                    t = (0, T.Z)(r, C);
                  return [r.context, e, t];
                },
                [r],
              ),
              o = n[0],
              l = n[1],
              c = n[2],
              u = (0, i.useMemo)(
                function () {
                  return o &&
                    o.Consumer &&
                    (0, E.isContextConsumer)(i.createElement(o.Consumer, null))
                    ? o
                    : M;
                },
                [o, M],
              ),
              f = (0, i.useContext)(u),
              p =
                Boolean(r.store) &&
                Boolean(r.store.getState) &&
                Boolean(r.store.dispatch);
            Boolean(f) && Boolean(f.store);
            var g = p ? r.store : f.store,
              b = (0, i.useMemo)(
                function () {
                  return (function (t) {
                    return e(t.dispatch, s);
                  })(g);
                },
                [g],
              ),
              h = (0, i.useMemo)(
                function () {
                  if (!m) return P;
                  var e = v(g, p ? null : f.subscription),
                    t = e.notifyNestedSubs.bind(e);
                  return [e, t];
                },
                [g, p, f],
              ),
              _ = h[0],
              S = h[1],
              y = (0, i.useMemo)(
                function () {
                  return p ? f : (0, a.Z)({}, f, { subscription: _ });
                },
                [p, f, _],
              ),
              B = (0, i.useReducer)(I, G, z),
              R = B[0][0],
              w = B[1];
            if (R && R.error) throw R.error;
            var x = (0, i.useRef)(),
              A = (0, i.useRef)(c),
              W = (0, i.useRef)(),
              k = (0, i.useRef)(!1),
              N = d(
                function () {
                  return W.current && c === A.current
                    ? W.current
                    : b(g.getState(), c);
                },
                [g, R, c],
              );
            D(O, [A, x, k, c, N, W, S]),
              D(F, [m, g, _, b, A, x, k, W, S, w], [g, _, b]);
            var L = (0, i.useMemo)(
              function () {
                return i.createElement(t, (0, a.Z)({}, N, { ref: l }));
              },
              [l, t, N],
            );
            return (0, i.useMemo)(
              function () {
                return m ? i.createElement(u.Provider, { value: y }, L) : L;
              },
              [u, L, y],
            );
          }
          var g = c ? i.memo(f) : f;
          if (
            ((g.WrappedComponent = t), (g.displayName = f.displayName = n), h)
          ) {
            var b = i.forwardRef(function (e, t) {
              return i.createElement(
                g,
                (0, a.Z)({}, e, { reactReduxForwardedRef: t }),
              );
            });
            return (b.displayName = n), (b.WrappedComponent = t), R()(b, t);
          }
          return R()(g, t);
        };
      }
      function A(e, t) {
        return e === t
          ? 0 !== e || 0 !== t || 1 / e == 1 / t
          : e != e && t != t;
      }
      function W(e, t) {
        if (A(e, t)) return !0;
        if (
          "object" != typeof e ||
          null === e ||
          "object" != typeof t ||
          null === t
        )
          return !1;
        var r = Object.keys(e),
          i = Object.keys(t);
        if (r.length !== i.length) return !1;
        for (var n = 0; n < r.length; n++)
          if (
            !Object.prototype.hasOwnProperty.call(t, r[n]) ||
            !A(e[r[n]], t[r[n]])
          )
            return !1;
        return !0;
      }
      function k(e) {
        return function (t, r) {
          var i = e(t, r);
          function n() {
            return i;
          }
          return (n.dependsOnOwnProps = !1), n;
        };
      }
      function N(e) {
        return null !== e.dependsOnOwnProps && void 0 !== e.dependsOnOwnProps
          ? Boolean(e.dependsOnOwnProps)
          : 1 !== e.length;
      }
      function L(e, t) {
        return function (t, r) {
          r.displayName;
          var i = function (e, t) {
            return i.dependsOnOwnProps ? i.mapToProps(e, t) : i.mapToProps(e);
          };
          return (
            (i.dependsOnOwnProps = !0),
            (i.mapToProps = function (t, r) {
              (i.mapToProps = e), (i.dependsOnOwnProps = N(e));
              var n = i(t, r);
              return (
                "function" == typeof n &&
                  ((i.mapToProps = n),
                  (i.dependsOnOwnProps = N(n)),
                  (n = i(t, r))),
                n
              );
            }),
            i
          );
        };
      }
      const X = [
        function (e) {
          return "function" == typeof e ? L(e) : void 0;
        },
        function (e) {
          return e
            ? void 0
            : k(function (e) {
                return { dispatch: e };
              });
        },
        function (e) {
          return e && "object" == typeof e
            ? k(function (t) {
                return (function (e, t) {
                  var r = {},
                    i = function (i) {
                      var n = e[i];
                      "function" == typeof n &&
                        (r[i] = function () {
                          return t(n.apply(void 0, arguments));
                        });
                    };
                  for (var n in e) i(n);
                  return r;
                })(e, t);
              })
            : void 0;
        },
      ];
      const U = [
        function (e) {
          return "function" == typeof e ? L(e) : void 0;
        },
        function (e) {
          return e
            ? void 0
            : k(function () {
                return {};
              });
        },
      ];
      function j(e, t, r) {
        return (0, a.Z)({}, r, e, t);
      }
      const H = [
        function (e) {
          return "function" == typeof e
            ? (function (e) {
                return function (t, r) {
                  r.displayName;
                  var i,
                    n = r.pure,
                    a = r.areMergedPropsEqual,
                    o = !1;
                  return function (t, r, s) {
                    var l = e(t, r, s);
                    return (
                      o ? (n && a(l, i)) || (i = l) : ((o = !0), (i = l)), i
                    );
                  };
                };
              })(e)
            : void 0;
        },
        function (e) {
          return e
            ? void 0
            : function () {
                return j;
              };
        },
      ];
      var V = [
        "initMapStateToProps",
        "initMapDispatchToProps",
        "initMergeProps",
      ];
      function q(e, t, r, i) {
        return function (n, a) {
          return r(e(n, a), t(i, a), a);
        };
      }
      function Z(e, t, r, i, n) {
        var a,
          o,
          s,
          l,
          c,
          u = n.areStatesEqual,
          d = n.areOwnPropsEqual,
          m = n.areStatePropsEqual,
          f = !1;
        function p(n, f) {
          var p,
            g,
            b = !d(f, o),
            h = !u(n, a, f, o);
          return (
            (a = n),
            (o = f),
            b && h
              ? ((s = e(a, o)),
                t.dependsOnOwnProps && (l = t(i, o)),
                (c = r(s, l, o)))
              : b
                ? (e.dependsOnOwnProps && (s = e(a, o)),
                  t.dependsOnOwnProps && (l = t(i, o)),
                  (c = r(s, l, o)))
                : h
                  ? ((p = e(a, o)),
                    (g = !m(p, s)),
                    (s = p),
                    g && (c = r(s, l, o)),
                    c)
                  : c
          );
        }
        return function (n, u) {
          return f
            ? p(n, u)
            : ((s = e((a = n), (o = u))),
              (l = t(i, o)),
              (c = r(s, l, o)),
              (f = !0),
              c);
        };
      }
      function Y(e, t) {
        var r = t.initMapStateToProps,
          i = t.initMapDispatchToProps,
          n = t.initMergeProps,
          a = (0, T.Z)(t, V),
          o = r(e, a),
          s = i(e, a),
          l = n(e, a);
        return (a.pure ? Z : q)(o, s, l, e, a);
      }
      var J = [
        "pure",
        "areStatesEqual",
        "areOwnPropsEqual",
        "areStatePropsEqual",
        "areMergedPropsEqual",
      ];
      function K(e, t, r) {
        for (var i = t.length - 1; i >= 0; i--) {
          var n = t[i](e);
          if (n) return n;
        }
        return function (t, i) {
          throw new Error(
            "Invalid value of type " +
              typeof e +
              " for " +
              r +
              " argument when connecting component " +
              i.wrappedComponentName +
              ".",
          );
        };
      }
      function Q(e, t) {
        return e === t;
      }
      function $(e) {
        var t = void 0 === e ? {} : e,
          r = t.connectHOC,
          i = void 0 === r ? x : r,
          n = t.mapStateToPropsFactories,
          o = void 0 === n ? U : n,
          s = t.mapDispatchToPropsFactories,
          l = void 0 === s ? X : s,
          c = t.mergePropsFactories,
          u = void 0 === c ? H : c,
          d = t.selectorFactory,
          m = void 0 === d ? Y : d;
        return function (e, t, r, n) {
          void 0 === n && (n = {});
          var s = n,
            c = s.pure,
            d = void 0 === c || c,
            f = s.areStatesEqual,
            p = void 0 === f ? Q : f,
            g = s.areOwnPropsEqual,
            b = void 0 === g ? W : g,
            h = s.areStatePropsEqual,
            _ = void 0 === h ? W : h,
            S = s.areMergedPropsEqual,
            v = void 0 === S ? W : S,
            y = (0, T.Z)(s, J),
            M = K(e, o, "mapStateToProps"),
            B = K(t, l, "mapDispatchToProps"),
            R = K(r, u, "mergeProps");
          return i(
            m,
            (0, a.Z)(
              {
                methodName: "connect",
                getDisplayName: function (e) {
                  return "Connect(" + e + ")";
                },
                shouldHandleStateChanges: Boolean(e),
                initMapStateToProps: M,
                initMapDispatchToProps: B,
                initMergeProps: R,
                pure: d,
                areStatesEqual: p,
                areOwnPropsEqual: b,
                areStatePropsEqual: _,
                areMergedPropsEqual: v,
              },
              y,
            ),
          );
        };
      }
      const ee = $();
      var te,
        re = r(42287);
      function ie(e, t) {
        var r = (0, i.useState)(function () {
            return { inputs: t, result: e() };
          })[0],
          n = (0, i.useRef)(!0),
          a = (0, i.useRef)(r),
          o =
            n.current ||
            Boolean(
              t &&
                a.current.inputs &&
                (function (e, t) {
                  if (e.length !== t.length) return !1;
                  for (var r = 0; r < e.length; r++)
                    if (e[r] !== t[r]) return !1;
                  return !0;
                })(t, a.current.inputs),
            )
              ? a.current
              : { inputs: t, result: e() };
        return (
          (0, i.useEffect)(
            function () {
              (n.current = !1), (a.current = o);
            },
            [o],
          ),
          o.result
        );
      }
      (te = re.unstable_batchedUpdates), (h = te);
      var ne = ie,
        ae = function (e, t) {
          return ie(function () {
            return e;
          }, t);
        },
        oe = r(7716),
        se = function (e) {
          var t = e.top,
            r = e.right,
            i = e.bottom,
            n = e.left;
          return {
            top: t,
            right: r,
            bottom: i,
            left: n,
            width: r - n,
            height: i - t,
            x: n,
            y: t,
            center: { x: (r + n) / 2, y: (i + t) / 2 },
          };
        },
        le = function (e, t) {
          return {
            top: e.top - t.top,
            left: e.left - t.left,
            bottom: e.bottom + t.bottom,
            right: e.right + t.right,
          };
        },
        ce = function (e, t) {
          return {
            top: e.top + t.top,
            left: e.left + t.left,
            bottom: e.bottom - t.bottom,
            right: e.right - t.right,
          };
        },
        ue = { top: 0, right: 0, bottom: 0, left: 0 },
        de = function (e) {
          var t = e.borderBox,
            r = e.margin,
            i = void 0 === r ? ue : r,
            n = e.border,
            a = void 0 === n ? ue : n,
            o = e.padding,
            s = void 0 === o ? ue : o,
            l = se(le(t, i)),
            c = se(ce(t, a)),
            u = se(ce(c, s));
          return {
            marginBox: l,
            borderBox: se(t),
            paddingBox: c,
            contentBox: u,
            margin: i,
            border: a,
            padding: s,
          };
        },
        me = function (e) {
          var t = e.slice(0, -2);
          if ("px" !== e.slice(-2)) return 0;
          var r = Number(t);
          return isNaN(r) && (0, oe.Z)(!1), r;
        },
        fe = function (e, t) {
          var r,
            i,
            n = e.borderBox,
            a = e.border,
            o = e.margin,
            s = e.padding,
            l =
              ((i = t),
              {
                top: (r = n).top + i.y,
                left: r.left + i.x,
                bottom: r.bottom + i.y,
                right: r.right + i.x,
              });
          return de({ borderBox: l, border: a, margin: o, padding: s });
        },
        pe = function (e, t) {
          return (
            void 0 === t &&
              (t = { x: window.pageXOffset, y: window.pageYOffset }),
            fe(e, t)
          );
        },
        ge = function (e, t) {
          var r = {
              top: me(t.marginTop),
              right: me(t.marginRight),
              bottom: me(t.marginBottom),
              left: me(t.marginLeft),
            },
            i = {
              top: me(t.paddingTop),
              right: me(t.paddingRight),
              bottom: me(t.paddingBottom),
              left: me(t.paddingLeft),
            },
            n = {
              top: me(t.borderTopWidth),
              right: me(t.borderRightWidth),
              bottom: me(t.borderBottomWidth),
              left: me(t.borderLeftWidth),
            };
          return de({ borderBox: e, margin: r, padding: i, border: n });
        },
        be = function (e) {
          var t = e.getBoundingClientRect(),
            r = window.getComputedStyle(e);
          return ge(t, r);
        },
        he =
          Number.isNaN ||
          function (e) {
            return "number" == typeof e && e != e;
          };
      function _e(e, t) {
        if (e.length !== t.length) return !1;
        for (var r = 0; r < e.length; r++)
          if (((i = e[r]), (n = t[r]), !(i === n || (he(i) && he(n)))))
            return !1;
        var i, n;
        return !0;
      }
      const Se = function (e, t) {
        var r;
        void 0 === t && (t = _e);
        var i,
          n = [],
          a = !1;
        return function () {
          for (var o = [], s = 0; s < arguments.length; s++)
            o[s] = arguments[s];
          return (
            (a && r === this && t(o, n)) ||
              ((i = e.apply(this, o)), (a = !0), (r = this), (n = o)),
            i
          );
        };
      };
      const ve = function (e) {
        var t = [],
          r = null,
          i = function () {
            for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
              n[a] = arguments[a];
            (t = n),
              r ||
                (r = requestAnimationFrame(function () {
                  (r = null), e.apply(void 0, t);
                }));
          };
        return (
          (i.cancel = function () {
            r && (cancelAnimationFrame(r), (r = null));
          }),
          i
        );
      };
      function ye(e, t) {}
      ye.bind(null, "warn"), ye.bind(null, "error");
      function Me() {}
      function Te(e, t, r) {
        var i = t.map(function (t) {
          var i = (function (e, t) {
            return (0, a.Z)({}, e, {}, t);
          })(r, t.options);
          return (
            e.addEventListener(t.eventName, t.fn, i),
            function () {
              e.removeEventListener(t.eventName, t.fn, i);
            }
          );
        });
        return function () {
          i.forEach(function (e) {
            e();
          });
        };
      }
      var Be = !0,
        Re = "Invariant failed";
      function Ee(e) {
        this.message = e;
      }
      function we(e, t) {
        if (!e) throw new Ee(Be ? Re : Re + ": " + (t || ""));
      }
      Ee.prototype.toString = function () {
        return this.message;
      };
      var Ce = (function (e) {
          function t() {
            for (
              var t, r = arguments.length, i = new Array(r), n = 0;
              n < r;
              n++
            )
              i[n] = arguments[n];
            return (
              ((t = e.call.apply(e, [this].concat(i)) || this).callbacks =
                null),
              (t.unbind = Me),
              (t.onWindowError = function (e) {
                var r = t.getCallbacks();
                r.isDragging() && r.tryAbort(),
                  e.error instanceof Ee && e.preventDefault();
              }),
              (t.getCallbacks = function () {
                if (!t.callbacks)
                  throw new Error(
                    "Unable to find AppCallbacks in <ErrorBoundary/>",
                  );
                return t.callbacks;
              }),
              (t.setCallbacks = function (e) {
                t.callbacks = e;
              }),
              t
            );
          }
          (0, n.Z)(t, e);
          var r = t.prototype;
          return (
            (r.componentDidMount = function () {
              this.unbind = Te(window, [
                { eventName: "error", fn: this.onWindowError },
              ]);
            }),
            (r.componentDidCatch = function (e) {
              if (!(e instanceof Ee)) throw e;
              this.setState({});
            }),
            (r.componentWillUnmount = function () {
              this.unbind();
            }),
            (r.render = function () {
              return this.props.children(this.setCallbacks);
            }),
            t
          );
        })(i.Component),
        Ge = function (e) {
          return e + 1;
        },
        Pe = function (e, t) {
          var r = e.droppableId === t.droppableId,
            i = Ge(e.index),
            n = Ge(t.index);
          return r
            ? "\n      You have moved the item from position " +
                i +
                "\n      to position " +
                n +
                "\n    "
            : "\n    You have moved the item from position " +
                i +
                "\n    in list " +
                e.droppableId +
                "\n    to list " +
                t.droppableId +
                "\n    in position " +
                n +
                "\n  ";
        },
        Ie = function (e, t, r) {
          return t.droppableId === r.droppableId
            ? "\n      The item " +
                e +
                "\n      has been combined with " +
                r.draggableId
            : "\n      The item " +
                e +
                "\n      in list " +
                t.droppableId +
                "\n      has been combined with " +
                r.draggableId +
                "\n      in list " +
                r.droppableId +
                "\n    ";
        },
        De = function (e) {
          return (
            "\n  The item has returned to its starting position\n  of " +
            Ge(e.index) +
            "\n"
          );
        },
        Oe = {
          dragHandleUsageInstructions:
            "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n",
          onDragStart: function (e) {
            return (
              "\n  You have lifted an item in position " +
              Ge(e.source.index) +
              "\n"
            );
          },
          onDragUpdate: function (e) {
            var t = e.destination;
            if (t) return Pe(e.source, t);
            var r = e.combine;
            return r
              ? Ie(e.draggableId, e.source, r)
              : "You are over an area that cannot be dropped on";
          },
          onDragEnd: function (e) {
            if ("CANCEL" === e.reason)
              return (
                "\n      Movement cancelled.\n      " + De(e.source) + "\n    "
              );
            var t = e.destination,
              r = e.combine;
            return t
              ? "\n      You have dropped the item.\n      " +
                  Pe(e.source, t) +
                  "\n    "
              : r
                ? "\n      You have dropped the item.\n      " +
                  Ie(e.draggableId, e.source, r) +
                  "\n    "
                : "\n    The item has been dropped while not over a drop area.\n    " +
                  De(e.source) +
                  "\n  ";
          },
        },
        Fe = { x: 0, y: 0 },
        ze = function (e, t) {
          return { x: e.x + t.x, y: e.y + t.y };
        },
        xe = function (e, t) {
          return { x: e.x - t.x, y: e.y - t.y };
        },
        Ae = function (e, t) {
          return e.x === t.x && e.y === t.y;
        },
        We = function (e) {
          return { x: 0 !== e.x ? -e.x : 0, y: 0 !== e.y ? -e.y : 0 };
        },
        ke = function (e, t, r) {
          var i;
          return (
            void 0 === r && (r = 0),
            ((i = {})[e] = t),
            (i["x" === e ? "y" : "x"] = r),
            i
          );
        },
        Ne = function (e, t) {
          return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
        },
        Le = function (e, t) {
          return Math.min.apply(
            Math,
            t.map(function (t) {
              return Ne(e, t);
            }),
          );
        },
        Xe = function (e) {
          return function (t) {
            return { x: e(t.x), y: e(t.y) };
          };
        },
        Ue = function (e, t) {
          return {
            top: e.top + t.y,
            left: e.left + t.x,
            bottom: e.bottom + t.y,
            right: e.right + t.x,
          };
        },
        je = function (e) {
          return [
            { x: e.left, y: e.top },
            { x: e.right, y: e.top },
            { x: e.left, y: e.bottom },
            { x: e.right, y: e.bottom },
          ];
        },
        He = function (e, t) {
          return t && t.shouldClipSubject
            ? (function (e, t) {
                var r = se({
                  top: Math.max(t.top, e.top),
                  right: Math.min(t.right, e.right),
                  bottom: Math.min(t.bottom, e.bottom),
                  left: Math.max(t.left, e.left),
                });
                return r.width <= 0 || r.height <= 0 ? null : r;
              })(t.pageMarginBox, e)
            : se(e);
        },
        Ve = function (e) {
          var t = e.page,
            r = e.withPlaceholder,
            i = e.axis,
            n = e.frame,
            o = (function (e, t) {
              return t ? Ue(e, t.scroll.diff.displacement) : e;
            })(t.marginBox, n),
            s = (function (e, t, r) {
              var i;
              return r && r.increasedBy
                ? (0, a.Z)(
                    {},
                    e,
                    (((i = {})[t.end] = e[t.end] + r.increasedBy[t.line]), i),
                  )
                : e;
            })(o, i, r);
          return { page: t, withPlaceholder: r, active: He(s, n) };
        },
        qe = function (e, t) {
          e.frame || we(!1);
          var r = e.frame,
            i = xe(t, r.scroll.initial),
            n = We(i),
            o = (0, a.Z)({}, r, {
              scroll: {
                initial: r.scroll.initial,
                current: t,
                diff: { value: i, displacement: n },
                max: r.scroll.max,
              },
            }),
            s = Ve({
              page: e.subject.page,
              withPlaceholder: e.subject.withPlaceholder,
              axis: e.axis,
              frame: o,
            });
          return (0, a.Z)({}, e, { frame: o, subject: s });
        };
      function Ze(e) {
        return Object.values
          ? Object.values(e)
          : Object.keys(e).map(function (t) {
              return e[t];
            });
      }
      function Ye(e, t) {
        if (e.findIndex) return e.findIndex(t);
        for (var r = 0; r < e.length; r++) if (t(e[r])) return r;
        return -1;
      }
      function Je(e, t) {
        if (e.find) return e.find(t);
        var r = Ye(e, t);
        return -1 !== r ? e[r] : void 0;
      }
      function Ke(e) {
        return Array.prototype.slice.call(e);
      }
      var Qe = Se(function (e) {
          return e.reduce(function (e, t) {
            return (e[t.descriptor.id] = t), e;
          }, {});
        }),
        $e = Se(function (e) {
          return e.reduce(function (e, t) {
            return (e[t.descriptor.id] = t), e;
          }, {});
        }),
        et = Se(function (e) {
          return Ze(e);
        }),
        tt = Se(function (e) {
          return Ze(e);
        }),
        rt = Se(function (e, t) {
          var r = tt(t)
            .filter(function (t) {
              return e === t.descriptor.droppableId;
            })
            .sort(function (e, t) {
              return e.descriptor.index - t.descriptor.index;
            });
          return r;
        });
      function it(e) {
        return e.at && "REORDER" === e.at.type ? e.at.destination : null;
      }
      function nt(e) {
        return e.at && "COMBINE" === e.at.type ? e.at.combine : null;
      }
      var at = Se(function (e, t) {
          return t.filter(function (t) {
            return t.descriptor.id !== e.descriptor.id;
          });
        }),
        ot = function (e, t) {
          return e.descriptor.droppableId === t.descriptor.id;
        },
        st = { point: Fe, value: 0 },
        lt = { invisible: {}, visible: {}, all: [] },
        ct = { displaced: lt, displacedBy: st, at: null },
        ut = function (e, t) {
          return function (r) {
            return e <= r && r <= t;
          };
        },
        dt = function (e) {
          var t = ut(e.top, e.bottom),
            r = ut(e.left, e.right);
          return function (i) {
            if (t(i.top) && t(i.bottom) && r(i.left) && r(i.right)) return !0;
            var n = t(i.top) || t(i.bottom),
              a = r(i.left) || r(i.right);
            if (n && a) return !0;
            var o = i.top < e.top && i.bottom > e.bottom,
              s = i.left < e.left && i.right > e.right;
            return !(!o || !s) || (o && a) || (s && n);
          };
        },
        mt = function (e) {
          var t = ut(e.top, e.bottom),
            r = ut(e.left, e.right);
          return function (e) {
            return t(e.top) && t(e.bottom) && r(e.left) && r(e.right);
          };
        },
        ft = {
          direction: "vertical",
          line: "y",
          crossAxisLine: "x",
          start: "top",
          end: "bottom",
          size: "height",
          crossAxisStart: "left",
          crossAxisEnd: "right",
          crossAxisSize: "width",
        },
        pt = {
          direction: "horizontal",
          line: "x",
          crossAxisLine: "y",
          start: "left",
          end: "right",
          size: "width",
          crossAxisStart: "top",
          crossAxisEnd: "bottom",
          crossAxisSize: "height",
        },
        gt = function (e) {
          var t = e.target,
            r = e.destination,
            i = e.viewport,
            n = e.withDroppableDisplacement,
            a = e.isVisibleThroughFrameFn,
            o = n
              ? (function (e, t) {
                  var r = t.frame ? t.frame.scroll.diff.displacement : Fe;
                  return Ue(e, r);
                })(t, r)
              : t;
          return (
            (function (e, t, r) {
              return !!t.subject.active && r(t.subject.active)(e);
            })(o, r, a) &&
            (function (e, t, r) {
              return r(t)(e);
            })(o, i, a)
          );
        },
        bt = function (e) {
          return gt((0, a.Z)({}, e, { isVisibleThroughFrameFn: dt }));
        },
        ht = function (e) {
          return gt((0, a.Z)({}, e, { isVisibleThroughFrameFn: mt }));
        },
        _t = function (e, t, r) {
          if ("boolean" == typeof r) return r;
          if (!t) return !0;
          var i = t.invisible,
            n = t.visible;
          if (i[e]) return !1;
          var a = n[e];
          return !a || a.shouldAnimate;
        };
      function St(e) {
        var t = e.afterDragging,
          r = e.destination,
          i = e.displacedBy,
          n = e.viewport,
          a = e.forceShouldAnimate,
          o = e.last;
        return t.reduce(
          function (e, t) {
            var s = (function (e, t) {
                var r = e.page.marginBox,
                  i = { top: t.point.y, right: 0, bottom: 0, left: t.point.x };
                return se(le(r, i));
              })(t, i),
              l = t.descriptor.id;
            if (
              (e.all.push(l),
              !bt({
                target: s,
                destination: r,
                viewport: n,
                withDroppableDisplacement: !0,
              }))
            )
              return (e.invisible[t.descriptor.id] = !0), e;
            var c = { draggableId: l, shouldAnimate: _t(l, o, a) };
            return (e.visible[l] = c), e;
          },
          { all: [], visible: {}, invisible: {} },
        );
      }
      function vt(e) {
        var t = e.insideDestination,
          r = e.inHomeList,
          i = e.displacedBy,
          n = e.destination,
          a = (function (e, t) {
            if (!e.length) return 0;
            var r = e[e.length - 1].descriptor.index;
            return t.inHomeList ? r : r + 1;
          })(t, { inHomeList: r });
        return {
          displaced: lt,
          displacedBy: i,
          at: {
            type: "REORDER",
            destination: { droppableId: n.descriptor.id, index: a },
          },
        };
      }
      function yt(e) {
        var t = e.draggable,
          r = e.insideDestination,
          i = e.destination,
          n = e.viewport,
          a = e.displacedBy,
          o = e.last,
          s = e.index,
          l = e.forceShouldAnimate,
          c = ot(t, i);
        if (null == s)
          return vt({
            insideDestination: r,
            inHomeList: c,
            displacedBy: a,
            destination: i,
          });
        var u = Je(r, function (e) {
          return e.descriptor.index === s;
        });
        if (!u)
          return vt({
            insideDestination: r,
            inHomeList: c,
            displacedBy: a,
            destination: i,
          });
        var d = at(t, r),
          m = r.indexOf(u);
        return {
          displaced: St({
            afterDragging: d.slice(m),
            destination: i,
            displacedBy: a,
            last: o,
            viewport: n.frame,
            forceShouldAnimate: l,
          }),
          displacedBy: a,
          at: {
            type: "REORDER",
            destination: { droppableId: i.descriptor.id, index: s },
          },
        };
      }
      function Mt(e, t) {
        return Boolean(t.effected[e]);
      }
      var Tt = function (e) {
          var t = e.isMovingForward,
            r = e.isInHomeList,
            i = e.draggable,
            n = e.draggables,
            a = e.destination,
            o = e.insideDestination,
            s = e.previousImpact,
            l = e.viewport,
            c = e.afterCritical,
            u = s.at;
          if ((u || we(!1), "REORDER" === u.type)) {
            var d = (function (e) {
              var t = e.isMovingForward,
                r = e.isInHomeList,
                i = e.insideDestination,
                n = e.location;
              if (!i.length) return null;
              var a = n.index,
                o = t ? a + 1 : a - 1,
                s = i[0].descriptor.index,
                l = i[i.length - 1].descriptor.index;
              return o < s || o > (r ? l : l + 1) ? null : o;
            })({
              isMovingForward: t,
              isInHomeList: r,
              location: u.destination,
              insideDestination: o,
            });
            return null == d
              ? null
              : yt({
                  draggable: i,
                  insideDestination: o,
                  destination: a,
                  viewport: l,
                  last: s.displaced,
                  displacedBy: s.displacedBy,
                  index: d,
                });
          }
          var m = (function (e) {
            var t = e.isMovingForward,
              r = e.destination,
              i = e.draggables,
              n = e.combine,
              a = e.afterCritical;
            if (!r.isCombineEnabled) return null;
            var o = n.draggableId,
              s = i[o].descriptor.index;
            return Mt(o, a) ? (t ? s : s - 1) : t ? s + 1 : s;
          })({
            isMovingForward: t,
            destination: a,
            displaced: s.displaced,
            draggables: n,
            combine: u.combine,
            afterCritical: c,
          });
          return null == m
            ? null
            : yt({
                draggable: i,
                insideDestination: o,
                destination: a,
                viewport: l,
                last: s.displaced,
                displacedBy: s.displacedBy,
                index: m,
              });
        },
        Bt = function (e) {
          var t = e.afterCritical,
            r = e.impact,
            i = e.draggables,
            n = nt(r);
          n || we(!1);
          var a = n.draggableId,
            o = i[a].page.borderBox.center,
            s = (function (e) {
              var t = e.displaced,
                r = e.afterCritical,
                i = e.combineWith,
                n = e.displacedBy,
                a = Boolean(t.visible[i] || t.invisible[i]);
              return Mt(i, r) ? (a ? Fe : We(n.point)) : a ? n.point : Fe;
            })({
              displaced: r.displaced,
              afterCritical: t,
              combineWith: a,
              displacedBy: r.displacedBy,
            });
          return ze(o, s);
        },
        Rt = function (e, t) {
          return t.margin[e.start] + t.borderBox[e.size] / 2;
        },
        Et = function (e, t, r) {
          return (
            t[e.crossAxisStart] +
            r.margin[e.crossAxisStart] +
            r.borderBox[e.crossAxisSize] / 2
          );
        },
        wt = function (e) {
          var t = e.axis,
            r = e.moveRelativeTo,
            i = e.isMoving;
          return ke(
            t.line,
            r.marginBox[t.end] + Rt(t, i),
            Et(t, r.marginBox, i),
          );
        },
        Ct = function (e) {
          var t = e.axis,
            r = e.moveRelativeTo,
            i = e.isMoving;
          return ke(
            t.line,
            r.marginBox[t.start] -
              (function (e, t) {
                return t.margin[e.end] + t.borderBox[e.size] / 2;
              })(t, i),
            Et(t, r.marginBox, i),
          );
        },
        Gt = function (e) {
          var t = e.impact,
            r = e.draggable,
            i = e.draggables,
            n = e.droppable,
            a = e.afterCritical,
            o = rt(n.descriptor.id, i),
            s = r.page,
            l = n.axis;
          if (!o.length)
            return (function (e) {
              var t = e.axis,
                r = e.moveInto,
                i = e.isMoving;
              return ke(
                t.line,
                r.contentBox[t.start] + Rt(t, i),
                Et(t, r.contentBox, i),
              );
            })({ axis: l, moveInto: n.page, isMoving: s });
          var c = t.displaced,
            u = t.displacedBy,
            d = c.all[0];
          if (d) {
            var m = i[d];
            if (Mt(d, a))
              return Ct({ axis: l, moveRelativeTo: m.page, isMoving: s });
            var f = fe(m.page, u.point);
            return Ct({ axis: l, moveRelativeTo: f, isMoving: s });
          }
          var p = o[o.length - 1];
          if (p.descriptor.id === r.descriptor.id) return s.borderBox.center;
          if (Mt(p.descriptor.id, a)) {
            var g = fe(p.page, We(a.displacedBy.point));
            return wt({ axis: l, moveRelativeTo: g, isMoving: s });
          }
          return wt({ axis: l, moveRelativeTo: p.page, isMoving: s });
        },
        Pt = function (e, t) {
          var r = e.frame;
          return r ? ze(t, r.scroll.diff.displacement) : t;
        },
        It = function (e) {
          var t = (function (e) {
              var t = e.impact,
                r = e.draggable,
                i = e.droppable,
                n = e.draggables,
                a = e.afterCritical,
                o = r.page.borderBox.center,
                s = t.at;
              return i && s
                ? "REORDER" === s.type
                  ? Gt({
                      impact: t,
                      draggable: r,
                      draggables: n,
                      droppable: i,
                      afterCritical: a,
                    })
                  : Bt({ impact: t, draggables: n, afterCritical: a })
                : o;
            })(e),
            r = e.droppable;
          return r ? Pt(r, t) : t;
        },
        Dt = function (e, t) {
          var r = xe(t, e.scroll.initial),
            i = We(r);
          return {
            frame: se({
              top: t.y,
              bottom: t.y + e.frame.height,
              left: t.x,
              right: t.x + e.frame.width,
            }),
            scroll: {
              initial: e.scroll.initial,
              max: e.scroll.max,
              current: t,
              diff: { value: r, displacement: i },
            },
          };
        };
      function Ot(e, t) {
        return e.map(function (e) {
          return t[e];
        });
      }
      var Ft = function (e) {
          var t = e.pageBorderBoxCenter,
            r = e.draggable,
            i = (function (e, t) {
              return ze(e.scroll.diff.displacement, t);
            })(e.viewport, t),
            n = xe(i, r.page.borderBox.center);
          return ze(r.client.borderBox.center, n);
        },
        zt = function (e) {
          var t = e.draggable,
            r = e.destination,
            i = e.newPageBorderBoxCenter,
            n = e.viewport,
            o = e.withDroppableDisplacement,
            s = e.onlyOnMainAxis,
            l = void 0 !== s && s,
            c = xe(i, t.page.borderBox.center),
            u = {
              target: Ue(t.page.borderBox, c),
              destination: r,
              withDroppableDisplacement: o,
              viewport: n,
            };
          return l
            ? (function (e) {
                return gt(
                  (0, a.Z)({}, e, {
                    isVisibleThroughFrameFn:
                      ((t = e.destination.axis),
                      function (e) {
                        var r = ut(e.top, e.bottom),
                          i = ut(e.left, e.right);
                        return function (e) {
                          return t === ft
                            ? r(e.top) && r(e.bottom)
                            : i(e.left) && i(e.right);
                        };
                      }),
                  }),
                );
                var t;
              })(u)
            : ht(u);
        },
        xt = function (e) {
          var t = e.isMovingForward,
            r = e.draggable,
            i = e.destination,
            n = e.draggables,
            o = e.previousImpact,
            s = e.viewport,
            l = e.previousPageBorderBoxCenter,
            c = e.previousClientSelection,
            u = e.afterCritical;
          if (!i.isEnabled) return null;
          var d = rt(i.descriptor.id, n),
            m = ot(r, i),
            f =
              (function (e) {
                var t = e.isMovingForward,
                  r = e.draggable,
                  i = e.destination,
                  n = e.insideDestination,
                  o = e.previousImpact;
                if (!i.isCombineEnabled) return null;
                if (!it(o)) return null;
                function s(e) {
                  var t = {
                    type: "COMBINE",
                    combine: { draggableId: e, droppableId: i.descriptor.id },
                  };
                  return (0, a.Z)({}, o, { at: t });
                }
                var l = o.displaced.all,
                  c = l.length ? l[0] : null;
                if (t) return c ? s(c) : null;
                var u = at(r, n);
                if (!c)
                  return u.length ? s(u[u.length - 1].descriptor.id) : null;
                var d = Ye(u, function (e) {
                  return e.descriptor.id === c;
                });
                -1 === d && we(!1);
                var m = d - 1;
                return m < 0 ? null : s(u[m].descriptor.id);
              })({
                isMovingForward: t,
                draggable: r,
                destination: i,
                insideDestination: d,
                previousImpact: o,
              }) ||
              Tt({
                isMovingForward: t,
                isInHomeList: m,
                draggable: r,
                draggables: n,
                destination: i,
                insideDestination: d,
                previousImpact: o,
                viewport: s,
                afterCritical: u,
              });
          if (!f) return null;
          var p = It({
            impact: f,
            draggable: r,
            droppable: i,
            draggables: n,
            afterCritical: u,
          });
          if (
            zt({
              draggable: r,
              destination: i,
              newPageBorderBoxCenter: p,
              viewport: s.frame,
              withDroppableDisplacement: !1,
              onlyOnMainAxis: !0,
            })
          )
            return {
              clientSelection: Ft({
                pageBorderBoxCenter: p,
                draggable: r,
                viewport: s,
              }),
              impact: f,
              scrollJumpRequest: null,
            };
          var g = xe(p, l),
            b = (function (e) {
              var t = e.impact,
                r = e.viewport,
                i = e.destination,
                n = e.draggables,
                o = e.maxScrollChange,
                s = Dt(r, ze(r.scroll.current, o)),
                l = i.frame ? qe(i, ze(i.frame.scroll.current, o)) : i,
                c = t.displaced,
                u = St({
                  afterDragging: Ot(c.all, n),
                  destination: i,
                  displacedBy: t.displacedBy,
                  viewport: s.frame,
                  last: c,
                  forceShouldAnimate: !1,
                }),
                d = St({
                  afterDragging: Ot(c.all, n),
                  destination: l,
                  displacedBy: t.displacedBy,
                  viewport: r.frame,
                  last: c,
                  forceShouldAnimate: !1,
                }),
                m = {},
                f = {},
                p = [c, u, d];
              return (
                c.all.forEach(function (e) {
                  var t = (function (e, t) {
                    for (var r = 0; r < t.length; r++) {
                      var i = t[r].visible[e];
                      if (i) return i;
                    }
                    return null;
                  })(e, p);
                  t ? (f[e] = t) : (m[e] = !0);
                }),
                (0, a.Z)({}, t, {
                  displaced: { all: c.all, invisible: m, visible: f },
                })
              );
            })({
              impact: f,
              viewport: s,
              destination: i,
              draggables: n,
              maxScrollChange: g,
            });
          return { clientSelection: c, impact: b, scrollJumpRequest: g };
        },
        At = function (e) {
          var t = e.subject.active;
          return t || we(!1), t;
        },
        Wt = function (e, t) {
          var r = e.page.borderBox.center;
          return Mt(e.descriptor.id, t) ? xe(r, t.displacedBy.point) : r;
        },
        kt = function (e, t) {
          var r = e.page.borderBox;
          return Mt(e.descriptor.id, t) ? Ue(r, We(t.displacedBy.point)) : r;
        },
        Nt = Se(function (e, t) {
          var r = t[e.line];
          return { value: r, point: ke(e.line, r) };
        }),
        Lt = function (e, t) {
          return (0, a.Z)({}, e, {
            scroll: (0, a.Z)({}, e.scroll, { max: t }),
          });
        },
        Xt = function (e, t, r) {
          var i = e.frame;
          ot(t, e) && we(!1), e.subject.withPlaceholder && we(!1);
          var n = Nt(e.axis, t.displaceBy).point,
            o = (function (e, t, r) {
              var i = e.axis;
              if ("virtual" === e.descriptor.mode) return ke(i.line, t[i.line]);
              var n = e.subject.page.contentBox[i.size],
                a =
                  rt(e.descriptor.id, r).reduce(function (e, t) {
                    return e + t.client.marginBox[i.size];
                  }, 0) +
                  t[i.line] -
                  n;
              return a <= 0 ? null : ke(i.line, a);
            })(e, n, r),
            s = {
              placeholderSize: n,
              increasedBy: o,
              oldFrameMaxScroll: e.frame ? e.frame.scroll.max : null,
            };
          if (!i) {
            var l = Ve({
              page: e.subject.page,
              withPlaceholder: s,
              axis: e.axis,
              frame: e.frame,
            });
            return (0, a.Z)({}, e, { subject: l });
          }
          var c = o ? ze(i.scroll.max, o) : i.scroll.max,
            u = Lt(i, c),
            d = Ve({
              page: e.subject.page,
              withPlaceholder: s,
              axis: e.axis,
              frame: u,
            });
          return (0, a.Z)({}, e, { subject: d, frame: u });
        },
        Ut = function (e) {
          var t = e.isMovingForward,
            r = e.previousPageBorderBoxCenter,
            i = e.draggable,
            n = e.isOver,
            a = e.draggables,
            o = e.droppables,
            s = e.viewport,
            l = e.afterCritical,
            c = (function (e) {
              var t = e.isMovingForward,
                r = e.pageBorderBoxCenter,
                i = e.source,
                n = e.droppables,
                a = e.viewport,
                o = i.subject.active;
              if (!o) return null;
              var s = i.axis,
                l = ut(o[s.start], o[s.end]),
                c = et(n)
                  .filter(function (e) {
                    return e !== i;
                  })
                  .filter(function (e) {
                    return e.isEnabled;
                  })
                  .filter(function (e) {
                    return Boolean(e.subject.active);
                  })
                  .filter(function (e) {
                    return dt(a.frame)(At(e));
                  })
                  .filter(function (e) {
                    var r = At(e);
                    return t
                      ? o[s.crossAxisEnd] < r[s.crossAxisEnd]
                      : r[s.crossAxisStart] < o[s.crossAxisStart];
                  })
                  .filter(function (e) {
                    var t = At(e),
                      r = ut(t[s.start], t[s.end]);
                    return (
                      l(t[s.start]) ||
                      l(t[s.end]) ||
                      r(o[s.start]) ||
                      r(o[s.end])
                    );
                  })
                  .sort(function (e, r) {
                    var i = At(e)[s.crossAxisStart],
                      n = At(r)[s.crossAxisStart];
                    return t ? i - n : n - i;
                  })
                  .filter(function (e, t, r) {
                    return (
                      At(e)[s.crossAxisStart] === At(r[0])[s.crossAxisStart]
                    );
                  });
              if (!c.length) return null;
              if (1 === c.length) return c[0];
              var u = c.filter(function (e) {
                return ut(At(e)[s.start], At(e)[s.end])(r[s.line]);
              });
              return 1 === u.length
                ? u[0]
                : u.length > 1
                  ? u.sort(function (e, t) {
                      return At(e)[s.start] - At(t)[s.start];
                    })[0]
                  : c.sort(function (e, t) {
                      var i = Le(r, je(At(e))),
                        n = Le(r, je(At(t)));
                      return i !== n ? i - n : At(e)[s.start] - At(t)[s.start];
                    })[0];
            })({
              isMovingForward: t,
              pageBorderBoxCenter: r,
              source: n,
              droppables: o,
              viewport: s,
            });
          if (!c) return null;
          var u = rt(c.descriptor.id, a),
            d = (function (e) {
              var t = e.pageBorderBoxCenter,
                r = e.viewport,
                i = e.destination,
                n = e.insideDestination,
                a = e.afterCritical,
                o = n
                  .filter(function (e) {
                    return ht({
                      target: kt(e, a),
                      destination: i,
                      viewport: r.frame,
                      withDroppableDisplacement: !0,
                    });
                  })
                  .sort(function (e, r) {
                    var n = Ne(t, Pt(i, Wt(e, a))),
                      o = Ne(t, Pt(i, Wt(r, a)));
                    return n < o
                      ? -1
                      : o < n
                        ? 1
                        : e.descriptor.index - r.descriptor.index;
                  });
              return o[0] || null;
            })({
              pageBorderBoxCenter: r,
              viewport: s,
              destination: c,
              insideDestination: u,
              afterCritical: l,
            }),
            m = (function (e) {
              var t = e.previousPageBorderBoxCenter,
                r = e.moveRelativeTo,
                i = e.insideDestination,
                n = e.draggable,
                a = e.draggables,
                o = e.destination,
                s = e.viewport,
                l = e.afterCritical;
              if (!r) {
                if (i.length) return null;
                var c = {
                    displaced: lt,
                    displacedBy: st,
                    at: {
                      type: "REORDER",
                      destination: { droppableId: o.descriptor.id, index: 0 },
                    },
                  },
                  u = It({
                    impact: c,
                    draggable: n,
                    droppable: o,
                    draggables: a,
                    afterCritical: l,
                  }),
                  d = ot(n, o) ? o : Xt(o, n, a);
                return zt({
                  draggable: n,
                  destination: d,
                  newPageBorderBoxCenter: u,
                  viewport: s.frame,
                  withDroppableDisplacement: !1,
                  onlyOnMainAxis: !0,
                })
                  ? c
                  : null;
              }
              var m,
                f = Boolean(
                  t[o.axis.line] <= r.page.borderBox.center[o.axis.line],
                ),
                p =
                  ((m = r.descriptor.index),
                  r.descriptor.id === n.descriptor.id || f ? m : m + 1),
                g = Nt(o.axis, n.displaceBy);
              return yt({
                draggable: n,
                insideDestination: i,
                destination: o,
                viewport: s,
                displacedBy: g,
                last: lt,
                index: p,
              });
            })({
              previousPageBorderBoxCenter: r,
              destination: c,
              draggable: i,
              draggables: a,
              moveRelativeTo: d,
              insideDestination: u,
              viewport: s,
              afterCritical: l,
            });
          if (!m) return null;
          var f = It({
            impact: m,
            draggable: i,
            droppable: c,
            draggables: a,
            afterCritical: l,
          });
          return {
            clientSelection: Ft({
              pageBorderBoxCenter: f,
              draggable: i,
              viewport: s,
            }),
            impact: m,
            scrollJumpRequest: null,
          };
        },
        jt = function (e) {
          var t = e.at;
          return t
            ? "REORDER" === t.type
              ? t.destination.droppableId
              : t.combine.droppableId
            : null;
        },
        Ht = function (e) {
          var t = e.state,
            r = e.type,
            i = (function (e, t) {
              var r = jt(e);
              return r ? t[r] : null;
            })(t.impact, t.dimensions.droppables),
            n = Boolean(i),
            a = t.dimensions.droppables[t.critical.droppable.id],
            o = i || a,
            s = o.axis.direction,
            l =
              ("vertical" === s && ("MOVE_UP" === r || "MOVE_DOWN" === r)) ||
              ("horizontal" === s && ("MOVE_LEFT" === r || "MOVE_RIGHT" === r));
          if (l && !n) return null;
          var c = "MOVE_DOWN" === r || "MOVE_RIGHT" === r,
            u = t.dimensions.draggables[t.critical.draggable.id],
            d = t.current.page.borderBoxCenter,
            m = t.dimensions,
            f = m.draggables,
            p = m.droppables;
          return l
            ? xt({
                isMovingForward: c,
                previousPageBorderBoxCenter: d,
                draggable: u,
                destination: o,
                draggables: f,
                viewport: t.viewport,
                previousClientSelection: t.current.client.selection,
                previousImpact: t.impact,
                afterCritical: t.afterCritical,
              })
            : Ut({
                isMovingForward: c,
                previousPageBorderBoxCenter: d,
                draggable: u,
                isOver: o,
                draggables: f,
                droppables: p,
                viewport: t.viewport,
                afterCritical: t.afterCritical,
              });
        };
      function Vt(e) {
        return "DRAGGING" === e.phase || "COLLECTING" === e.phase;
      }
      function qt(e) {
        var t = ut(e.top, e.bottom),
          r = ut(e.left, e.right);
        return function (e) {
          return t(e.y) && r(e.x);
        };
      }
      function Zt(e) {
        var t = e.pageBorderBox,
          r = e.draggable,
          i = e.droppables,
          n = et(i).filter(function (e) {
            if (!e.isEnabled) return !1;
            var r,
              i,
              n = e.subject.active;
            if (!n) return !1;
            if (
              ((i = n),
              !(
                (r = t).left < i.right &&
                r.right > i.left &&
                r.top < i.bottom &&
                r.bottom > i.top
              ))
            )
              return !1;
            if (qt(n)(t.center)) return !0;
            var a = e.axis,
              o = n.center[a.crossAxisLine],
              s = t[a.crossAxisStart],
              l = t[a.crossAxisEnd],
              c = ut(n[a.crossAxisStart], n[a.crossAxisEnd]),
              u = c(s),
              d = c(l);
            return (!u && !d) || (u ? s < o : l > o);
          });
        return n.length
          ? 1 === n.length
            ? n[0].descriptor.id
            : (function (e) {
                var t = e.pageBorderBox,
                  r = e.draggable,
                  i = e.candidates,
                  n = r.page.borderBox.center,
                  a = i
                    .map(function (e) {
                      var r = e.axis,
                        i = ke(
                          e.axis.line,
                          t.center[r.line],
                          e.page.borderBox.center[r.crossAxisLine],
                        );
                      return { id: e.descriptor.id, distance: Ne(n, i) };
                    })
                    .sort(function (e, t) {
                      return t.distance - e.distance;
                    });
                return a[0] ? a[0].id : null;
              })({ pageBorderBox: t, draggable: r, candidates: n })
          : null;
      }
      var Yt = function (e, t) {
        return se(Ue(e, t));
      };
      function Jt(e) {
        var t = e.displaced,
          r = e.id;
        return Boolean(t.visible[r] || t.invisible[r]);
      }
      var Kt = function (e) {
          var t = e.pageOffset,
            r = e.draggable,
            i = e.draggables,
            n = e.droppables,
            a = e.previousImpact,
            o = e.viewport,
            s = e.afterCritical,
            l = Yt(r.page.borderBox, t),
            c = Zt({ pageBorderBox: l, draggable: r, droppables: n });
          if (!c) return ct;
          var u = n[c],
            d = rt(u.descriptor.id, i),
            m = (function (e, t) {
              var r = e.frame;
              return r ? Yt(t, r.scroll.diff.value) : t;
            })(u, l);
          return (
            (function (e) {
              var t = e.draggable,
                r = e.pageBorderBoxWithDroppableScroll,
                i = e.previousImpact,
                n = e.destination,
                a = e.insideDestination,
                o = e.afterCritical;
              if (!n.isCombineEnabled) return null;
              var s = n.axis,
                l = Nt(n.axis, t.displaceBy),
                c = l.value,
                u = r[s.start],
                d = r[s.end],
                m = Je(at(t, a), function (e) {
                  var t = e.descriptor.id,
                    r = e.page.borderBox,
                    n = r[s.size] / 4,
                    a = Mt(t, o),
                    l = Jt({ displaced: i.displaced, id: t });
                  return a
                    ? l
                      ? d > r[s.start] + n && d < r[s.end] - n
                      : u > r[s.start] - c + n && u < r[s.end] - c - n
                    : l
                      ? d > r[s.start] + c + n && d < r[s.end] + c - n
                      : u > r[s.start] + n && u < r[s.end] - n;
                });
              return m
                ? {
                    displacedBy: l,
                    displaced: i.displaced,
                    at: {
                      type: "COMBINE",
                      combine: {
                        draggableId: m.descriptor.id,
                        droppableId: n.descriptor.id,
                      },
                    },
                  }
                : null;
            })({
              pageBorderBoxWithDroppableScroll: m,
              draggable: r,
              previousImpact: a,
              destination: u,
              insideDestination: d,
              afterCritical: s,
            }) ||
            (function (e) {
              var t = e.pageBorderBoxWithDroppableScroll,
                r = e.draggable,
                i = e.destination,
                n = e.insideDestination,
                a = e.last,
                o = e.viewport,
                s = e.afterCritical,
                l = i.axis,
                c = Nt(i.axis, r.displaceBy),
                u = c.value,
                d = t[l.start],
                m = t[l.end],
                f = (function (e) {
                  var t = e.draggable,
                    r = e.closest,
                    i = e.inHomeList;
                  return r
                    ? i && r.descriptor.index > t.descriptor.index
                      ? r.descriptor.index - 1
                      : r.descriptor.index
                    : null;
                })({
                  draggable: r,
                  closest: Je(at(r, n), function (e) {
                    var t = e.descriptor.id,
                      r = e.page.borderBox.center[l.line],
                      i = Mt(t, s),
                      n = Jt({ displaced: a, id: t });
                    return i
                      ? n
                        ? m <= r
                        : d < r - u
                      : n
                        ? m <= r + u
                        : d < r;
                  }),
                  inHomeList: ot(r, i),
                });
              return yt({
                draggable: r,
                insideDestination: n,
                destination: i,
                viewport: o,
                last: a,
                displacedBy: c,
                index: f,
              });
            })({
              pageBorderBoxWithDroppableScroll: m,
              draggable: r,
              destination: u,
              insideDestination: d,
              last: a.displaced,
              viewport: o,
              afterCritical: s,
            })
          );
        },
        Qt = function (e, t) {
          var r;
          return (0, a.Z)({}, e, (((r = {})[t.descriptor.id] = t), r));
        },
        $t = function (e) {
          var t = e.previousImpact,
            r = e.impact,
            i = e.droppables,
            n = jt(t),
            o = jt(r);
          if (!n) return i;
          if (n === o) return i;
          var s = i[n];
          if (!s.subject.withPlaceholder) return i;
          var l = (function (e) {
            var t = e.subject.withPlaceholder;
            t || we(!1);
            var r = e.frame;
            if (!r) {
              var i = Ve({
                page: e.subject.page,
                axis: e.axis,
                frame: null,
                withPlaceholder: null,
              });
              return (0, a.Z)({}, e, { subject: i });
            }
            var n = t.oldFrameMaxScroll;
            n || we(!1);
            var o = Lt(r, n),
              s = Ve({
                page: e.subject.page,
                axis: e.axis,
                frame: o,
                withPlaceholder: null,
              });
            return (0, a.Z)({}, e, { subject: s, frame: o });
          })(s);
          return Qt(i, l);
        },
        er = function (e) {
          var t = e.state,
            r = e.clientSelection,
            i = e.dimensions,
            n = e.viewport,
            o = e.impact,
            s = e.scrollJumpRequest,
            l = n || t.viewport,
            c = i || t.dimensions,
            u = r || t.current.client.selection,
            d = xe(u, t.initial.client.selection),
            m = {
              offset: d,
              selection: u,
              borderBoxCenter: ze(t.initial.client.borderBoxCenter, d),
            },
            f = {
              selection: ze(m.selection, l.scroll.current),
              borderBoxCenter: ze(m.borderBoxCenter, l.scroll.current),
              offset: ze(m.offset, l.scroll.diff.value),
            },
            p = { client: m, page: f };
          if ("COLLECTING" === t.phase)
            return (0, a.Z)({ phase: "COLLECTING" }, t, {
              dimensions: c,
              viewport: l,
              current: p,
            });
          var g = c.draggables[t.critical.draggable.id],
            b =
              o ||
              Kt({
                pageOffset: f.offset,
                draggable: g,
                draggables: c.draggables,
                droppables: c.droppables,
                previousImpact: t.impact,
                viewport: l,
                afterCritical: t.afterCritical,
              }),
            h = (function (e) {
              var t = e.draggable,
                r = e.draggables,
                i = e.droppables,
                n = e.previousImpact,
                a = e.impact,
                o = $t({ previousImpact: n, impact: a, droppables: i }),
                s = jt(a);
              if (!s) return o;
              var l = i[s];
              if (ot(t, l)) return o;
              if (l.subject.withPlaceholder) return o;
              var c = Xt(l, t, r);
              return Qt(o, c);
            })({
              draggable: g,
              impact: b,
              previousImpact: t.impact,
              draggables: c.draggables,
              droppables: c.droppables,
            });
          return (0, a.Z)({}, t, {
            current: p,
            dimensions: { draggables: c.draggables, droppables: h },
            impact: b,
            viewport: l,
            scrollJumpRequest: s || null,
            forceShouldAnimate: !s && null,
          });
        };
      var tr = function (e) {
          var t = e.impact,
            r = e.viewport,
            i = e.draggables,
            n = e.destination,
            o = e.forceShouldAnimate,
            s = t.displaced,
            l = (function (e, t) {
              return e.map(function (e) {
                return t[e];
              });
            })(s.all, i),
            c = St({
              afterDragging: l,
              destination: n,
              displacedBy: t.displacedBy,
              viewport: r.frame,
              forceShouldAnimate: o,
              last: s,
            });
          return (0, a.Z)({}, t, { displaced: c });
        },
        rr = function (e) {
          var t = e.impact,
            r = e.draggable,
            i = e.droppable,
            n = e.draggables,
            a = e.viewport,
            o = e.afterCritical,
            s = It({
              impact: t,
              draggable: r,
              draggables: n,
              droppable: i,
              afterCritical: o,
            });
          return Ft({ pageBorderBoxCenter: s, draggable: r, viewport: a });
        },
        ir = function (e) {
          var t = e.state,
            r = e.dimensions,
            i = e.viewport;
          "SNAP" !== t.movementMode && we(!1);
          var n = t.impact,
            a = i || t.viewport,
            o = r || t.dimensions,
            s = o.draggables,
            l = o.droppables,
            c = s[t.critical.draggable.id],
            u = jt(n);
          u || we(!1);
          var d = l[u],
            m = tr({ impact: n, viewport: a, destination: d, draggables: s }),
            f = rr({
              impact: m,
              draggable: c,
              droppable: d,
              draggables: s,
              viewport: a,
              afterCritical: t.afterCritical,
            });
          return er({
            impact: m,
            clientSelection: f,
            state: t,
            dimensions: o,
            viewport: a,
          });
        },
        nr = function (e) {
          var t = e.draggable,
            r = e.home,
            i = e.draggables,
            n = e.viewport,
            a = Nt(r.axis, t.displaceBy),
            o = rt(r.descriptor.id, i),
            s = o.indexOf(t);
          -1 === s && we(!1);
          var l,
            c = o.slice(s + 1),
            u = c.reduce(function (e, t) {
              return (e[t.descriptor.id] = !0), e;
            }, {}),
            d = {
              inVirtualList: "virtual" === r.descriptor.mode,
              displacedBy: a,
              effected: u,
            };
          return {
            impact: {
              displaced: St({
                afterDragging: c,
                destination: r,
                displacedBy: a,
                last: null,
                viewport: n.frame,
                forceShouldAnimate: !1,
              }),
              displacedBy: a,
              at: {
                type: "REORDER",
                destination:
                  ((l = t.descriptor),
                  { index: l.index, droppableId: l.droppableId }),
              },
            },
            afterCritical: d,
          };
        },
        ar = function (e) {
          0;
        },
        or = function (e) {
          0;
        },
        sr = function (e) {
          var t = e.additions,
            r = e.updatedDroppables,
            i = e.viewport,
            n = i.scroll.diff.value;
          return t.map(function (e) {
            var t = e.descriptor.droppableId,
              o = (function (e) {
                var t = e.frame;
                return t || we(!1), t;
              })(r[t]),
              s = o.scroll.diff.value,
              l = (function (e) {
                var t = e.draggable,
                  r = e.offset,
                  i = e.initialWindowScroll,
                  n = fe(t.client, r),
                  o = pe(n, i);
                return (0, a.Z)({}, t, {
                  placeholder: (0, a.Z)({}, t.placeholder, { client: n }),
                  client: n,
                  page: o,
                });
              })({
                draggable: e,
                offset: ze(n, s),
                initialWindowScroll: i.scroll.initial,
              });
            return l;
          });
        },
        lr = function (e) {
          return "SNAP" === e.movementMode;
        },
        cr = function (e, t, r) {
          var i = (function (e, t) {
            return {
              draggables: e.draggables,
              droppables: Qt(e.droppables, t),
            };
          })(e.dimensions, t);
          return !lr(e) || r
            ? er({ state: e, dimensions: i })
            : ir({ state: e, dimensions: i });
        };
      function ur(e) {
        return e.isDragging && "SNAP" === e.movementMode
          ? (0, a.Z)({ phase: "DRAGGING" }, e, { scrollJumpRequest: null })
          : e;
      }
      var dr = { phase: "IDLE", completed: null, shouldFlush: !1 },
        mr = function (e, t) {
          if ((void 0 === e && (e = dr), "FLUSH" === t.type))
            return (0, a.Z)({}, dr, { shouldFlush: !0 });
          if ("INITIAL_PUBLISH" === t.type) {
            "IDLE" !== e.phase && we(!1);
            var r = t.payload,
              i = r.critical,
              n = r.clientSelection,
              o = r.viewport,
              s = r.dimensions,
              l = r.movementMode,
              c = s.draggables[i.draggable.id],
              u = s.droppables[i.droppable.id],
              d = {
                selection: n,
                borderBoxCenter: c.client.borderBox.center,
                offset: Fe,
              },
              m = {
                client: d,
                page: {
                  selection: ze(d.selection, o.scroll.initial),
                  borderBoxCenter: ze(d.selection, o.scroll.initial),
                  offset: ze(d.selection, o.scroll.diff.value),
                },
              },
              f = et(s.droppables).every(function (e) {
                return !e.isFixedOnPage;
              }),
              p = nr({
                draggable: c,
                home: u,
                draggables: s.draggables,
                viewport: o,
              }),
              g = p.impact;
            return {
              phase: "DRAGGING",
              isDragging: !0,
              critical: i,
              movementMode: l,
              dimensions: s,
              initial: m,
              current: m,
              isWindowScrollAllowed: f,
              impact: g,
              afterCritical: p.afterCritical,
              onLiftImpact: g,
              viewport: o,
              scrollJumpRequest: null,
              forceShouldAnimate: null,
            };
          }
          if ("COLLECTION_STARTING" === t.type)
            return "COLLECTING" === e.phase || "DROP_PENDING" === e.phase
              ? e
              : ("DRAGGING" !== e.phase && we(!1),
                (0, a.Z)({ phase: "COLLECTING" }, e, { phase: "COLLECTING" }));
          if ("PUBLISH_WHILE_DRAGGING" === t.type)
            return (
              "COLLECTING" !== e.phase && "DROP_PENDING" !== e.phase && we(!1),
              (function (e) {
                var t = e.state,
                  r = e.published;
                ar();
                var i = r.modified.map(function (e) {
                    var r = t.dimensions.droppables[e.droppableId];
                    return qe(r, e.scroll);
                  }),
                  n = (0, a.Z)({}, t.dimensions.droppables, {}, Qe(i)),
                  o = $e(
                    sr({
                      additions: r.additions,
                      updatedDroppables: n,
                      viewport: t.viewport,
                    }),
                  ),
                  s = (0, a.Z)({}, t.dimensions.draggables, {}, o);
                r.removals.forEach(function (e) {
                  delete s[e];
                });
                var l = { droppables: n, draggables: s },
                  c = jt(t.impact),
                  u = c ? l.droppables[c] : null,
                  d = l.draggables[t.critical.draggable.id],
                  m = l.droppables[t.critical.droppable.id],
                  f = nr({
                    draggable: d,
                    home: m,
                    draggables: s,
                    viewport: t.viewport,
                  }),
                  p = f.impact,
                  g = f.afterCritical,
                  b = u && u.isCombineEnabled ? t.impact : p,
                  h = Kt({
                    pageOffset: t.current.page.offset,
                    draggable: l.draggables[t.critical.draggable.id],
                    draggables: l.draggables,
                    droppables: l.droppables,
                    previousImpact: b,
                    viewport: t.viewport,
                    afterCritical: g,
                  });
                or();
                var _ = (0, a.Z)({ phase: "DRAGGING" }, t, {
                  phase: "DRAGGING",
                  impact: h,
                  onLiftImpact: p,
                  dimensions: l,
                  afterCritical: g,
                  forceShouldAnimate: !1,
                });
                return "COLLECTING" === t.phase
                  ? _
                  : (0, a.Z)({ phase: "DROP_PENDING" }, _, {
                      phase: "DROP_PENDING",
                      reason: t.reason,
                      isWaiting: !1,
                    });
              })({ state: e, published: t.payload })
            );
          if ("MOVE" === t.type) {
            if ("DROP_PENDING" === e.phase) return e;
            Vt(e) || we(!1);
            var b = t.payload.client;
            return Ae(b, e.current.client.selection)
              ? e
              : er({
                  state: e,
                  clientSelection: b,
                  impact: lr(e) ? e.impact : null,
                });
          }
          if ("UPDATE_DROPPABLE_SCROLL" === t.type) {
            if ("DROP_PENDING" === e.phase) return ur(e);
            if ("COLLECTING" === e.phase) return ur(e);
            Vt(e) || we(!1);
            var h = t.payload,
              _ = h.id,
              S = h.newScroll,
              v = e.dimensions.droppables[_];
            if (!v) return e;
            var y = qe(v, S);
            return cr(e, y, !1);
          }
          if ("UPDATE_DROPPABLE_IS_ENABLED" === t.type) {
            if ("DROP_PENDING" === e.phase) return e;
            Vt(e) || we(!1);
            var M = t.payload,
              T = M.id,
              B = M.isEnabled,
              R = e.dimensions.droppables[T];
            R || we(!1), R.isEnabled === B && we(!1);
            var E = (0, a.Z)({}, R, { isEnabled: B });
            return cr(e, E, !0);
          }
          if ("UPDATE_DROPPABLE_IS_COMBINE_ENABLED" === t.type) {
            if ("DROP_PENDING" === e.phase) return e;
            Vt(e) || we(!1);
            var w = t.payload,
              C = w.id,
              G = w.isCombineEnabled,
              P = e.dimensions.droppables[C];
            P || we(!1), P.isCombineEnabled === G && we(!1);
            var I = (0, a.Z)({}, P, { isCombineEnabled: G });
            return cr(e, I, !0);
          }
          if ("MOVE_BY_WINDOW_SCROLL" === t.type) {
            if ("DROP_PENDING" === e.phase || "DROP_ANIMATING" === e.phase)
              return e;
            Vt(e) || we(!1), e.isWindowScrollAllowed || we(!1);
            var D = t.payload.newScroll;
            if (Ae(e.viewport.scroll.current, D)) return ur(e);
            var O = Dt(e.viewport, D);
            return lr(e)
              ? ir({ state: e, viewport: O })
              : er({ state: e, viewport: O });
          }
          if ("UPDATE_VIEWPORT_MAX_SCROLL" === t.type) {
            if (!Vt(e)) return e;
            var F = t.payload.maxScroll;
            if (Ae(F, e.viewport.scroll.max)) return e;
            var z = (0, a.Z)({}, e.viewport, {
              scroll: (0, a.Z)({}, e.viewport.scroll, { max: F }),
            });
            return (0, a.Z)({ phase: "DRAGGING" }, e, { viewport: z });
          }
          if (
            "MOVE_UP" === t.type ||
            "MOVE_DOWN" === t.type ||
            "MOVE_LEFT" === t.type ||
            "MOVE_RIGHT" === t.type
          ) {
            if ("COLLECTING" === e.phase || "DROP_PENDING" === e.phase)
              return e;
            "DRAGGING" !== e.phase && we(!1);
            var x = Ht({ state: e, type: t.type });
            return x
              ? er({
                  state: e,
                  impact: x.impact,
                  clientSelection: x.clientSelection,
                  scrollJumpRequest: x.scrollJumpRequest,
                })
              : e;
          }
          if ("DROP_PENDING" === t.type) {
            var A = t.payload.reason;
            return (
              "COLLECTING" !== e.phase && we(!1),
              (0, a.Z)({ phase: "DROP_PENDING" }, e, {
                phase: "DROP_PENDING",
                isWaiting: !0,
                reason: A,
              })
            );
          }
          if ("DROP_ANIMATE" === t.type) {
            var W = t.payload,
              k = W.completed,
              N = W.dropDuration,
              L = W.newHomeClientOffset;
            return (
              "DRAGGING" !== e.phase && "DROP_PENDING" !== e.phase && we(!1),
              {
                phase: "DROP_ANIMATING",
                completed: k,
                dropDuration: N,
                newHomeClientOffset: L,
                dimensions: e.dimensions,
              }
            );
          }
          return "DROP_COMPLETE" === t.type
            ? { phase: "IDLE", completed: t.payload.completed, shouldFlush: !1 }
            : e;
        },
        fr = function (e) {
          return { type: "LIFT", payload: e };
        },
        pr = function (e) {
          return { type: "PUBLISH_WHILE_DRAGGING", payload: e };
        },
        gr = function () {
          return { type: "COLLECTION_STARTING", payload: null };
        },
        br = function (e) {
          return { type: "UPDATE_DROPPABLE_SCROLL", payload: e };
        },
        hr = function (e) {
          return { type: "UPDATE_DROPPABLE_IS_ENABLED", payload: e };
        },
        _r = function (e) {
          return { type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED", payload: e };
        },
        Sr = function (e) {
          return { type: "MOVE", payload: e };
        },
        vr = function () {
          return { type: "MOVE_UP", payload: null };
        },
        yr = function () {
          return { type: "MOVE_DOWN", payload: null };
        },
        Mr = function () {
          return { type: "MOVE_RIGHT", payload: null };
        },
        Tr = function () {
          return { type: "MOVE_LEFT", payload: null };
        },
        Br = function () {
          return { type: "FLUSH", payload: null };
        },
        Rr = function (e) {
          return { type: "DROP_COMPLETE", payload: e };
        },
        Er = function (e) {
          return { type: "DROP", payload: e };
        },
        wr = function () {
          return { type: "DROP_ANIMATION_FINISHED", payload: null };
        };
      var Cr = "cubic-bezier(.2,1,.1,1)",
        Gr = { drop: 0, combining: 0.7 },
        Pr = { drop: 0.75 },
        Ir = 0.2 + "s " + "cubic-bezier(0.2, 0, 0, 1)",
        Dr = {
          fluid: "opacity " + Ir,
          snap: "transform " + Ir + ", opacity " + Ir,
          drop: function (e) {
            var t = e + "s " + Cr;
            return "transform " + t + ", opacity " + t;
          },
          outOfTheWay: "transform " + Ir,
          placeholder: "height " + Ir + ", width " + Ir + ", margin " + Ir,
        },
        Or = function (e) {
          return Ae(e, Fe) ? null : "translate(" + e.x + "px, " + e.y + "px)";
        },
        Fr = {
          moveTo: Or,
          drop: function (e, t) {
            var r = Or(e);
            return r ? (t ? r + " scale(" + Pr.drop + ")" : r) : null;
          },
        },
        zr = 0.33,
        xr = 0.55,
        Ar = xr - zr,
        Wr = function (e) {
          var t = e.getState,
            r = e.dispatch;
          return function (e) {
            return function (i) {
              if ("DROP" === i.type) {
                var n = t(),
                  o = i.payload.reason;
                if ("COLLECTING" !== n.phase) {
                  if ("IDLE" !== n.phase) {
                    "DROP_PENDING" === n.phase && n.isWaiting && we(!1),
                      "DRAGGING" !== n.phase &&
                        "DROP_PENDING" !== n.phase &&
                        we(!1);
                    var s = n.critical,
                      l = n.dimensions,
                      c = l.draggables[n.critical.draggable.id],
                      u = (function (e) {
                        var t = e.draggables,
                          r = e.reason,
                          i = e.lastImpact,
                          n = e.home,
                          o = e.viewport,
                          s = e.onLiftImpact;
                        return i.at && "DROP" === r
                          ? "REORDER" === i.at.type
                            ? { impact: i, didDropInsideDroppable: !0 }
                            : {
                                impact: (0, a.Z)({}, i, { displaced: lt }),
                                didDropInsideDroppable: !0,
                              }
                          : {
                              impact: tr({
                                draggables: t,
                                impact: s,
                                destination: n,
                                viewport: o,
                                forceShouldAnimate: !0,
                              }),
                              didDropInsideDroppable: !1,
                            };
                      })({
                        reason: o,
                        lastImpact: n.impact,
                        afterCritical: n.afterCritical,
                        onLiftImpact: n.onLiftImpact,
                        home: n.dimensions.droppables[n.critical.droppable.id],
                        viewport: n.viewport,
                        draggables: n.dimensions.draggables,
                      }),
                      d = u.impact,
                      m = u.didDropInsideDroppable,
                      f = m ? it(d) : null,
                      p = m ? nt(d) : null,
                      g = {
                        index: s.draggable.index,
                        droppableId: s.droppable.id,
                      },
                      b = {
                        draggableId: c.descriptor.id,
                        type: c.descriptor.type,
                        source: g,
                        reason: o,
                        mode: n.movementMode,
                        destination: f,
                        combine: p,
                      },
                      h = (function (e) {
                        var t = e.impact,
                          r = e.draggable,
                          i = e.dimensions,
                          n = e.viewport,
                          a = e.afterCritical,
                          o = i.draggables,
                          s = i.droppables,
                          l = jt(t),
                          c = l ? s[l] : null,
                          u = s[r.descriptor.droppableId],
                          d = rr({
                            impact: t,
                            draggable: r,
                            draggables: o,
                            afterCritical: a,
                            droppable: c || u,
                            viewport: n,
                          });
                        return xe(d, r.client.borderBox.center);
                      })({
                        impact: d,
                        draggable: c,
                        dimensions: l,
                        viewport: n.viewport,
                        afterCritical: n.afterCritical,
                      }),
                      _ = {
                        critical: n.critical,
                        afterCritical: n.afterCritical,
                        result: b,
                        impact: d,
                      };
                    if (!Ae(n.current.client.offset, h) || Boolean(b.combine)) {
                      var S = (function (e) {
                        var t = e.current,
                          r = e.destination,
                          i = e.reason,
                          n = Ne(t, r);
                        if (n <= 0) return zr;
                        if (n >= 1500) return xr;
                        var a = zr + Ar * (n / 1500);
                        return Number(
                          ("CANCEL" === i ? 0.6 * a : a).toFixed(2),
                        );
                      })({
                        current: n.current.client.offset,
                        destination: h,
                        reason: o,
                      });
                      r(
                        (function (e) {
                          return { type: "DROP_ANIMATE", payload: e };
                        })({
                          newHomeClientOffset: h,
                          dropDuration: S,
                          completed: _,
                        }),
                      );
                    } else r(Rr({ completed: _ }));
                  }
                } else
                  r(
                    (function (e) {
                      return { type: "DROP_PENDING", payload: e };
                    })({ reason: o }),
                  );
              } else e(i);
            };
          };
        },
        kr = function () {
          return { x: window.pageXOffset, y: window.pageYOffset };
        };
      function Nr(e) {
        var t = e.onWindowScroll;
        var r = ve(function () {
            t(kr());
          }),
          i = (function (e) {
            return {
              eventName: "scroll",
              options: { passive: !0, capture: !1 },
              fn: function (t) {
                (t.target !== window && t.target !== window.document) || e();
              },
            };
          })(r),
          n = Me;
        function a() {
          return n !== Me;
        }
        return {
          start: function () {
            a() && we(!1), (n = Te(window, [i]));
          },
          stop: function () {
            a() || we(!1), r.cancel(), n(), (n = Me);
          },
          isActive: a,
        };
      }
      var Lr = function (e) {
          var t = Nr({
            onWindowScroll: function (t) {
              e.dispatch({
                type: "MOVE_BY_WINDOW_SCROLL",
                payload: { newScroll: t },
              });
            },
          });
          return function (e) {
            return function (r) {
              t.isActive() || "INITIAL_PUBLISH" !== r.type || t.start(),
                t.isActive() &&
                  (function (e) {
                    return (
                      "DROP_COMPLETE" === e.type ||
                      "DROP_ANIMATE" === e.type ||
                      "FLUSH" === e.type
                    );
                  })(r) &&
                  t.stop(),
                e(r);
            };
          };
        },
        Xr = function () {
          var e = [];
          return {
            add: function (t) {
              var r = setTimeout(function () {
                  return (function (t) {
                    var r = Ye(e, function (e) {
                      return e.timerId === t;
                    });
                    -1 === r && we(!1), e.splice(r, 1)[0].callback();
                  })(r);
                }),
                i = { timerId: r, callback: t };
              e.push(i);
            },
            flush: function () {
              if (e.length) {
                var t = [].concat(e);
                (e.length = 0),
                  t.forEach(function (e) {
                    clearTimeout(e.timerId), e.callback();
                  });
              }
            },
          };
        },
        Ur = function (e, t) {
          ar(), t(), or();
        },
        jr = function (e, t) {
          return {
            draggableId: e.draggable.id,
            type: e.droppable.type,
            source: { droppableId: e.droppable.id, index: e.draggable.index },
            mode: t,
          };
        },
        Hr = function (e, t, r, i) {
          if (e) {
            var n = (function (e) {
              var t = !1,
                r = !1,
                i = setTimeout(function () {
                  r = !0;
                }),
                n = function (n) {
                  t || r || ((t = !0), e(n), clearTimeout(i));
                };
              return (
                (n.wasCalled = function () {
                  return t;
                }),
                n
              );
            })(r);
            e(t, { announce: n }), n.wasCalled() || r(i(t));
          } else r(i(t));
        },
        Vr = function (e, t) {
          var r = (function (e, t) {
            var r = Xr(),
              i = null,
              n = function (r) {
                i || we(!1),
                  (i = null),
                  Ur(0, function () {
                    return Hr(e().onDragEnd, r, t, Oe.onDragEnd);
                  });
              };
            return {
              beforeCapture: function (t, r) {
                i && we(!1),
                  Ur(0, function () {
                    var i = e().onBeforeCapture;
                    i && i({ draggableId: t, mode: r });
                  });
              },
              beforeStart: function (t, r) {
                i && we(!1),
                  Ur(0, function () {
                    var i = e().onBeforeDragStart;
                    i && i(jr(t, r));
                  });
              },
              start: function (n, a) {
                i && we(!1);
                var o = jr(n, a);
                (i = {
                  mode: a,
                  lastCritical: n,
                  lastLocation: o.source,
                  lastCombine: null,
                }),
                  r.add(function () {
                    Ur(0, function () {
                      return Hr(e().onDragStart, o, t, Oe.onDragStart);
                    });
                  });
              },
              update: function (n, o) {
                var s = it(o),
                  l = nt(o);
                i || we(!1);
                var c = !(function (e, t) {
                  if (e === t) return !0;
                  var r =
                      e.draggable.id === t.draggable.id &&
                      e.draggable.droppableId === t.draggable.droppableId &&
                      e.draggable.type === t.draggable.type &&
                      e.draggable.index === t.draggable.index,
                    i =
                      e.droppable.id === t.droppable.id &&
                      e.droppable.type === t.droppable.type;
                  return r && i;
                })(n, i.lastCritical);
                c && (i.lastCritical = n);
                var u,
                  d,
                  m =
                    ((d = s),
                    !(
                      (null == (u = i.lastLocation) && null == d) ||
                      (null != u &&
                        null != d &&
                        u.droppableId === d.droppableId &&
                        u.index === d.index)
                    ));
                m && (i.lastLocation = s);
                var f = !(function (e, t) {
                  return (
                    (null == e && null == t) ||
                    (null != e &&
                      null != t &&
                      e.draggableId === t.draggableId &&
                      e.droppableId === t.droppableId)
                  );
                })(i.lastCombine, l);
                if ((f && (i.lastCombine = l), c || m || f)) {
                  var p = (0, a.Z)({}, jr(n, i.mode), {
                    combine: l,
                    destination: s,
                  });
                  r.add(function () {
                    Ur(0, function () {
                      return Hr(e().onDragUpdate, p, t, Oe.onDragUpdate);
                    });
                  });
                }
              },
              flush: function () {
                i || we(!1), r.flush();
              },
              drop: n,
              abort: function () {
                if (i) {
                  var e = (0, a.Z)({}, jr(i.lastCritical, i.mode), {
                    combine: null,
                    destination: null,
                    reason: "CANCEL",
                  });
                  n(e);
                }
              },
            };
          })(e, t);
          return function (e) {
            return function (t) {
              return function (i) {
                if ("BEFORE_INITIAL_CAPTURE" !== i.type) {
                  if ("INITIAL_PUBLISH" === i.type) {
                    var n = i.payload.critical;
                    return (
                      r.beforeStart(n, i.payload.movementMode),
                      t(i),
                      void r.start(n, i.payload.movementMode)
                    );
                  }
                  if ("DROP_COMPLETE" === i.type) {
                    var a = i.payload.completed.result;
                    return r.flush(), t(i), void r.drop(a);
                  }
                  if ((t(i), "FLUSH" !== i.type)) {
                    var o = e.getState();
                    "DRAGGING" === o.phase && r.update(o.critical, o.impact);
                  } else r.abort();
                } else
                  r.beforeCapture(
                    i.payload.draggableId,
                    i.payload.movementMode,
                  );
              };
            };
          };
        },
        qr = function (e) {
          return function (t) {
            return function (r) {
              if ("DROP_ANIMATION_FINISHED" === r.type) {
                var i = e.getState();
                "DROP_ANIMATING" !== i.phase && we(!1),
                  e.dispatch(Rr({ completed: i.completed }));
              } else t(r);
            };
          };
        },
        Zr = function (e) {
          var t = null,
            r = null;
          return function (i) {
            return function (n) {
              if (
                (("FLUSH" !== n.type &&
                  "DROP_COMPLETE" !== n.type &&
                  "DROP_ANIMATION_FINISHED" !== n.type) ||
                  (r && (cancelAnimationFrame(r), (r = null)),
                  t && (t(), (t = null))),
                i(n),
                "DROP_ANIMATE" === n.type)
              ) {
                var a = {
                  eventName: "scroll",
                  options: { capture: !0, passive: !1, once: !0 },
                  fn: function () {
                    "DROP_ANIMATING" === e.getState().phase &&
                      e.dispatch({
                        type: "DROP_ANIMATION_FINISHED",
                        payload: null,
                      });
                  },
                };
                r = requestAnimationFrame(function () {
                  (r = null), (t = Te(window, [a]));
                });
              }
            };
          };
        },
        Yr = function (e) {
          return function (t) {
            return function (r) {
              if ((t(r), "PUBLISH_WHILE_DRAGGING" === r.type)) {
                var i = e.getState();
                "DROP_PENDING" === i.phase &&
                  (i.isWaiting || e.dispatch(Er({ reason: i.reason })));
              }
            };
          };
        },
        Jr = g,
        Kr = function (e) {
          var t,
            r = e.dimensionMarshal,
            i = e.focusMarshal,
            n = e.styleMarshal,
            a = e.getResponders,
            l = e.announce,
            c = e.autoScroller;
          return m(
            mr,
            Jr(
              (function () {
                for (
                  var e = arguments.length, t = new Array(e), r = 0;
                  r < e;
                  r++
                )
                  t[r] = arguments[r];
                return function (e) {
                  return function () {
                    var r = e.apply(void 0, arguments),
                      i = function () {
                        throw new Error(s(15));
                      },
                      n = {
                        getState: r.getState,
                        dispatch: function () {
                          return i.apply(void 0, arguments);
                        },
                      },
                      a = t.map(function (e) {
                        return e(n);
                      });
                    return (
                      (i = g.apply(void 0, a)(r.dispatch)),
                      (0, o.Z)((0, o.Z)({}, r), {}, { dispatch: i })
                    );
                  };
                };
              })(
                ((t = n),
                function () {
                  return function (e) {
                    return function (r) {
                      "INITIAL_PUBLISH" === r.type && t.dragging(),
                        "DROP_ANIMATE" === r.type &&
                          t.dropping(r.payload.completed.result.reason),
                        ("FLUSH" !== r.type && "DROP_COMPLETE" !== r.type) ||
                          t.resting(),
                        e(r);
                    };
                  };
                }),
                (function (e) {
                  return function () {
                    return function (t) {
                      return function (r) {
                        ("DROP_COMPLETE" !== r.type &&
                          "FLUSH" !== r.type &&
                          "DROP_ANIMATE" !== r.type) ||
                          e.stopPublishing(),
                          t(r);
                      };
                    };
                  };
                })(r),
                (function (e) {
                  return function (t) {
                    var r = t.getState,
                      i = t.dispatch;
                    return function (t) {
                      return function (n) {
                        if ("LIFT" === n.type) {
                          var a = n.payload,
                            o = a.id,
                            s = a.clientSelection,
                            l = a.movementMode,
                            c = r();
                          "DROP_ANIMATING" === c.phase &&
                            i(Rr({ completed: c.completed })),
                            "IDLE" !== r().phase && we(!1),
                            i(Br()),
                            i({
                              type: "BEFORE_INITIAL_CAPTURE",
                              payload: { draggableId: o, movementMode: l },
                            });
                          var u = {
                              draggableId: o,
                              scrollOptions: {
                                shouldPublishImmediately: "SNAP" === l,
                              },
                            },
                            d = e.startPublishing(u),
                            m = d.critical,
                            f = d.dimensions,
                            p = d.viewport;
                          i({
                            type: "INITIAL_PUBLISH",
                            payload: {
                              critical: m,
                              dimensions: f,
                              clientSelection: s,
                              movementMode: l,
                              viewport: p,
                            },
                          });
                        } else t(n);
                      };
                    };
                  };
                })(r),
                Wr,
                qr,
                Zr,
                Yr,
                (function (e) {
                  return function (t) {
                    return function (r) {
                      return function (i) {
                        if (
                          (function (e) {
                            return (
                              "DROP_COMPLETE" === e.type ||
                              "DROP_ANIMATE" === e.type ||
                              "FLUSH" === e.type
                            );
                          })(i)
                        )
                          return e.stop(), void r(i);
                        if ("INITIAL_PUBLISH" === i.type) {
                          r(i);
                          var n = t.getState();
                          return (
                            "DRAGGING" !== n.phase && we(!1), void e.start(n)
                          );
                        }
                        r(i), e.scroll(t.getState());
                      };
                    };
                  };
                })(c),
                Lr,
                (function (e) {
                  var t = !1;
                  return function () {
                    return function (r) {
                      return function (i) {
                        if ("INITIAL_PUBLISH" === i.type)
                          return (
                            (t = !0),
                            e.tryRecordFocus(i.payload.critical.draggable.id),
                            r(i),
                            void e.tryRestoreFocusRecorded()
                          );
                        if ((r(i), t)) {
                          if ("FLUSH" === i.type)
                            return (t = !1), void e.tryRestoreFocusRecorded();
                          if ("DROP_COMPLETE" === i.type) {
                            t = !1;
                            var n = i.payload.completed.result;
                            n.combine &&
                              e.tryShiftRecord(
                                n.draggableId,
                                n.combine.draggableId,
                              ),
                              e.tryRestoreFocusRecorded();
                          }
                        }
                      };
                    };
                  };
                })(i),
                Vr(a, l),
              ),
            ),
          );
        };
      var Qr = function (e) {
          var t = e.scrollHeight,
            r = e.scrollWidth,
            i = e.height,
            n = e.width,
            a = xe({ x: r, y: t }, { x: n, y: i });
          return { x: Math.max(0, a.x), y: Math.max(0, a.y) };
        },
        $r = function () {
          var e = document.documentElement;
          return e || we(!1), e;
        },
        ei = function () {
          var e = $r();
          return Qr({
            scrollHeight: e.scrollHeight,
            scrollWidth: e.scrollWidth,
            width: e.clientWidth,
            height: e.clientHeight,
          });
        },
        ti = function (e) {
          var t = e.critical,
            r = e.scrollOptions,
            i = e.registry;
          ar();
          var n,
            a,
            o,
            s,
            l,
            c,
            u,
            d =
              ((n = kr()),
              (a = ei()),
              (o = n.y),
              (s = n.x),
              (l = $r()),
              (c = l.clientWidth),
              (u = l.clientHeight),
              {
                frame: se({ top: o, left: s, right: s + c, bottom: o + u }),
                scroll: {
                  initial: n,
                  current: n,
                  max: a,
                  diff: { value: Fe, displacement: Fe },
                },
              }),
            m = d.scroll.current,
            f = t.droppable,
            p = i.droppable.getAllByType(f.type).map(function (e) {
              return e.callbacks.getDimensionAndWatchScroll(m, r);
            }),
            g = i.draggable.getAllByType(t.draggable.type).map(function (e) {
              return e.getDimension(m);
            }),
            b = { draggables: $e(g), droppables: Qe(p) };
          return or(), { dimensions: b, critical: t, viewport: d };
        };
      function ri(e, t, r) {
        return (
          r.descriptor.id !== t.id &&
          r.descriptor.type === t.type &&
          "virtual" ===
            e.droppable.getById(r.descriptor.droppableId).descriptor.mode
        );
      }
      var ii,
        ni,
        ai = function (e, t) {
          var r = null,
            i = (function (e) {
              var t = e.registry,
                r = e.callbacks,
                i = { additions: {}, removals: {}, modified: {} },
                n = null,
                a = function () {
                  n ||
                    (r.collectionStarting(),
                    (n = requestAnimationFrame(function () {
                      (n = null), ar();
                      var e = i,
                        a = e.additions,
                        o = e.removals,
                        s = e.modified,
                        l = Object.keys(a)
                          .map(function (e) {
                            return t.draggable.getById(e).getDimension(Fe);
                          })
                          .sort(function (e, t) {
                            return e.descriptor.index - t.descriptor.index;
                          }),
                        c = Object.keys(s).map(function (e) {
                          return {
                            droppableId: e,
                            scroll: t.droppable
                              .getById(e)
                              .callbacks.getScrollWhileDragging(),
                          };
                        }),
                        u = {
                          additions: l,
                          removals: Object.keys(o),
                          modified: c,
                        };
                      (i = { additions: {}, removals: {}, modified: {} }),
                        or(),
                        r.publish(u);
                    })));
                };
              return {
                add: function (e) {
                  var t = e.descriptor.id;
                  (i.additions[t] = e),
                    (i.modified[e.descriptor.droppableId] = !0),
                    i.removals[t] && delete i.removals[t],
                    a();
                },
                remove: function (e) {
                  var t = e.descriptor;
                  (i.removals[t.id] = !0),
                    (i.modified[t.droppableId] = !0),
                    i.additions[t.id] && delete i.additions[t.id],
                    a();
                },
                stop: function () {
                  n &&
                    (cancelAnimationFrame(n),
                    (n = null),
                    (i = { additions: {}, removals: {}, modified: {} }));
                },
              };
            })({
              callbacks: {
                publish: t.publishWhileDragging,
                collectionStarting: t.collectionStarting,
              },
              registry: e,
            }),
            n = function (t) {
              r || we(!1);
              var n = r.critical.draggable;
              "ADDITION" === t.type && ri(e, n, t.value) && i.add(t.value),
                "REMOVAL" === t.type && ri(e, n, t.value) && i.remove(t.value);
            },
            a = {
              updateDroppableIsEnabled: function (i, n) {
                e.droppable.exists(i) || we(!1),
                  r && t.updateDroppableIsEnabled({ id: i, isEnabled: n });
              },
              updateDroppableIsCombineEnabled: function (i, n) {
                r &&
                  (e.droppable.exists(i) || we(!1),
                  t.updateDroppableIsCombineEnabled({
                    id: i,
                    isCombineEnabled: n,
                  }));
              },
              scrollDroppable: function (t, i) {
                r && e.droppable.getById(t).callbacks.scroll(i);
              },
              updateDroppableScroll: function (i, n) {
                r &&
                  (e.droppable.exists(i) || we(!1),
                  t.updateDroppableScroll({ id: i, newScroll: n }));
              },
              startPublishing: function (t) {
                r && we(!1);
                var i = e.draggable.getById(t.draggableId),
                  a = e.droppable.getById(i.descriptor.droppableId),
                  o = { draggable: i.descriptor, droppable: a.descriptor },
                  s = e.subscribe(n);
                return (
                  (r = { critical: o, unsubscribe: s }),
                  ti({
                    critical: o,
                    registry: e,
                    scrollOptions: t.scrollOptions,
                  })
                );
              },
              stopPublishing: function () {
                if (r) {
                  i.stop();
                  var t = r.critical.droppable;
                  e.droppable.getAllByType(t.type).forEach(function (e) {
                    return e.callbacks.dragStopped();
                  }),
                    r.unsubscribe(),
                    (r = null);
                }
              },
            };
          return a;
        },
        oi = function (e, t) {
          return (
            "IDLE" === e.phase ||
            ("DROP_ANIMATING" === e.phase &&
              e.completed.result.draggableId !== t &&
              "DROP" === e.completed.result.reason)
          );
        },
        si = function (e) {
          window.scrollBy(e.x, e.y);
        },
        li = Se(function (e) {
          return et(e).filter(function (e) {
            return !!e.isEnabled && !!e.frame;
          });
        }),
        ci = function (e) {
          var t = e.center,
            r = e.destination,
            i = e.droppables;
          if (r) {
            var n = i[r];
            return n.frame ? n : null;
          }
          var a = (function (e, t) {
            var r = Je(li(t), function (t) {
              return t.frame || we(!1), qt(t.frame.pageMarginBox)(e);
            });
            return r;
          })(t, i);
          return a;
        },
        ui = 0.25,
        di = 0.05,
        mi = 28,
        fi = function (e) {
          return Math.pow(e, 2);
        },
        pi = { stopDampeningAt: 1200, accelerateAt: 360 },
        gi = function (e) {
          var t = e.startOfRange,
            r = e.endOfRange,
            i = e.current,
            n = r - t;
          return 0 === n ? 0 : (i - t) / n;
        },
        bi = pi.accelerateAt,
        hi = pi.stopDampeningAt,
        _i = function (e) {
          var t = e.distanceToEdge,
            r = e.thresholds,
            i = e.dragStartTime,
            n = e.shouldUseTimeDampening,
            a = (function (e, t) {
              if (e > t.startScrollingFrom) return 0;
              if (e <= t.maxScrollValueAt) return mi;
              if (e === t.startScrollingFrom) return 1;
              var r = gi({
                  startOfRange: t.maxScrollValueAt,
                  endOfRange: t.startScrollingFrom,
                  current: e,
                }),
                i = mi * fi(1 - r);
              return Math.ceil(i);
            })(t, r);
          return 0 === a
            ? 0
            : n
              ? Math.max(
                  (function (e, t) {
                    var r = t,
                      i = hi,
                      n = Date.now() - r;
                    if (n >= hi) return e;
                    if (n < bi) return 1;
                    var a = gi({ startOfRange: bi, endOfRange: i, current: n }),
                      o = e * fi(a);
                    return Math.ceil(o);
                  })(a, i),
                  1,
                )
              : a;
        },
        Si = function (e) {
          var t = e.container,
            r = e.distanceToEdges,
            i = e.dragStartTime,
            n = e.axis,
            a = e.shouldUseTimeDampening,
            o = (function (e, t) {
              return {
                startScrollingFrom: e[t.size] * ui,
                maxScrollValueAt: e[t.size] * di,
              };
            })(t, n);
          return r[n.end] < r[n.start]
            ? _i({
                distanceToEdge: r[n.end],
                thresholds: o,
                dragStartTime: i,
                shouldUseTimeDampening: a,
              })
            : -1 *
                _i({
                  distanceToEdge: r[n.start],
                  thresholds: o,
                  dragStartTime: i,
                  shouldUseTimeDampening: a,
                });
        },
        vi = Xe(function (e) {
          return 0 === e ? 0 : e;
        }),
        yi = function (e) {
          var t = e.dragStartTime,
            r = e.container,
            i = e.subject,
            n = e.center,
            a = e.shouldUseTimeDampening,
            o = {
              top: n.y - r.top,
              right: r.right - n.x,
              bottom: r.bottom - n.y,
              left: n.x - r.left,
            },
            s = Si({
              container: r,
              distanceToEdges: o,
              dragStartTime: t,
              axis: ft,
              shouldUseTimeDampening: a,
            }),
            l = Si({
              container: r,
              distanceToEdges: o,
              dragStartTime: t,
              axis: pt,
              shouldUseTimeDampening: a,
            }),
            c = vi({ x: l, y: s });
          if (Ae(c, Fe)) return null;
          var u = (function (e) {
            var t = e.container,
              r = e.subject,
              i = e.proposedScroll,
              n = r.height > t.height,
              a = r.width > t.width;
            return a || n
              ? a && n
                ? null
                : { x: a ? 0 : i.x, y: n ? 0 : i.y }
              : i;
          })({ container: r, subject: i, proposedScroll: c });
          return u ? (Ae(u, Fe) ? null : u) : null;
        },
        Mi = Xe(function (e) {
          return 0 === e ? 0 : e > 0 ? 1 : -1;
        }),
        Ti =
          ((ii = function (e, t) {
            return e < 0 ? e : e > t ? e - t : 0;
          }),
          function (e) {
            var t = e.current,
              r = e.max,
              i = e.change,
              n = ze(t, i),
              a = { x: ii(n.x, r.x), y: ii(n.y, r.y) };
            return Ae(a, Fe) ? null : a;
          }),
        Bi = function (e) {
          var t = e.max,
            r = e.current,
            i = e.change,
            n = { x: Math.max(r.x, t.x), y: Math.max(r.y, t.y) },
            a = Mi(i),
            o = Ti({ max: n, current: r, change: a });
          return !o || (0 !== a.x && 0 === o.x) || (0 !== a.y && 0 === o.y);
        },
        Ri = function (e, t) {
          return Bi({
            current: e.scroll.current,
            max: e.scroll.max,
            change: t,
          });
        },
        Ei = function (e, t) {
          var r = e.frame;
          return (
            !!r &&
            Bi({ current: r.scroll.current, max: r.scroll.max, change: t })
          );
        },
        wi = function (e) {
          var t = e.state,
            r = e.dragStartTime,
            i = e.shouldUseTimeDampening,
            n = e.scrollWindow,
            a = e.scrollDroppable,
            o = t.current.page.borderBoxCenter,
            s = t.dimensions.draggables[t.critical.draggable.id].page.marginBox;
          if (t.isWindowScrollAllowed) {
            var l = (function (e) {
              var t = e.viewport,
                r = e.subject,
                i = e.center,
                n = e.dragStartTime,
                a = e.shouldUseTimeDampening,
                o = yi({
                  dragStartTime: n,
                  container: t.frame,
                  subject: r,
                  center: i,
                  shouldUseTimeDampening: a,
                });
              return o && Ri(t, o) ? o : null;
            })({
              dragStartTime: r,
              viewport: t.viewport,
              subject: s,
              center: o,
              shouldUseTimeDampening: i,
            });
            if (l) return void n(l);
          }
          var c = ci({
            center: o,
            destination: jt(t.impact),
            droppables: t.dimensions.droppables,
          });
          if (c) {
            var u = (function (e) {
              var t = e.droppable,
                r = e.subject,
                i = e.center,
                n = e.dragStartTime,
                a = e.shouldUseTimeDampening,
                o = t.frame;
              if (!o) return null;
              var s = yi({
                dragStartTime: n,
                container: o.pageMarginBox,
                subject: r,
                center: i,
                shouldUseTimeDampening: a,
              });
              return s && Ei(t, s) ? s : null;
            })({
              dragStartTime: r,
              droppable: c,
              subject: s,
              center: o,
              shouldUseTimeDampening: i,
            });
            u && a(c.descriptor.id, u);
          }
        },
        Ci = function (e) {
          var t = e.move,
            r = e.scrollDroppable,
            i = e.scrollWindow,
            n = function (e, t) {
              if (!Ei(e, t)) return t;
              var i = (function (e, t) {
                var r = e.frame;
                return r && Ei(e, t)
                  ? Ti({
                      current: r.scroll.current,
                      max: r.scroll.max,
                      change: t,
                    })
                  : null;
              })(e, t);
              if (!i) return r(e.descriptor.id, t), null;
              var n = xe(t, i);
              return r(e.descriptor.id, n), xe(t, n);
            },
            a = function (e, t, r) {
              if (!e) return r;
              if (!Ri(t, r)) return r;
              var n = (function (e, t) {
                if (!Ri(e, t)) return null;
                var r = e.scroll.max,
                  i = e.scroll.current;
                return Ti({ current: i, max: r, change: t });
              })(t, r);
              if (!n) return i(r), null;
              var a = xe(r, n);
              return i(a), xe(r, a);
            };
          return function (e) {
            var r = e.scrollJumpRequest;
            if (r) {
              var i = jt(e.impact);
              i || we(!1);
              var o = n(e.dimensions.droppables[i], r);
              if (o) {
                var s = e.viewport,
                  l = a(e.isWindowScrollAllowed, s, o);
                l &&
                  (function (e, r) {
                    var i = ze(e.current.client.selection, r);
                    t({ client: i });
                  })(e, l);
              }
            }
          };
        },
        Gi = function (e) {
          var t = e.scrollDroppable,
            r = e.scrollWindow,
            i = e.move,
            n = (function (e) {
              var t = e.scrollWindow,
                r = e.scrollDroppable,
                i = ve(t),
                n = ve(r),
                a = null,
                o = function (e) {
                  a || we(!1);
                  var t = a,
                    r = t.shouldUseTimeDampening,
                    o = t.dragStartTime;
                  wi({
                    state: e,
                    scrollWindow: i,
                    scrollDroppable: n,
                    dragStartTime: o,
                    shouldUseTimeDampening: r,
                  });
                };
              return {
                start: function (e) {
                  ar(), a && we(!1);
                  var t = Date.now(),
                    r = !1,
                    i = function () {
                      r = !0;
                    };
                  wi({
                    state: e,
                    dragStartTime: 0,
                    shouldUseTimeDampening: !1,
                    scrollWindow: i,
                    scrollDroppable: i,
                  }),
                    (a = { dragStartTime: t, shouldUseTimeDampening: r }),
                    or(),
                    r && o(e);
                },
                stop: function () {
                  a && (i.cancel(), n.cancel(), (a = null));
                },
                scroll: o,
              };
            })({ scrollWindow: r, scrollDroppable: t }),
            a = Ci({ move: i, scrollWindow: r, scrollDroppable: t });
          return {
            scroll: function (e) {
              "DRAGGING" === e.phase &&
                ("FLUID" !== e.movementMode
                  ? e.scrollJumpRequest && a(e)
                  : n.scroll(e));
            },
            start: n.start,
            stop: n.stop,
          };
        },
        Pi = "data-rbd",
        Ii = {
          base: (ni = Pi + "-drag-handle"),
          draggableId: ni + "-draggable-id",
          contextId: ni + "-context-id",
        },
        Di = (function () {
          var e = Pi + "-draggable";
          return { base: e, contextId: e + "-context-id", id: e + "-id" };
        })(),
        Oi = (function () {
          var e = Pi + "-droppable";
          return { base: e, contextId: e + "-context-id", id: e + "-id" };
        })(),
        Fi = { contextId: Pi + "-scroll-container-context-id" },
        zi = function (e, t) {
          return e
            .map(function (e) {
              var r = e.styles[t];
              return r ? e.selector + " { " + r + " }" : "";
            })
            .join(" ");
        },
        xi = function (e) {
          var t,
            r,
            i,
            n =
              ((t = e),
              function (e) {
                return "[" + e + '="' + t + '"]';
              }),
            a =
              ((r = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    "),
              {
                selector: n(Ii.contextId),
                styles: {
                  always:
                    "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
                  resting: r,
                  dragging: "pointer-events: none;",
                  dropAnimating: r,
                },
              }),
            o = [
              ((i = "\n      transition: " + Dr.outOfTheWay + ";\n    "),
              {
                selector: n(Di.contextId),
                styles: { dragging: i, dropAnimating: i, userCancel: i },
              }),
              a,
              {
                selector: n(Oi.contextId),
                styles: { always: "overflow-anchor: none;" },
              },
              {
                selector: "body",
                styles: {
                  dragging:
                    "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      ",
                },
              },
            ];
          return {
            always: zi(o, "always"),
            resting: zi(o, "resting"),
            dragging: zi(o, "dragging"),
            dropAnimating: zi(o, "dropAnimating"),
            userCancel: zi(o, "userCancel"),
          };
        },
        Ai =
          "undefined" != typeof window &&
          void 0 !== window.document &&
          void 0 !== window.document.createElement
            ? i.useLayoutEffect
            : i.useEffect,
        Wi = function () {
          var e = document.querySelector("head");
          return e || we(!1), e;
        },
        ki = function (e) {
          var t = document.createElement("style");
          return e && t.setAttribute("nonce", e), (t.type = "text/css"), t;
        };
      var Ni = function (e) {
        return e && e.ownerDocument ? e.ownerDocument.defaultView : window;
      };
      function Li(e) {
        return e instanceof Ni(e).HTMLElement;
      }
      function Xi(e, t) {
        var r = "[" + Ii.contextId + '="' + e + '"]',
          i = Ke(document.querySelectorAll(r));
        if (!i.length) return null;
        var n = Je(i, function (e) {
          return e.getAttribute(Ii.draggableId) === t;
        });
        return n && Li(n) ? n : null;
      }
      function Ui() {
        var e = { draggables: {}, droppables: {} },
          t = [];
        function r(e) {
          t.length &&
            t.forEach(function (t) {
              return t(e);
            });
        }
        function i(t) {
          return e.draggables[t] || null;
        }
        function n(t) {
          return e.droppables[t] || null;
        }
        return {
          draggable: {
            register: function (t) {
              (e.draggables[t.descriptor.id] = t),
                r({ type: "ADDITION", value: t });
            },
            update: function (t, r) {
              var i = e.draggables[r.descriptor.id];
              i &&
                i.uniqueId === t.uniqueId &&
                (delete e.draggables[r.descriptor.id],
                (e.draggables[t.descriptor.id] = t));
            },
            unregister: function (t) {
              var n = t.descriptor.id,
                a = i(n);
              a &&
                t.uniqueId === a.uniqueId &&
                (delete e.draggables[n], r({ type: "REMOVAL", value: t }));
            },
            getById: function (e) {
              var t = i(e);
              return t || we(!1), t;
            },
            findById: i,
            exists: function (e) {
              return Boolean(i(e));
            },
            getAllByType: function (t) {
              return Ze(e.draggables).filter(function (e) {
                return e.descriptor.type === t;
              });
            },
          },
          droppable: {
            register: function (t) {
              e.droppables[t.descriptor.id] = t;
            },
            unregister: function (t) {
              var r = n(t.descriptor.id);
              r &&
                t.uniqueId === r.uniqueId &&
                delete e.droppables[t.descriptor.id];
            },
            getById: function (e) {
              var t = n(e);
              return t || we(!1), t;
            },
            findById: n,
            exists: function (e) {
              return Boolean(n(e));
            },
            getAllByType: function (t) {
              return Ze(e.droppables).filter(function (e) {
                return e.descriptor.type === t;
              });
            },
          },
          subscribe: function (e) {
            return (
              t.push(e),
              function () {
                var r = t.indexOf(e);
                -1 !== r && t.splice(r, 1);
              }
            );
          },
          clean: function () {
            (e.draggables = {}), (e.droppables = {}), (t.length = 0);
          },
        };
      }
      var ji = i.createContext(null),
        Hi = function () {
          var e = document.body;
          return e || we(!1), e;
        },
        Vi = {
          position: "absolute",
          width: "1px",
          height: "1px",
          margin: "-1px",
          border: "0",
          padding: "0",
          overflow: "hidden",
          clip: "rect(0 0 0 0)",
          "clip-path": "inset(100%)",
        },
        qi = function (e) {
          return "rbd-announcement-" + e;
        };
      var Zi = 0,
        Yi = { separator: "::" };
      function Ji(e, t) {
        return (
          void 0 === t && (t = Yi),
          ne(
            function () {
              return "" + e + t.separator + Zi++;
            },
            [t.separator, e],
          )
        );
      }
      var Ki = i.createContext(null);
      function Qi(e) {
        0;
      }
      function $i(e, t) {
        Qi();
      }
      function en(e) {
        var t = (0, i.useRef)(e);
        return (
          (0, i.useEffect)(function () {
            t.current = e;
          }),
          t
        );
      }
      var tn,
        rn = 27,
        nn = 32,
        an = 37,
        on = 38,
        sn = 39,
        ln = 40,
        cn = (((tn = {})[13] = !0), (tn[9] = !0), tn),
        un = function (e) {
          cn[e.keyCode] && e.preventDefault();
        },
        dn = (function () {
          var e = "visibilitychange";
          return "undefined" == typeof document
            ? e
            : Je([e, "ms" + e, "webkit" + e, "moz" + e, "o" + e], function (e) {
                return "on" + e in document;
              }) || e;
        })(),
        mn = 0,
        fn = 5;
      var pn,
        gn = { type: "IDLE" };
      function bn(e) {
        var t = e.cancel,
          r = e.completed,
          i = e.getPhase,
          n = e.setPhase;
        return [
          {
            eventName: "mousemove",
            fn: function (e) {
              var t = e.button,
                r = e.clientX,
                a = e.clientY;
              if (t === mn) {
                var o = { x: r, y: a },
                  s = i();
                if ("DRAGGING" === s.type)
                  return e.preventDefault(), void s.actions.move(o);
                "PENDING" !== s.type && we(!1);
                var l = s.point;
                if (
                  ((c = l),
                  (u = o),
                  Math.abs(u.x - c.x) >= fn || Math.abs(u.y - c.y) >= fn)
                ) {
                  var c, u;
                  e.preventDefault();
                  var d = s.actions.fluidLift(o);
                  n({ type: "DRAGGING", actions: d });
                }
              }
            },
          },
          {
            eventName: "mouseup",
            fn: function (e) {
              var n = i();
              "DRAGGING" === n.type
                ? (e.preventDefault(),
                  n.actions.drop({ shouldBlockNextClick: !0 }),
                  r())
                : t();
            },
          },
          {
            eventName: "mousedown",
            fn: function (e) {
              "DRAGGING" === i().type && e.preventDefault(), t();
            },
          },
          {
            eventName: "keydown",
            fn: function (e) {
              if ("PENDING" !== i().type)
                return e.keyCode === rn
                  ? (e.preventDefault(), void t())
                  : void un(e);
              t();
            },
          },
          { eventName: "resize", fn: t },
          {
            eventName: "scroll",
            options: { passive: !0, capture: !1 },
            fn: function () {
              "PENDING" === i().type && t();
            },
          },
          {
            eventName: "webkitmouseforcedown",
            fn: function (e) {
              var r = i();
              "IDLE" === r.type && we(!1),
                r.actions.shouldRespectForcePress() ? t() : e.preventDefault();
            },
          },
          { eventName: dn, fn: t },
        ];
      }
      function hn() {}
      var _n =
        (((pn = {})[34] = !0), (pn[33] = !0), (pn[36] = !0), (pn[35] = !0), pn);
      function Sn(e, t) {
        function r() {
          t(), e.cancel();
        }
        return [
          {
            eventName: "keydown",
            fn: function (i) {
              return i.keyCode === rn
                ? (i.preventDefault(), void r())
                : i.keyCode === nn
                  ? (i.preventDefault(), t(), void e.drop())
                  : i.keyCode === ln
                    ? (i.preventDefault(), void e.moveDown())
                    : i.keyCode === on
                      ? (i.preventDefault(), void e.moveUp())
                      : i.keyCode === sn
                        ? (i.preventDefault(), void e.moveRight())
                        : i.keyCode === an
                          ? (i.preventDefault(), void e.moveLeft())
                          : void (_n[i.keyCode] ? i.preventDefault() : un(i));
            },
          },
          { eventName: "mousedown", fn: r },
          { eventName: "mouseup", fn: r },
          { eventName: "click", fn: r },
          { eventName: "touchstart", fn: r },
          { eventName: "resize", fn: r },
          { eventName: "wheel", fn: r, options: { passive: !0 } },
          { eventName: dn, fn: r },
        ];
      }
      var vn = { type: "IDLE" },
        yn = 0.15;
      var Mn = {
        input: !0,
        button: !0,
        textarea: !0,
        select: !0,
        option: !0,
        optgroup: !0,
        video: !0,
        audio: !0,
      };
      function Tn(e, t) {
        if (null == t) return !1;
        if (Boolean(Mn[t.tagName.toLowerCase()])) return !0;
        var r = t.getAttribute("contenteditable");
        return "true" === r || "" === r || (t !== e && Tn(e, t.parentElement));
      }
      function Bn(e, t) {
        var r = t.target;
        return !!Li(r) && Tn(e, r);
      }
      var Rn = function (e) {
        return se(e.getBoundingClientRect()).center;
      };
      var En = (function () {
        var e = "matches";
        return "undefined" == typeof document
          ? e
          : Je([e, "msMatchesSelector", "webkitMatchesSelector"], function (e) {
              return e in Element.prototype;
            }) || e;
      })();
      function wn(e, t) {
        return null == e ? null : e[En](t) ? e : wn(e.parentElement, t);
      }
      function Cn(e, t) {
        return e.closest ? e.closest(t) : wn(e, t);
      }
      function Gn(e, t) {
        var r,
          i = t.target;
        if (!((r = i) instanceof Ni(r).Element)) return null;
        var n = (function (e) {
            return "[" + Ii.contextId + '="' + e + '"]';
          })(e),
          a = Cn(i, n);
        return a && Li(a) ? a : null;
      }
      function Pn(e) {
        e.preventDefault();
      }
      function In(e) {
        var t = e.expected,
          r = e.phase,
          i = e.isLockActive;
        e.shouldWarn;
        return !!i() && t === r;
      }
      function Dn(e) {
        var t = e.lockAPI,
          r = e.store,
          i = e.registry,
          n = e.draggableId;
        if (t.isClaimed()) return !1;
        var a = i.draggable.findById(n);
        return !!a && !!a.options.isEnabled && !!oi(r.getState(), n);
      }
      function On(e) {
        var t = e.lockAPI,
          r = e.contextId,
          i = e.store,
          n = e.registry,
          o = e.draggableId,
          s = e.forceSensorStop,
          l = e.sourceEvent;
        if (!Dn({ lockAPI: t, store: i, registry: n, draggableId: o }))
          return null;
        var c = n.draggable.getById(o),
          u = (function (e, t) {
            var r = "[" + Di.contextId + '="' + e + '"]',
              i = Je(Ke(document.querySelectorAll(r)), function (e) {
                return e.getAttribute(Di.id) === t;
              });
            return i && Li(i) ? i : null;
          })(r, c.descriptor.id);
        if (!u) return null;
        if (l && !c.options.canDragInteractiveElements && Bn(u, l)) return null;
        var d = t.claim(s || Me),
          m = "PRE_DRAG";
        function f() {
          return c.options.shouldRespectForcePress;
        }
        function p() {
          return t.isActive(d);
        }
        var g = function (e, t) {
          In({ expected: e, phase: m, isLockActive: p, shouldWarn: !0 }) &&
            i.dispatch(t());
        }.bind(null, "DRAGGING");
        function b(e) {
          function r() {
            t.release(), (m = "COMPLETED");
          }
          function n(t, n) {
            if (
              (void 0 === n && (n = { shouldBlockNextClick: !1 }),
              e.cleanup(),
              n.shouldBlockNextClick)
            ) {
              var a = Te(window, [
                {
                  eventName: "click",
                  fn: Pn,
                  options: { once: !0, passive: !1, capture: !0 },
                },
              ]);
              setTimeout(a);
            }
            r(), i.dispatch(Er({ reason: t }));
          }
          return (
            "PRE_DRAG" !== m && (r(), "PRE_DRAG" !== m && we(!1)),
            i.dispatch(fr(e.liftActionArgs)),
            (m = "DRAGGING"),
            (0, a.Z)(
              {
                isActive: function () {
                  return In({
                    expected: "DRAGGING",
                    phase: m,
                    isLockActive: p,
                    shouldWarn: !1,
                  });
                },
                shouldRespectForcePress: f,
                drop: function (e) {
                  return n("DROP", e);
                },
                cancel: function (e) {
                  return n("CANCEL", e);
                },
              },
              e.actions,
            )
          );
        }
        return {
          isActive: function () {
            return In({
              expected: "PRE_DRAG",
              phase: m,
              isLockActive: p,
              shouldWarn: !1,
            });
          },
          shouldRespectForcePress: f,
          fluidLift: function (e) {
            var t = ve(function (e) {
                g(function () {
                  return Sr({ client: e });
                });
              }),
              r = b({
                liftActionArgs: {
                  id: o,
                  clientSelection: e,
                  movementMode: "FLUID",
                },
                cleanup: function () {
                  return t.cancel();
                },
                actions: { move: t },
              });
            return (0, a.Z)({}, r, { move: t });
          },
          snapLift: function () {
            var e = {
              moveUp: function () {
                return g(vr);
              },
              moveRight: function () {
                return g(Mr);
              },
              moveDown: function () {
                return g(yr);
              },
              moveLeft: function () {
                return g(Tr);
              },
            };
            return b({
              liftActionArgs: {
                id: o,
                clientSelection: Rn(u),
                movementMode: "SNAP",
              },
              cleanup: Me,
              actions: e,
            });
          },
          abort: function () {
            In({
              expected: "PRE_DRAG",
              phase: m,
              isLockActive: p,
              shouldWarn: !0,
            }) && t.release();
          },
        };
      }
      var Fn = [
        function (e) {
          var t = (0, i.useRef)(gn),
            r = (0, i.useRef)(Me),
            n = ne(
              function () {
                return {
                  eventName: "mousedown",
                  fn: function (t) {
                    if (
                      !t.defaultPrevented &&
                      t.button === mn &&
                      !(t.ctrlKey || t.metaKey || t.shiftKey || t.altKey)
                    ) {
                      var i = e.findClosestDraggableId(t);
                      if (i) {
                        var n = e.tryGetLock(i, s, { sourceEvent: t });
                        if (n) {
                          t.preventDefault();
                          var a = { x: t.clientX, y: t.clientY };
                          r.current(), u(n, a);
                        }
                      }
                    }
                  },
                };
              },
              [e],
            ),
            a = ne(
              function () {
                return {
                  eventName: "webkitmouseforcewillbegin",
                  fn: function (t) {
                    if (!t.defaultPrevented) {
                      var r = e.findClosestDraggableId(t);
                      if (r) {
                        var i = e.findOptionsForDraggable(r);
                        i &&
                          (i.shouldRespectForcePress ||
                            (e.canGetLock(r) && t.preventDefault()));
                      }
                    }
                  },
                };
              },
              [e],
            ),
            o = ae(
              function () {
                r.current = Te(window, [a, n], { passive: !1, capture: !0 });
              },
              [a, n],
            ),
            s = ae(
              function () {
                "IDLE" !== t.current.type &&
                  ((t.current = gn), r.current(), o());
              },
              [o],
            ),
            l = ae(
              function () {
                var e = t.current;
                s(),
                  "DRAGGING" === e.type &&
                    e.actions.cancel({ shouldBlockNextClick: !0 }),
                  "PENDING" === e.type && e.actions.abort();
              },
              [s],
            ),
            c = ae(
              function () {
                var e = bn({
                  cancel: l,
                  completed: s,
                  getPhase: function () {
                    return t.current;
                  },
                  setPhase: function (e) {
                    t.current = e;
                  },
                });
                r.current = Te(window, e, { capture: !0, passive: !1 });
              },
              [l, s],
            ),
            u = ae(
              function (e, r) {
                "IDLE" !== t.current.type && we(!1),
                  (t.current = { type: "PENDING", point: r, actions: e }),
                  c();
              },
              [c],
            );
          Ai(
            function () {
              return (
                o(),
                function () {
                  r.current();
                }
              );
            },
            [o],
          );
        },
        function (e) {
          var t = (0, i.useRef)(hn),
            r = ne(
              function () {
                return {
                  eventName: "keydown",
                  fn: function (r) {
                    if (!r.defaultPrevented && r.keyCode === nn) {
                      var i = e.findClosestDraggableId(r);
                      if (i) {
                        var a = e.tryGetLock(i, l, { sourceEvent: r });
                        if (a) {
                          r.preventDefault();
                          var o = !0,
                            s = a.snapLift();
                          t.current(),
                            (t.current = Te(window, Sn(s, l), {
                              capture: !0,
                              passive: !1,
                            }));
                        }
                      }
                    }
                    function l() {
                      o || we(!1), (o = !1), t.current(), n();
                    }
                  },
                };
              },
              [e],
            ),
            n = ae(
              function () {
                t.current = Te(window, [r], { passive: !1, capture: !0 });
              },
              [r],
            );
          Ai(
            function () {
              return (
                n(),
                function () {
                  t.current();
                }
              );
            },
            [n],
          );
        },
        function (e) {
          var t = (0, i.useRef)(vn),
            r = (0, i.useRef)(Me),
            n = ae(function () {
              return t.current;
            }, []),
            a = ae(function (e) {
              t.current = e;
            }, []),
            o = ne(
              function () {
                return {
                  eventName: "touchstart",
                  fn: function (t) {
                    if (!t.defaultPrevented) {
                      var i = e.findClosestDraggableId(t);
                      if (i) {
                        var n = e.tryGetLock(i, l, { sourceEvent: t });
                        if (n) {
                          var a = t.touches[0],
                            o = { x: a.clientX, y: a.clientY };
                          r.current(), m(n, o);
                        }
                      }
                    }
                  },
                };
              },
              [e],
            ),
            s = ae(
              function () {
                r.current = Te(window, [o], { capture: !0, passive: !1 });
              },
              [o],
            ),
            l = ae(
              function () {
                var e = t.current;
                "IDLE" !== e.type &&
                  ("PENDING" === e.type && clearTimeout(e.longPressTimerId),
                  a(vn),
                  r.current(),
                  s());
              },
              [s, a],
            ),
            c = ae(
              function () {
                var e = t.current;
                l(),
                  "DRAGGING" === e.type &&
                    e.actions.cancel({ shouldBlockNextClick: !0 }),
                  "PENDING" === e.type && e.actions.abort();
              },
              [l],
            ),
            u = ae(
              function () {
                var e = { capture: !0, passive: !1 },
                  t = { cancel: c, completed: l, getPhase: n },
                  i = Te(
                    window,
                    (function (e) {
                      var t = e.cancel,
                        r = e.completed,
                        i = e.getPhase;
                      return [
                        {
                          eventName: "touchmove",
                          options: { capture: !1 },
                          fn: function (e) {
                            var r = i();
                            if ("DRAGGING" === r.type) {
                              r.hasMoved = !0;
                              var n = e.touches[0],
                                a = { x: n.clientX, y: n.clientY };
                              e.preventDefault(), r.actions.move(a);
                            } else t();
                          },
                        },
                        {
                          eventName: "touchend",
                          fn: function (e) {
                            var n = i();
                            "DRAGGING" === n.type
                              ? (e.preventDefault(),
                                n.actions.drop({ shouldBlockNextClick: !0 }),
                                r())
                              : t();
                          },
                        },
                        {
                          eventName: "touchcancel",
                          fn: function (e) {
                            "DRAGGING" === i().type
                              ? (e.preventDefault(), t())
                              : t();
                          },
                        },
                        {
                          eventName: "touchforcechange",
                          fn: function (e) {
                            var r = i();
                            "IDLE" === r.type && we(!1);
                            var n = e.touches[0];
                            if (n && n.force >= yn) {
                              var a = r.actions.shouldRespectForcePress();
                              if ("PENDING" !== r.type)
                                return a
                                  ? r.hasMoved
                                    ? void e.preventDefault()
                                    : void t()
                                  : void e.preventDefault();
                              a && t();
                            }
                          },
                        },
                        { eventName: dn, fn: t },
                      ];
                    })(t),
                    e,
                  ),
                  a = Te(
                    window,
                    (function (e) {
                      var t = e.cancel,
                        r = e.getPhase;
                      return [
                        { eventName: "orientationchange", fn: t },
                        { eventName: "resize", fn: t },
                        {
                          eventName: "contextmenu",
                          fn: function (e) {
                            e.preventDefault();
                          },
                        },
                        {
                          eventName: "keydown",
                          fn: function (e) {
                            "DRAGGING" === r().type
                              ? (e.keyCode === rn && e.preventDefault(), t())
                              : t();
                          },
                        },
                        { eventName: dn, fn: t },
                      ];
                    })(t),
                    e,
                  );
                r.current = function () {
                  i(), a();
                };
              },
              [c, n, l],
            ),
            d = ae(
              function () {
                var e = n();
                "PENDING" !== e.type && we(!1);
                var t = e.actions.fluidLift(e.point);
                a({ type: "DRAGGING", actions: t, hasMoved: !1 });
              },
              [n, a],
            ),
            m = ae(
              function (e, t) {
                "IDLE" !== n().type && we(!1);
                var r = setTimeout(d, 120);
                a({
                  type: "PENDING",
                  point: t,
                  actions: e,
                  longPressTimerId: r,
                }),
                  u();
              },
              [u, n, a, d],
            );
          Ai(
            function () {
              return (
                s(),
                function () {
                  r.current();
                  var e = n();
                  "PENDING" === e.type &&
                    (clearTimeout(e.longPressTimerId), a(vn));
                }
              );
            },
            [n, s, a],
          ),
            Ai(function () {
              return Te(window, [
                {
                  eventName: "touchmove",
                  fn: function () {},
                  options: { capture: !1, passive: !1 },
                },
              ]);
            }, []);
        },
      ];
      function zn(e) {
        var t = e.contextId,
          r = e.store,
          n = e.registry,
          a = e.customSensors,
          o = e.enableDefaultSensors,
          s = [].concat(o ? Fn : [], a || []),
          l = (0, i.useState)(function () {
            return (function () {
              var e = null;
              function t() {
                e || we(!1), (e = null);
              }
              return {
                isClaimed: function () {
                  return Boolean(e);
                },
                isActive: function (t) {
                  return t === e;
                },
                claim: function (t) {
                  e && we(!1);
                  var r = { abandon: t };
                  return (e = r), r;
                },
                release: t,
                tryAbandon: function () {
                  e && (e.abandon(), t());
                },
              };
            })();
          })[0],
          c = ae(
            function (e, t) {
              e.isDragging && !t.isDragging && l.tryAbandon();
            },
            [l],
          );
        Ai(
          function () {
            var e = r.getState();
            return r.subscribe(function () {
              var t = r.getState();
              c(e, t), (e = t);
            });
          },
          [l, r, c],
        ),
          Ai(
            function () {
              return l.tryAbandon;
            },
            [l.tryAbandon],
          );
        var u = ae(
            function (e) {
              return Dn({ lockAPI: l, registry: n, store: r, draggableId: e });
            },
            [l, n, r],
          ),
          d = ae(
            function (e, i, a) {
              return On({
                lockAPI: l,
                registry: n,
                contextId: t,
                store: r,
                draggableId: e,
                forceSensorStop: i,
                sourceEvent: a && a.sourceEvent ? a.sourceEvent : null,
              });
            },
            [t, l, n, r],
          ),
          m = ae(
            function (e) {
              return (function (e, t) {
                var r = Gn(e, t);
                return r ? r.getAttribute(Ii.draggableId) : null;
              })(t, e);
            },
            [t],
          ),
          f = ae(
            function (e) {
              var t = n.draggable.findById(e);
              return t ? t.options : null;
            },
            [n.draggable],
          ),
          p = ae(
            function () {
              l.isClaimed() &&
                (l.tryAbandon(),
                "IDLE" !== r.getState().phase && r.dispatch(Br()));
            },
            [l, r],
          ),
          g = ae(l.isClaimed, [l]),
          b = ne(
            function () {
              return {
                canGetLock: u,
                tryGetLock: d,
                findClosestDraggableId: m,
                findOptionsForDraggable: f,
                tryReleaseLock: p,
                isLockClaimed: g,
              };
            },
            [u, d, m, f, p, g],
          );
        Qi();
        for (var h = 0; h < s.length; h++) s[h](b);
      }
      var xn = function (e) {
        return {
          onBeforeCapture: e.onBeforeCapture,
          onBeforeDragStart: e.onBeforeDragStart,
          onDragStart: e.onDragStart,
          onDragEnd: e.onDragEnd,
          onDragUpdate: e.onDragUpdate,
        };
      };
      function An(e) {
        return e.current || we(!1), e.current;
      }
      function Wn(e) {
        var t = e.contextId,
          r = e.setCallbacks,
          n = e.sensors,
          o = e.nonce,
          s = e.dragHandleUsageInstructions,
          l = (0, i.useRef)(null);
        $i();
        var c = en(e),
          u = ae(
            function () {
              return xn(c.current);
            },
            [c],
          ),
          d = (function (e) {
            var t = ne(
                function () {
                  return qi(e);
                },
                [e],
              ),
              r = (0, i.useRef)(null);
            return (
              (0, i.useEffect)(
                function () {
                  var e = document.createElement("div");
                  return (
                    (r.current = e),
                    (e.id = t),
                    e.setAttribute("aria-live", "assertive"),
                    e.setAttribute("aria-atomic", "true"),
                    (0, a.Z)(e.style, Vi),
                    Hi().appendChild(e),
                    function () {
                      setTimeout(function () {
                        var t = Hi();
                        t.contains(e) && t.removeChild(e),
                          e === r.current && (r.current = null);
                      });
                    }
                  );
                },
                [t],
              ),
              ae(function (e) {
                var t = r.current;
                t && (t.textContent = e);
              }, [])
            );
          })(t),
          m = (function (e) {
            var t = e.contextId,
              r = e.text,
              n = Ji("hidden-text", { separator: "-" }),
              a = ne(
                function () {
                  return (
                    "rbd-hidden-text-" +
                    (e = { contextId: t, uniqueId: n }).contextId +
                    "-" +
                    e.uniqueId
                  );
                  var e;
                },
                [n, t],
              );
            return (
              (0, i.useEffect)(
                function () {
                  var e = document.createElement("div");
                  return (
                    (e.id = a),
                    (e.textContent = r),
                    (e.style.display = "none"),
                    Hi().appendChild(e),
                    function () {
                      var t = Hi();
                      t.contains(e) && t.removeChild(e);
                    }
                  );
                },
                [a, r],
              ),
              a
            );
          })({ contextId: t, text: s }),
          f = (function (e, t) {
            var r = ne(
                function () {
                  return xi(e);
                },
                [e],
              ),
              n = (0, i.useRef)(null),
              a = (0, i.useRef)(null),
              o = ae(
                Se(function (e) {
                  var t = a.current;
                  t || we(!1), (t.textContent = e);
                }),
                [],
              ),
              s = ae(function (e) {
                var t = n.current;
                t || we(!1), (t.textContent = e);
              }, []);
            Ai(
              function () {
                (n.current || a.current) && we(!1);
                var i = ki(t),
                  l = ki(t);
                return (
                  (n.current = i),
                  (a.current = l),
                  i.setAttribute(Pi + "-always", e),
                  l.setAttribute(Pi + "-dynamic", e),
                  Wi().appendChild(i),
                  Wi().appendChild(l),
                  s(r.always),
                  o(r.resting),
                  function () {
                    var e = function (e) {
                      var t = e.current;
                      t || we(!1), Wi().removeChild(t), (e.current = null);
                    };
                    e(n), e(a);
                  }
                );
              },
              [t, s, o, r.always, r.resting, e],
            );
            var l = ae(
                function () {
                  return o(r.dragging);
                },
                [o, r.dragging],
              ),
              c = ae(
                function (e) {
                  o("DROP" !== e ? r.userCancel : r.dropAnimating);
                },
                [o, r.dropAnimating, r.userCancel],
              ),
              u = ae(
                function () {
                  a.current && o(r.resting);
                },
                [o, r.resting],
              );
            return ne(
              function () {
                return { dragging: l, dropping: c, resting: u };
              },
              [l, c, u],
            );
          })(t, o),
          g = ae(function (e) {
            An(l).dispatch(e);
          }, []),
          b = ne(
            function () {
              return p(
                {
                  publishWhileDragging: pr,
                  updateDroppableScroll: br,
                  updateDroppableIsEnabled: hr,
                  updateDroppableIsCombineEnabled: _r,
                  collectionStarting: gr,
                },
                g,
              );
            },
            [g],
          ),
          h = (function () {
            var e = ne(Ui, []);
            return (
              (0, i.useEffect)(
                function () {
                  return function () {
                    requestAnimationFrame(e.clean);
                  };
                },
                [e],
              ),
              e
            );
          })(),
          _ = ne(
            function () {
              return ai(h, b);
            },
            [h, b],
          ),
          S = ne(
            function () {
              return Gi(
                (0, a.Z)(
                  { scrollWindow: si, scrollDroppable: _.scrollDroppable },
                  p({ move: Sr }, g),
                ),
              );
            },
            [_.scrollDroppable, g],
          ),
          v = (function (e) {
            var t = (0, i.useRef)({}),
              r = (0, i.useRef)(null),
              n = (0, i.useRef)(null),
              a = (0, i.useRef)(!1),
              o = ae(function (e, r) {
                var i = { id: e, focus: r };
                return (
                  (t.current[e] = i),
                  function () {
                    var r = t.current;
                    r[e] !== i && delete r[e];
                  }
                );
              }, []),
              s = ae(
                function (t) {
                  var r = Xi(e, t);
                  r && r !== document.activeElement && r.focus();
                },
                [e],
              ),
              l = ae(function (e, t) {
                r.current === e && (r.current = t);
              }, []),
              c = ae(
                function () {
                  n.current ||
                    (a.current &&
                      (n.current = requestAnimationFrame(function () {
                        n.current = null;
                        var e = r.current;
                        e && s(e);
                      })));
                },
                [s],
              ),
              u = ae(function (e) {
                r.current = null;
                var t = document.activeElement;
                t && t.getAttribute(Ii.draggableId) === e && (r.current = e);
              }, []);
            return (
              Ai(function () {
                return (
                  (a.current = !0),
                  function () {
                    a.current = !1;
                    var e = n.current;
                    e && cancelAnimationFrame(e);
                  }
                );
              }, []),
              ne(
                function () {
                  return {
                    register: o,
                    tryRecordFocus: u,
                    tryRestoreFocusRecorded: c,
                    tryShiftRecord: l,
                  };
                },
                [o, u, c, l],
              )
            );
          })(t),
          y = ne(
            function () {
              return Kr({
                announce: d,
                autoScroller: S,
                dimensionMarshal: _,
                focusMarshal: v,
                getResponders: u,
                styleMarshal: f,
              });
            },
            [d, S, _, v, u, f],
          );
        l.current = y;
        var T = ae(function () {
            var e = An(l);
            "IDLE" !== e.getState().phase && e.dispatch(Br());
          }, []),
          B = ae(function () {
            var e = An(l).getState();
            return e.isDragging || "DROP_ANIMATING" === e.phase;
          }, []);
        r(
          ne(
            function () {
              return { isDragging: B, tryAbort: T };
            },
            [B, T],
          ),
        );
        var R = ae(function (e) {
            return oi(An(l).getState(), e);
          }, []),
          E = ae(function () {
            return Vt(An(l).getState());
          }, []),
          w = ne(
            function () {
              return {
                marshal: _,
                focus: v,
                contextId: t,
                canLift: R,
                isMovementAllowed: E,
                dragHandleUsageInstructionsId: m,
                registry: h,
              };
            },
            [t, _, m, v, R, E, h],
          );
        return (
          zn({
            contextId: t,
            store: y,
            registry: h,
            customSensors: n,
            enableDefaultSensors: !1 !== e.enableDefaultSensors,
          }),
          (0, i.useEffect)(
            function () {
              return T;
            },
            [T],
          ),
          i.createElement(
            Ki.Provider,
            { value: w },
            i.createElement(M, { context: ji, store: y }, e.children),
          )
        );
      }
      var kn = 0;
      function Nn(e) {
        var t = ne(function () {
            return "" + kn++;
          }, []),
          r = e.dragHandleUsageInstructions || Oe.dragHandleUsageInstructions;
        return i.createElement(Ce, null, function (n) {
          return i.createElement(
            Wn,
            {
              nonce: e.nonce,
              contextId: t,
              setCallbacks: n,
              dragHandleUsageInstructions: r,
              enableDefaultSensors: e.enableDefaultSensors,
              sensors: e.sensors,
              onBeforeCapture: e.onBeforeCapture,
              onBeforeDragStart: e.onBeforeDragStart,
              onDragStart: e.onDragStart,
              onDragUpdate: e.onDragUpdate,
              onDragEnd: e.onDragEnd,
            },
            e.children,
          );
        });
      }
      var Ln = function (e) {
          return function (t) {
            return e === t;
          };
        },
        Xn = Ln("scroll"),
        Un = Ln("auto"),
        jn =
          (Ln("visible"),
          function (e, t) {
            return t(e.overflowX) || t(e.overflowY);
          }),
        Hn = function (e) {
          var t = window.getComputedStyle(e),
            r = { overflowX: t.overflowX, overflowY: t.overflowY };
          return jn(r, Xn) || jn(r, Un);
        },
        Vn = function e(t) {
          return null == t ||
            t === document.body ||
            t === document.documentElement
            ? null
            : Hn(t)
              ? t
              : e(t.parentElement);
        },
        qn = function (e) {
          return { x: e.scrollLeft, y: e.scrollTop };
        },
        Zn = function e(t) {
          return (
            !!t &&
            ("fixed" === window.getComputedStyle(t).position ||
              e(t.parentElement))
          );
        },
        Yn = function (e) {
          return { closestScrollable: Vn(e), isFixedOnPage: Zn(e) };
        },
        Jn = function (e) {
          var t = e.ref,
            r = e.descriptor,
            i = e.env,
            n = e.windowScroll,
            a = e.direction,
            o = e.isDropDisabled,
            s = e.isCombineEnabled,
            l = e.shouldClipSubject,
            c = i.closestScrollable,
            u = (function (e, t) {
              var r = be(e);
              if (!t) return r;
              if (e !== t) return r;
              var i = r.paddingBox.top - t.scrollTop,
                n = r.paddingBox.left - t.scrollLeft,
                a = i + t.scrollHeight,
                o = n + t.scrollWidth,
                s = le({ top: i, right: o, bottom: a, left: n }, r.border);
              return de({
                borderBox: s,
                margin: r.margin,
                border: r.border,
                padding: r.padding,
              });
            })(t, c),
            d = pe(u, n),
            m = (function () {
              if (!c) return null;
              var e = be(c),
                t = {
                  scrollHeight: c.scrollHeight,
                  scrollWidth: c.scrollWidth,
                };
              return {
                client: e,
                page: pe(e, n),
                scroll: qn(c),
                scrollSize: t,
                shouldClipSubject: l,
              };
            })(),
            f = (function (e) {
              var t = e.descriptor,
                r = e.isEnabled,
                i = e.isCombineEnabled,
                n = e.isFixedOnPage,
                a = e.direction,
                o = e.client,
                s = e.page,
                l = e.closest,
                c = (function () {
                  if (!l) return null;
                  var e = l.scrollSize,
                    t = l.client,
                    r = Qr({
                      scrollHeight: e.scrollHeight,
                      scrollWidth: e.scrollWidth,
                      height: t.paddingBox.height,
                      width: t.paddingBox.width,
                    });
                  return {
                    pageMarginBox: l.page.marginBox,
                    frameClient: t,
                    scrollSize: e,
                    shouldClipSubject: l.shouldClipSubject,
                    scroll: {
                      initial: l.scroll,
                      current: l.scroll,
                      max: r,
                      diff: { value: Fe, displacement: Fe },
                    },
                  };
                })(),
                u = "vertical" === a ? ft : pt;
              return {
                descriptor: t,
                isCombineEnabled: i,
                isFixedOnPage: n,
                axis: u,
                isEnabled: r,
                client: o,
                page: s,
                frame: c,
                subject: Ve({
                  page: s,
                  withPlaceholder: null,
                  axis: u,
                  frame: c,
                }),
              };
            })({
              descriptor: r,
              isEnabled: !o,
              isCombineEnabled: s,
              isFixedOnPage: i.isFixedOnPage,
              direction: a,
              client: u,
              page: d,
              closest: m,
            });
          return f;
        },
        Kn = { passive: !1 },
        Qn = { passive: !0 },
        $n = function (e) {
          return e.shouldPublishImmediately ? Kn : Qn;
        };
      function ea(e) {
        var t = (0, i.useContext)(e);
        return t || we(!1), t;
      }
      var ta = function (e) {
        return (e && e.env.closestScrollable) || null;
      };
      function ra() {}
      var ia = {
          width: 0,
          height: 0,
          margin: { top: 0, right: 0, bottom: 0, left: 0 },
        },
        na = function (e) {
          var t = e.isAnimatingOpenOnMount,
            r = e.placeholder,
            i = e.animate,
            n = (function (e) {
              var t = e.isAnimatingOpenOnMount,
                r = e.placeholder,
                i = e.animate;
              return t || "close" === i
                ? ia
                : {
                    height: r.client.borderBox.height,
                    width: r.client.borderBox.width,
                    margin: r.client.margin,
                  };
            })({ isAnimatingOpenOnMount: t, placeholder: r, animate: i });
          return {
            display: r.display,
            boxSizing: "border-box",
            width: n.width,
            height: n.height,
            marginTop: n.margin.top,
            marginRight: n.margin.right,
            marginBottom: n.margin.bottom,
            marginLeft: n.margin.left,
            flexShrink: "0",
            flexGrow: "0",
            pointerEvents: "none",
            transition: "none" !== i ? Dr.placeholder : null,
          };
        };
      var aa = i.memo(function (e) {
          var t = (0, i.useRef)(null),
            r = ae(function () {
              t.current && (clearTimeout(t.current), (t.current = null));
            }, []),
            n = e.animate,
            a = e.onTransitionEnd,
            o = e.onClose,
            s = e.contextId,
            l = (0, i.useState)("open" === e.animate),
            c = l[0],
            u = l[1];
          (0, i.useEffect)(
            function () {
              return c
                ? "open" !== n
                  ? (r(), u(!1), ra)
                  : t.current
                    ? ra
                    : ((t.current = setTimeout(function () {
                        (t.current = null), u(!1);
                      })),
                      r)
                : ra;
            },
            [n, c, r],
          );
          var d = ae(
              function (e) {
                "height" === e.propertyName && (a(), "close" === n && o());
              },
              [n, o, a],
            ),
            m = na({
              isAnimatingOpenOnMount: c,
              animate: e.animate,
              placeholder: e.placeholder,
            });
          return i.createElement(e.placeholder.tagName, {
            style: m,
            "data-rbd-placeholder-context-id": s,
            onTransitionEnd: d,
            ref: e.innerRef,
          });
        }),
        oa = i.createContext(null);
      var sa = (function (e) {
          function t() {
            for (
              var t, r = arguments.length, i = new Array(r), n = 0;
              n < r;
              n++
            )
              i[n] = arguments[n];
            return (
              ((t = e.call.apply(e, [this].concat(i)) || this).state = {
                isVisible: Boolean(t.props.on),
                data: t.props.on,
                animate: t.props.shouldAnimate && t.props.on ? "open" : "none",
              }),
              (t.onClose = function () {
                "close" === t.state.animate && t.setState({ isVisible: !1 });
              }),
              t
            );
          }
          return (
            (0, n.Z)(t, e),
            (t.getDerivedStateFromProps = function (e, t) {
              return e.shouldAnimate
                ? e.on
                  ? { isVisible: !0, data: e.on, animate: "open" }
                  : t.isVisible
                    ? { isVisible: !0, data: t.data, animate: "close" }
                    : { isVisible: !1, animate: "close", data: null }
                : { isVisible: Boolean(e.on), data: e.on, animate: "none" };
            }),
            (t.prototype.render = function () {
              if (!this.state.isVisible) return null;
              var e = {
                onClose: this.onClose,
                data: this.state.data,
                animate: this.state.animate,
              };
              return this.props.children(e);
            }),
            t
          );
        })(i.PureComponent),
        la = { dragging: 5e3, dropAnimating: 4500 },
        ca = function (e, t) {
          return t ? Dr.drop(t.duration) : e ? Dr.snap : Dr.fluid;
        },
        ua = function (e, t) {
          return e ? (t ? Gr.drop : Gr.combining) : null;
        },
        da = function (e) {
          return null != e.forceShouldAnimate
            ? e.forceShouldAnimate
            : "SNAP" === e.mode;
        };
      function ma(e) {
        return "DRAGGING" === e.type
          ? (function (e) {
              var t = e.dimension.client,
                r = e.offset,
                i = e.combineWith,
                n = e.dropping,
                a = Boolean(i),
                o = da(e),
                s = Boolean(n),
                l = s ? Fr.drop(r, a) : Fr.moveTo(r);
              return {
                position: "fixed",
                top: t.marginBox.top,
                left: t.marginBox.left,
                boxSizing: "border-box",
                width: t.borderBox.width,
                height: t.borderBox.height,
                transition: ca(o, n),
                transform: l,
                opacity: ua(a, s),
                zIndex: s ? la.dropAnimating : la.dragging,
                pointerEvents: "none",
              };
            })(e)
          : ((t = e),
            {
              transform: Fr.moveTo(t.offset),
              transition: t.shouldAnimateDisplacement ? null : "none",
            });
        var t;
      }
      function fa(e) {
        var t = Ji("draggable"),
          r = e.descriptor,
          n = e.registry,
          a = e.getDraggableRef,
          o = e.canDragInteractiveElements,
          s = e.shouldRespectForcePress,
          l = e.isEnabled,
          c = ne(
            function () {
              return {
                canDragInteractiveElements: o,
                shouldRespectForcePress: s,
                isEnabled: l,
              };
            },
            [o, l, s],
          ),
          u = ae(
            function (e) {
              var t = a();
              return (
                t || we(!1),
                (function (e, t, r) {
                  void 0 === r && (r = Fe);
                  var i = window.getComputedStyle(t),
                    n = t.getBoundingClientRect(),
                    a = ge(n, i),
                    o = pe(a, r);
                  return {
                    descriptor: e,
                    placeholder: {
                      client: a,
                      tagName: t.tagName.toLowerCase(),
                      display: i.display,
                    },
                    displaceBy: { x: a.marginBox.width, y: a.marginBox.height },
                    client: a,
                    page: o,
                  };
                })(r, t, e)
              );
            },
            [r, a],
          ),
          d = ne(
            function () {
              return {
                uniqueId: t,
                descriptor: r,
                options: c,
                getDimension: u,
              };
            },
            [r, u, c, t],
          ),
          m = (0, i.useRef)(d),
          f = (0, i.useRef)(!0);
        Ai(
          function () {
            return (
              n.draggable.register(m.current),
              function () {
                return n.draggable.unregister(m.current);
              }
            );
          },
          [n.draggable],
        ),
          Ai(
            function () {
              if (f.current) f.current = !1;
              else {
                var e = m.current;
                (m.current = d), n.draggable.update(d, e);
              }
            },
            [d, n.draggable],
          );
      }
      function pa(e, t, r) {
        $i();
      }
      function ga(e) {
        e.preventDefault();
      }
      var ba = function (e, t) {
          return e === t;
        },
        ha = function (e) {
          var t = e.combine,
            r = e.destination;
          return r ? r.droppableId : t ? t.droppableId : null;
        };
      function _a(e) {
        return {
          isDragging: !1,
          isDropAnimating: !1,
          isClone: !1,
          dropAnimation: null,
          mode: null,
          draggingOver: null,
          combineTargetFor: e,
          combineWith: null,
        };
      }
      var Sa = {
        mapped: {
          type: "SECONDARY",
          offset: Fe,
          combineTargetFor: null,
          shouldAnimateDisplacement: !0,
          snapshot: _a(null),
        },
      };
      var va = ee(
        function () {
          var e,
            t,
            r,
            i =
              ((e = Se(function (e, t) {
                return { x: e, y: t };
              })),
              (t = Se(function (e, t, r, i, n) {
                return {
                  isDragging: !0,
                  isClone: t,
                  isDropAnimating: Boolean(n),
                  dropAnimation: n,
                  mode: e,
                  draggingOver: r,
                  combineWith: i,
                  combineTargetFor: null,
                };
              })),
              (r = Se(function (e, r, i, n, a, o, s) {
                return {
                  mapped: {
                    type: "DRAGGING",
                    dropping: null,
                    draggingOver: a,
                    combineWith: o,
                    mode: r,
                    offset: e,
                    dimension: i,
                    forceShouldAnimate: s,
                    snapshot: t(r, n, a, o, null),
                  },
                };
              })),
              function (i, n) {
                if (i.isDragging) {
                  if (i.critical.draggable.id !== n.draggableId) return null;
                  var a = i.current.client.offset,
                    o = i.dimensions.draggables[n.draggableId],
                    s = jt(i.impact),
                    l =
                      (u = i.impact).at && "COMBINE" === u.at.type
                        ? u.at.combine.draggableId
                        : null,
                    c = i.forceShouldAnimate;
                  return r(e(a.x, a.y), i.movementMode, o, n.isClone, s, l, c);
                }
                var u;
                if ("DROP_ANIMATING" === i.phase) {
                  var d = i.completed;
                  if (d.result.draggableId !== n.draggableId) return null;
                  var m = n.isClone,
                    f = i.dimensions.draggables[n.draggableId],
                    p = d.result,
                    g = p.mode,
                    b = ha(p),
                    h = (function (e) {
                      return e.combine ? e.combine.draggableId : null;
                    })(p),
                    _ = {
                      duration: i.dropDuration,
                      curve: Cr,
                      moveTo: i.newHomeClientOffset,
                      opacity: h ? Gr.drop : null,
                      scale: h ? Pr.drop : null,
                    };
                  return {
                    mapped: {
                      type: "DRAGGING",
                      offset: i.newHomeClientOffset,
                      dimension: f,
                      dropping: _,
                      draggingOver: b,
                      combineWith: h,
                      mode: g,
                      forceShouldAnimate: null,
                      snapshot: t(g, m, b, h, _),
                    },
                  };
                }
                return null;
              }),
            n = (function () {
              var e = Se(function (e, t) {
                  return { x: e, y: t };
                }),
                t = Se(_a),
                r = Se(function (e, r, i) {
                  return (
                    void 0 === r && (r = null),
                    {
                      mapped: {
                        type: "SECONDARY",
                        offset: e,
                        combineTargetFor: r,
                        shouldAnimateDisplacement: i,
                        snapshot: t(r),
                      },
                    }
                  );
                }),
                i = function (e) {
                  return e ? r(Fe, e, !0) : null;
                },
                n = function (t, n, a, o) {
                  var s = a.displaced.visible[t],
                    l = Boolean(o.inVirtualList && o.effected[t]),
                    c = nt(a),
                    u = c && c.draggableId === t ? n : null;
                  if (!s) {
                    if (!l) return i(u);
                    if (a.displaced.invisible[t]) return null;
                    var d = We(o.displacedBy.point),
                      m = e(d.x, d.y);
                    return r(m, u, !0);
                  }
                  if (l) return i(u);
                  var f = a.displacedBy.point,
                    p = e(f.x, f.y);
                  return r(p, u, s.shouldAnimate);
                };
              return function (e, t) {
                if (e.isDragging)
                  return e.critical.draggable.id === t.draggableId
                    ? null
                    : n(
                        t.draggableId,
                        e.critical.draggable.id,
                        e.impact,
                        e.afterCritical,
                      );
                if ("DROP_ANIMATING" === e.phase) {
                  var r = e.completed;
                  return r.result.draggableId === t.draggableId
                    ? null
                    : n(
                        t.draggableId,
                        r.result.draggableId,
                        r.impact,
                        r.afterCritical,
                      );
                }
                return null;
              };
            })();
          return function (e, t) {
            return i(e, t) || n(e, t) || Sa;
          };
        },
        { dropAnimationFinished: wr },
        null,
        { context: ji, pure: !0, areStatePropsEqual: ba },
      )(function (e) {
        var t = (0, i.useRef)(null),
          r = ae(function (e) {
            t.current = e;
          }, []),
          n = ae(function () {
            return t.current;
          }, []),
          a = ea(Ki),
          o = a.contextId,
          s = a.dragHandleUsageInstructionsId,
          l = a.registry,
          c = ea(oa),
          u = c.type,
          d = c.droppableId,
          m = ne(
            function () {
              return {
                id: e.draggableId,
                index: e.index,
                type: u,
                droppableId: d,
              };
            },
            [e.draggableId, e.index, u, d],
          ),
          f = e.children,
          p = e.draggableId,
          g = e.isEnabled,
          b = e.shouldRespectForcePress,
          h = e.canDragInteractiveElements,
          _ = e.isClone,
          S = e.mapped,
          v = e.dropAnimationFinished;
        pa(),
          Qi(),
          _ ||
            fa(
              ne(
                function () {
                  return {
                    descriptor: m,
                    registry: l,
                    getDraggableRef: n,
                    canDragInteractiveElements: h,
                    shouldRespectForcePress: b,
                    isEnabled: g,
                  };
                },
                [m, l, n, h, b, g],
              ),
            );
        var y = ne(
            function () {
              return g
                ? {
                    tabIndex: 0,
                    role: "button",
                    "aria-describedby": s,
                    "data-rbd-drag-handle-draggable-id": p,
                    "data-rbd-drag-handle-context-id": o,
                    draggable: !1,
                    onDragStart: ga,
                  }
                : null;
            },
            [o, s, p, g],
          ),
          M = ae(
            function (e) {
              "DRAGGING" === S.type &&
                S.dropping &&
                "transform" === e.propertyName &&
                v();
            },
            [v, S],
          ),
          T = ne(
            function () {
              var e = ma(S),
                t = "DRAGGING" === S.type && S.dropping ? M : null;
              return {
                innerRef: r,
                draggableProps: {
                  "data-rbd-draggable-context-id": o,
                  "data-rbd-draggable-id": p,
                  style: e,
                  onTransitionEnd: t,
                },
                dragHandleProps: y,
              };
            },
            [o, y, p, S, M, r],
          ),
          B = ne(
            function () {
              return {
                draggableId: m.id,
                type: m.type,
                source: { index: m.index, droppableId: m.droppableId },
              };
            },
            [m.droppableId, m.id, m.index, m.type],
          );
        return f(T, S.snapshot, B);
      });
      function ya(e) {
        return ea(oa).isUsingCloneFor !== e.draggableId || e.isClone
          ? i.createElement(va, e)
          : null;
      }
      function Ma(e) {
        var t = "boolean" != typeof e.isDragDisabled || !e.isDragDisabled,
          r = Boolean(e.disableInteractiveElementBlocking),
          n = Boolean(e.shouldRespectForcePress);
        return i.createElement(
          ya,
          (0, a.Z)({}, e, {
            isClone: !1,
            isEnabled: t,
            canDragInteractiveElements: r,
            shouldRespectForcePress: n,
          }),
        );
      }
      var Ta = function (e, t) {
          return e === t.droppable.type;
        },
        Ba = function (e, t) {
          return t.draggables[e.draggable.id];
        };
      var Ra = {
          mode: "standard",
          type: "DEFAULT",
          direction: "vertical",
          isDropDisabled: !1,
          isCombineEnabled: !1,
          ignoreContainerClipping: !1,
          renderClone: null,
          getContainerForClone: function () {
            return document.body || we(!1), document.body;
          },
        },
        Ea = ee(
          function () {
            var e = {
                placeholder: null,
                shouldAnimatePlaceholder: !0,
                snapshot: {
                  isDraggingOver: !1,
                  draggingOverWith: null,
                  draggingFromThisWith: null,
                  isUsingPlaceholder: !1,
                },
                useClone: null,
              },
              t = (0, a.Z)({}, e, { shouldAnimatePlaceholder: !1 }),
              r = Se(function (e) {
                return {
                  draggableId: e.id,
                  type: e.type,
                  source: { index: e.index, droppableId: e.droppableId },
                };
              }),
              i = Se(function (i, n, a, o, s, l) {
                var c = s.descriptor.id;
                if (s.descriptor.droppableId === i) {
                  var u = l ? { render: l, dragging: r(s.descriptor) } : null,
                    d = {
                      isDraggingOver: a,
                      draggingOverWith: a ? c : null,
                      draggingFromThisWith: c,
                      isUsingPlaceholder: !0,
                    };
                  return {
                    placeholder: s.placeholder,
                    shouldAnimatePlaceholder: !1,
                    snapshot: d,
                    useClone: u,
                  };
                }
                if (!n) return t;
                if (!o) return e;
                var m = {
                  isDraggingOver: a,
                  draggingOverWith: c,
                  draggingFromThisWith: null,
                  isUsingPlaceholder: !0,
                };
                return {
                  placeholder: s.placeholder,
                  shouldAnimatePlaceholder: !0,
                  snapshot: m,
                  useClone: null,
                };
              });
            return function (r, n) {
              var a = n.droppableId,
                o = n.type,
                s = !n.isDropDisabled,
                l = n.renderClone;
              if (r.isDragging) {
                var c = r.critical;
                if (!Ta(o, c)) return t;
                var u = Ba(c, r.dimensions),
                  d = jt(r.impact) === a;
                return i(a, s, d, d, u, l);
              }
              if ("DROP_ANIMATING" === r.phase) {
                var m = r.completed;
                if (!Ta(o, m.critical)) return t;
                var f = Ba(m.critical, r.dimensions);
                return i(a, s, ha(m.result) === a, jt(m.impact) === a, f, l);
              }
              if ("IDLE" === r.phase && r.completed && !r.shouldFlush) {
                var p = r.completed;
                if (!Ta(o, p.critical)) return t;
                var g = jt(p.impact) === a,
                  b = Boolean(p.impact.at && "COMBINE" === p.impact.at.type),
                  h = p.critical.droppable.id === a;
                return g ? (b ? e : t) : h ? e : t;
              }
              return t;
            };
          },
          {
            updateViewportMaxScroll: function (e) {
              return { type: "UPDATE_VIEWPORT_MAX_SCROLL", payload: e };
            },
          },
          null,
          { context: ji, pure: !0, areStatePropsEqual: ba },
        )(function (e) {
          var t = (0, i.useContext)(Ki);
          t || we(!1);
          var r = t.contextId,
            n = t.isMovementAllowed,
            a = (0, i.useRef)(null),
            o = (0, i.useRef)(null),
            s = e.children,
            l = e.droppableId,
            c = e.type,
            u = e.mode,
            d = e.direction,
            m = e.ignoreContainerClipping,
            f = e.isDropDisabled,
            p = e.isCombineEnabled,
            g = e.snapshot,
            b = e.useClone,
            h = e.updateViewportMaxScroll,
            _ = e.getContainerForClone,
            S = ae(function () {
              return a.current;
            }, []),
            v = ae(function (e) {
              a.current = e;
            }, []),
            y =
              (ae(function () {
                return o.current;
              }, []),
              ae(function (e) {
                o.current = e;
              }, []));
          $i();
          var M = ae(
            function () {
              n() && h({ maxScroll: ei() });
            },
            [n, h],
          );
          !(function (e) {
            var t = (0, i.useRef)(null),
              r = ea(Ki),
              n = Ji("droppable"),
              a = r.registry,
              o = r.marshal,
              s = en(e),
              l = ne(
                function () {
                  return { id: e.droppableId, type: e.type, mode: e.mode };
                },
                [e.droppableId, e.mode, e.type],
              ),
              c = (0, i.useRef)(l),
              u = ne(
                function () {
                  return Se(function (e, r) {
                    t.current || we(!1);
                    var i = { x: e, y: r };
                    o.updateDroppableScroll(l.id, i);
                  });
                },
                [l.id, o],
              ),
              d = ae(function () {
                var e = t.current;
                return e && e.env.closestScrollable
                  ? qn(e.env.closestScrollable)
                  : Fe;
              }, []),
              m = ae(
                function () {
                  var e = d();
                  u(e.x, e.y);
                },
                [d, u],
              ),
              f = ne(
                function () {
                  return ve(m);
                },
                [m],
              ),
              p = ae(
                function () {
                  var e = t.current,
                    r = ta(e);
                  (e && r) || we(!1),
                    e.scrollOptions.shouldPublishImmediately ? m() : f();
                },
                [f, m],
              ),
              g = ae(
                function (e, i) {
                  t.current && we(!1);
                  var n = s.current,
                    a = n.getDroppableRef();
                  a || we(!1);
                  var o = Yn(a),
                    c = { ref: a, descriptor: l, env: o, scrollOptions: i };
                  t.current = c;
                  var u = Jn({
                      ref: a,
                      descriptor: l,
                      env: o,
                      windowScroll: e,
                      direction: n.direction,
                      isDropDisabled: n.isDropDisabled,
                      isCombineEnabled: n.isCombineEnabled,
                      shouldClipSubject: !n.ignoreContainerClipping,
                    }),
                    d = o.closestScrollable;
                  return (
                    d &&
                      (d.setAttribute(Fi.contextId, r.contextId),
                      d.addEventListener("scroll", p, $n(c.scrollOptions))),
                    u
                  );
                },
                [r.contextId, l, p, s],
              ),
              b = ae(function () {
                var e = t.current,
                  r = ta(e);
                return (e && r) || we(!1), qn(r);
              }, []),
              h = ae(
                function () {
                  var e = t.current;
                  e || we(!1);
                  var r = ta(e);
                  (t.current = null),
                    r &&
                      (f.cancel(),
                      r.removeAttribute(Fi.contextId),
                      r.removeEventListener("scroll", p, $n(e.scrollOptions)));
                },
                [p, f],
              ),
              _ = ae(function (e) {
                var r = t.current;
                r || we(!1);
                var i = ta(r);
                i || we(!1), (i.scrollTop += e.y), (i.scrollLeft += e.x);
              }, []),
              S = ne(
                function () {
                  return {
                    getDimensionAndWatchScroll: g,
                    getScrollWhileDragging: b,
                    dragStopped: h,
                    scroll: _,
                  };
                },
                [h, g, b, _],
              ),
              v = ne(
                function () {
                  return { uniqueId: n, descriptor: l, callbacks: S };
                },
                [S, l, n],
              );
            Ai(
              function () {
                return (
                  (c.current = v.descriptor),
                  a.droppable.register(v),
                  function () {
                    t.current && h(), a.droppable.unregister(v);
                  }
                );
              },
              [S, l, h, v, o, a.droppable],
            ),
              Ai(
                function () {
                  t.current &&
                    o.updateDroppableIsEnabled(c.current.id, !e.isDropDisabled);
                },
                [e.isDropDisabled, o],
              ),
              Ai(
                function () {
                  t.current &&
                    o.updateDroppableIsCombineEnabled(
                      c.current.id,
                      e.isCombineEnabled,
                    );
                },
                [e.isCombineEnabled, o],
              );
          })({
            droppableId: l,
            type: c,
            mode: u,
            direction: d,
            isDropDisabled: f,
            isCombineEnabled: p,
            ignoreContainerClipping: m,
            getDroppableRef: S,
          });
          var T = i.createElement(
              sa,
              { on: e.placeholder, shouldAnimate: e.shouldAnimatePlaceholder },
              function (e) {
                var t = e.onClose,
                  n = e.data,
                  a = e.animate;
                return i.createElement(aa, {
                  placeholder: n,
                  onClose: t,
                  innerRef: y,
                  animate: a,
                  contextId: r,
                  onTransitionEnd: M,
                });
              },
            ),
            B = ne(
              function () {
                return {
                  innerRef: v,
                  placeholder: T,
                  droppableProps: {
                    "data-rbd-droppable-id": l,
                    "data-rbd-droppable-context-id": r,
                  },
                };
              },
              [r, l, T, v],
            ),
            R = b ? b.dragging.draggableId : null,
            E = ne(
              function () {
                return { droppableId: l, type: c, isUsingCloneFor: R };
              },
              [l, R, c],
            );
          return i.createElement(
            oa.Provider,
            { value: E },
            s(B, g),
            (function () {
              if (!b) return null;
              var e = b.dragging,
                t = b.render,
                r = i.createElement(
                  ya,
                  {
                    draggableId: e.draggableId,
                    index: e.source.index,
                    isClone: !0,
                    isEnabled: !0,
                    shouldRespectForcePress: !1,
                    canDragInteractiveElements: !0,
                  },
                  function (r, i) {
                    return t(r, i, e);
                  },
                );
              return re.createPortal(r, _());
            })(),
          );
        });
      Ea.defaultProps = Ra;
    },
    73923: (e, t) => {
      "use strict";
      var r = 60103,
        i = 60106,
        n = 60107,
        a = 60108,
        o = 60114,
        s = 60109,
        l = 60110,
        c = 60112,
        u = 60113,
        d = 60120,
        m = 60115,
        f = 60116,
        p = 60121,
        g = 60122,
        b = 60117,
        h = 60129,
        _ = 60131;
      /** @license React v17.0.2
       * react-is.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */ if ("function" == typeof Symbol && Symbol.for) {
        var S = Symbol.for;
        (r = S("react.element")),
          (i = S("react.portal")),
          (n = S("react.fragment")),
          (a = S("react.strict_mode")),
          (o = S("react.profiler")),
          (s = S("react.provider")),
          (l = S("react.context")),
          (c = S("react.forward_ref")),
          (u = S("react.suspense")),
          (d = S("react.suspense_list")),
          (m = S("react.memo")),
          (f = S("react.lazy")),
          (p = S("react.block")),
          (g = S("react.server.block")),
          (b = S("react.fundamental")),
          (h = S("react.debug_trace_mode")),
          (_ = S("react.legacy_hidden"));
      }
      function v(e) {
        if ("object" == typeof e && null !== e) {
          var t = e.$$typeof;
          switch (t) {
            case r:
              switch ((e = e.type)) {
                case n:
                case o:
                case a:
                case u:
                case d:
                  return e;
                default:
                  switch ((e = e && e.$$typeof)) {
                    case l:
                    case c:
                    case f:
                    case m:
                    case s:
                      return e;
                    default:
                      return t;
                  }
              }
            case i:
              return t;
          }
        }
      }
      t.isContextConsumer = function (e) {
        return v(e) === l;
      };
    },
    14753: (e, t, r) => {
      "use strict";
      e.exports = r(73923);
    },
    12015: (e, t, r) => {
      "use strict";
      r.d(t, {
        F0: () => l,
        Rv: () => o,
        UV: () => u,
        Zb: () => c,
        aF: () => s,
        hB: () => a,
      });
      const i = new (r(68785).sO)("GR");
      function n(e) {
        return (...t) => {
          const r = `[${(performance.now() / 1e3).toFixed(3)}]`;
          e(r, ...t);
        };
      }
      const a = n(i.Debug),
        o = n(i.Info),
        s = n(i.Warning),
        l = n(i.Error),
        c = a;
      function u() {
        return i.IsDebugEnabled();
      }
    },
    7286: (e, t, r) => {
      "use strict";
      r.d(t, { Gn: () => p, m8: () => i, nW: () => b });
      var i,
        n = r(30750),
        a = r(47427),
        o = r(57003),
        s = r(13129),
        l = r(31846),
        c = r(13944),
        u = r(59728),
        d = r(91707),
        m = r(77556),
        f = r(91618);
      function p() {
        const e = b((0, c.we)().GetGameID());
        return e === i.NotRecording || e === i.NotRunning
          ? null
          : a.createElement(g, null);
      }
      function g(e) {
        const t = (0, c.we)(),
          r = (0, n.SZ)(() => t.GetIsLiveEdge() && !t.GetHidePlayer()),
          i = a.useCallback(() => {
            t.SetHidePlayer(!1), t.GetGameRecordingVideo().Play();
            const e = t.GetLiveEdgeMS();
            t.SetPlaytimeFromGlobalMS(e), t.FocusGlobalMS(e);
          }, [t]);
        return a.createElement(
          u.HP,
          {
            className: o.GoLiveButtonCtn,
            toolTipContent: (0, l.Xx)(
              r ? "#Playback_AtLatest" : "#Playback_JumpToLatest",
            ),
            direction: "bottom",
          },
          a.createElement(
            f.s,
            { onClick: i, className: (0, s.Z)(o.GoLiveButton, r && o.IsLive) },
            a.createElement(m.KD, { className: (0, s.Z)(o.JumpToEndIcon) }),
          ),
        );
      }
      function b(e) {
        const { app: t } = (0, d.qX)(e);
        if (!t) return i.NotRecording;
        switch (t.recording_type) {
          default:
          case 0:
          case 1:
            return i.NotRecording;
          case 2:
            return i.ManualRecording;
          case 3:
            return i.BackgroundRecording;
        }
      }
      !(function (e) {
        (e.NotRunning = "NotRunning"),
          (e.NotRecording = "NotRecording"),
          (e.ManualRecording = "ManualRecording"),
          (e.BackgroundRecording = "BackgroundRecording"),
          (e.ForeverRecording = "ForeverRecording");
      })(i || (i = {}));
    },
    91707: (e, t, r) => {
      "use strict";
      r.d(t, {
        $H: () => m,
        B$: () => f,
        Mo: () => d,
        Ou: () => c,
        no: () => u,
        qX: () => l,
      });
      var i = r(47427),
        n = r(30750),
        a = r(54842);
      function o() {
        return window.g_GRS;
      }
      function s() {
        if (null != o()) {
          const e = o();
          return {
            bLoading: e.BLoadingAppsWithTimelines(),
            rgApps: e.GetAppsWithTimelinesWithVideo(),
          };
        }
        return { bLoading: !1, rgApps: [] };
      }
      function l(e) {
        const { bLoading: t, rgApps: r } = (function () {
          const [e, t] = (0, i.useState)(s());
          return (0, i.useEffect)(() => (0, a.U5)(s, t), []), e;
        })();
        return {
          bLoading: t,
          app: (0, i.useMemo)(() => r.find((t) => t.game_id === e), [r, e]),
        };
      }
      function c(e) {
        return (null != o() && e && o().GetClipSummariesForGame(e)) || [];
      }
      function u(e, t, r, i, n, a) {
        return null != o() ? o().LoadThumbnails(e, t, r, i, n, a ?? !0) : null;
      }
      function d() {
        return null != o()
          ? {
              fnCreateUserTimelineMarkers: o().CreateUserTimelineMarkers,
              fnUpdateUserTimelineMarkers: o().UpdateUserTimelineMarkers,
              fnRemoveUserTimelineMarker: o().RemoveUserTimelineMarker,
            }
          : null;
      }
      function m(e, t) {
        return (0, n.SZ)(() => {
          if (null != o()) return o().GetAchivementInfo(e, t);
        });
      }
      function f() {
        return (0, n.SZ)(() => {
          if (null != o()) return !o().BEnoughDiskSpace();
        });
      }
    },
    74666: (e, t, r) => {
      "use strict";
      var i, n;
      function a(e) {
        return "gamemode" === e.type;
      }
      function o(e) {
        return "state_description" === e.type;
      }
      function s(e) {
        return "event" === e.type && parseInt(e.duration) > 0;
      }
      function l(e) {
        return "event" === e.type;
      }
      function c(e) {
        return "achievement" === e.type;
      }
      function u(e) {
        return "error" === e.type;
      }
      function d(e) {
        return "usermarker" === e.type;
      }
      function m(e) {
        return "screenshot" === e.type;
      }
      function f(e) {
        let t = { id: e.entry_id, time: e.time, type: void 0 };
        switch (e.type) {
          case 1: {
            let r = t;
            (r.type = "gamemode"), (r.mode = e.game_mode);
            break;
          }
          case 5: {
            let r = t;
            (r.type = "usermarker"),
              (r.icon = "steam_marker"),
              (r.priority = e.marker_priority);
            break;
          }
          case 4: {
            let r = t;
            (r.type = "achievement"), (r.achievement_name = e.achievement_name);
            break;
          }
          case 7: {
            let r = t;
            (r.type = "error"), (r.description = e.marker_description);
            break;
          }
          case 3: {
            let r = t;
            (r.type = "state_description"), (r.title = e.timestamp_title);
            break;
          }
          case 2: {
            let r = t;
            (r.type = "event"),
              (r.icon = e.marker_icon),
              (r.title = e.range_title),
              (r.description = e.marker_description),
              (r.priority = e.marker_priority),
              (r.duration = e.range_duration),
              (r.possible_clip = e.range_possible_clip);
            break;
          }
          case 6: {
            let r = t;
            (r.type = "screenshot"),
              (r.icon = e.marker_icon),
              (r.priority = e.marker_priority),
              (r.handle = e.screenshot_handle);
            break;
          }
          default:
            return null;
        }
        return t;
      }
      r.d(t, {
        CR: () => u,
        ED: () => a,
        Ml: () => i,
        PA: () => o,
        XD: () => f,
        l8: () => m,
        m6: () => c,
        pf: () => s,
        ph: () => d,
        tm: () => l,
      }),
        (function (e) {
          (e[(e.Invalid = 0)] = "Invalid"),
            (e[(e.Playing = 1)] = "Playing"),
            (e[(e.Staging = 2)] = "Staging"),
            (e[(e.Menus = 3)] = "Menus");
        })(i || (i = {})),
        (function (e) {
          (e[(e.Invalid = 0)] = "Invalid"),
            (e[(e.None = 1)] = "None"),
            (e[(e.Standard = 2)] = "Standard"),
            (e[(e.Featured = 3)] = "Featured");
        })(n || (n = {}));
    },
    40420: (e, t, r) => {
      "use strict";
      function i(e) {
        return { type: "global", valMS: e };
      }
      function n(e) {
        return { type: "timeline", valMS: e };
      }
      function a(e) {
        return (t) => t.type === e;
      }
      r.d(t, { Z6: () => i, bu: () => o, pX: () => n, yj: () => s });
      a("global"), a("timeline"), a("recording"), a("clip");
      function o(e) {
        return { type: "global", valPX: e };
      }
      function s(e) {
        return { type: "scrollWindow", valPX: e };
      }
      function l(e) {
        return (t) => t.type === e;
      }
      l("global"), l("clientWindow"), l("virtualWindow"), l("scrollWindow");
    },
    27821: (e, t, r) => {
      "use strict";
      r.d(t, { k9: () => $t, $z: () => Qt, Lj: () => Kt });
      var i = r(47427),
        n = r(30750),
        a = r(57837),
        o = r(13129),
        s = r(85556),
        l = r(54842),
        c = r(45651),
        u = r(87225),
        d = r(12015),
        m = r(20417),
        f = r(40420);
      const p = { nBeforeMS: 0, nAfterMS: 12e3 },
        g = i.createContext({
          globalStartMS: void 0,
          globalEndMS: void 0,
          setRange: null,
          setStartMS: null,
          setEndMS: null,
          globalPreviewStartMS: void 0,
          globalPreviewEndMS: void 0,
          setPreviewRange: null,
          clearPreviewSelection: null,
          selectionZoomCount: 0,
          eInitMethod: void 0,
          startMetrics: void 0,
          endMetrics: void 0,
          zoomIntoSelection: null,
          zoomOutSelection: null,
        });
      function b() {
        const e = (0, i.useContext)(g);
        return { nGlobalStartMS: e.globalStartMS, nGlobalEndMS: e.globalEndMS };
      }
      function h() {
        return (0, i.useContext)(g).globalStartMS;
      }
      function _() {
        return (0, i.useContext)(g).globalEndMS;
      }
      function S() {
        return (0, i.useContext)(g).setRange;
      }
      function v() {
        return (0, i.useContext)(g).setStartMS;
      }
      function y() {
        return (0, i.useContext)(g).setEndMS;
      }
      function M() {
        const e = (0, i.useContext)(g);
        return {
          selectedMarker: e.selectedMarker,
          setSelectedMarker: e.setSelectedMarker,
        };
      }
      function T() {
        const e = (0, i.useContext)(g);
        return !isNaN(e.globalStartMS?.valMS) && !isNaN(e.globalEndMS?.valMS);
      }
      const B = 10;
      class R {
        m_loader;
        m_playbackCoordinator;
        m_fnUnregisterFromLoader;
        m_fnUnregisterPlaybackCoordinator;
        m_refTimelineParentCtn;
        m_durationMS = 0;
        m_mapTimelineClips = l.LO.map([], { deep: !1 });
        m_scrollLeftPX = 0;
        m_scrollWindowWidth = null;
        m_scrollWindowOffsetPX = null;
        m_bAutoScrollPaused = !1;
        m_autoScrollPauseTimeout = null;
        m_msVisible = 0;
        m_prevLeftAndVisible = null;
        m_rgTimelineOffsets = [];
        m_mapTimelineEntries = l.LO.map([], { deep: !1 });
        m_bInitialized = !1;
        constructor(e, t, r) {
          (0, l.rC)(this),
            (this.m_loader = e),
            (this.m_playbackCoordinator = t),
            (this.m_fnUnregisterFromLoader =
              this.m_loader.AddEventListener(this)),
            (this.m_fnUnregisterPlaybackCoordinator = t.AddEventListener(this)),
            this.UpdateClipSummaries(r),
            e.BInitialized() && this.OnLoaderInitialized();
        }
        BInitialized() {
          return this.m_bInitialized;
        }
        OnLoaderInitialized() {
          (this.m_durationMS = this.m_loader.GetGlobalTimelineEndMS().valMS),
            this.OnInvalidate(),
            this.InitDefaultsIfReady();
        }
        InitDefaultsIfReady() {
          !this.m_bInitialized &&
            this.m_scrollWindowWidth &&
            this.m_loader.BInitialized() &&
            ((this.m_bInitialized = !0),
            (this.m_msVisible = this.ComputeDefaultMSVisible()),
            this.ScrollToCenteredGlobalMS(
              this.m_playbackCoordinator.GetGlobalMSPlaytime().valMS,
            ));
        }
        OnTimelineLoaded(e) {
          (0, d.hB)("OnTimelineLoaded", e);
          this.FindTimelineOffsets(e)
            ? this.ComputeEntriesForTimeline(e)
            : (0, d.Zb)("Missing timeline offset metadata for", e);
        }
        OnInvalidate(e) {
          (0, d.hB)("on invalidate ", e);
          const t = this.m_loader.GetGlobalTimelineEndMS().valMS,
            r = t - this.m_durationMS,
            i = this.m_durationMS <= 0,
            n =
              this.m_durationMS +
              this.ConvertDeltaPXToDurationMS(
                B * (this.m_rgTimelineOffsets.length - 1) +
                  2 * this.GetTimelineMarginWidth(),
              ),
            a = this.m_msVisible >= n;
          let o;
          if (
            ((this.m_durationMS = t),
            r > 0 && !this.m_bAutoScrollPaused && (a || i))
          )
            this.m_msVisible = this.ComputeDefaultMSVisible();
          else if (r < 0 && this.m_msVisible > t)
            (this.m_msVisible = this.ComputeDefaultMSVisible()),
              this.ScrollToOffset(0);
          else if (r < 0) {
            const e = this.FindClosestTimelineStartForOffsetPX(
              this.m_scrollLeftPX,
            );
            if (e) {
              const t = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
                r = this.ConvertDeltaPXToDurationMS(this.m_scrollLeftPX - t);
              o = { strTimelineID: e.timelineID, nTimelineOffsetMS: r };
            }
          }
          const s = this.m_loader.GetTimelines();
          let l = 0;
          if (this.BInitialized() && e) {
            const t = s.findIndex((t) => t.metadata.timeline_id === e);
            t >= 0 && (l = t);
          }
          if (
            ((this.m_rgTimelineOffsets = s.map((e, t) =>
              t >= l
                ? this.ComputeTimelineOffset(e)
                : this.m_rgTimelineOffsets[t],
            )),
            o)
          ) {
            const e = this.FindTimelineOffsets(o.strTimelineID);
            if (e) {
              const t = e.globalOffsetMS + o.nTimelineOffsetMS,
                r = (0, c.Lh)(
                  this.ConvertGlobalMSToGlobalPXOffset(t),
                  0,
                  this.GetMaxScrollLeftPX(),
                );
              this.ScrollToOffset(r);
            }
          }
          s.forEach((e, t) => {
            t >= l && this.ComputeEntriesForTimeline(e.metadata.timeline_id);
          });
        }
        OnFocusGlobalMS(e) {
          this.ScrollToCenteredGlobalMS(e.valMS);
        }
        GetGameID() {
          return this.m_loader.GetGameID();
        }
        SetTimelineParentCtnRef(e) {
          this.m_refTimelineParentCtn = e;
        }
        GetTimelineParentCtnRef() {
          return this.m_refTimelineParentCtn;
        }
        Close() {
          this.m_fnUnregisterFromLoader && this.m_fnUnregisterFromLoader(),
            this.m_fnUnregisterPlaybackCoordinator &&
              this.m_fnUnregisterPlaybackCoordinator(),
            (this.m_fnUnregisterFromLoader = null),
            (this.m_fnUnregisterPlaybackCoordinator = null),
            (this.m_loader = null),
            (this.m_bInitialized = !1),
            this.m_autoScrollPauseTimeout && this.ClearAutoScrollPauseTimeout();
        }
        ComputeDefaultMSVisible() {
          const e = 2 * this.GetTimelineMarginWidth(),
            t = B * (this.m_rgTimelineOffsets.length - 1),
            r = Math.max(1, this.m_scrollWindowWidth - t - e),
            i = Math.ceil(
              ((e + t) * this.m_durationMS) /
                (this.m_scrollWindowWidth - (e + t)),
            ),
            n = 1e3 * r;
          return Math.min(this.m_durationMS + i, n);
        }
        ZoomIn(e, t) {
          if (this.m_msVisible <= 1e3) return;
          const r = this.m_msVisible - this.m_msVisible / 1.1 ** e,
            i = r * t,
            n = this.ConvertPXOffsetToGlobalMS(this.m_scrollLeftPX),
            a = Math.max(this.m_msVisible - r, 1e3);
          (this.m_msVisible = a),
            this.ScrollToOffset(this.ConvertGlobalMSToGlobalPXOffset(n + i));
        }
        ZoomOut(e, t) {
          const r =
            this.m_durationMS +
            this.ConvertDeltaPXToDurationMS(
              B * (this.m_rgTimelineOffsets.length - 1) +
                2 * this.GetTimelineMarginWidth(),
            );
          if (this.m_msVisible >= r) return;
          const i = this.m_msVisible * 1.1 ** e - this.m_msVisible,
            n = i * t,
            a = this.ConvertPXOffsetToGlobalMS(this.m_scrollLeftPX),
            o = Math.min(this.m_msVisible + i, r);
          (this.m_msVisible = o),
            this.ScrollToOffset(this.ConvertGlobalMSToGlobalPXOffset(a - n));
        }
        SetTempZoomScale(e, t) {
          let r = Math.max(e, 0),
            i = Math.min(t, this.m_durationMS);
          (this.m_prevLeftAndVisible = [this.m_scrollLeftPX, this.m_msVisible]),
            (this.m_msVisible = i - r);
          const n = this.ConvertGlobalMSToGlobalPXOffset(r);
          this.ScrollToOffset(n);
        }
        ClearTempZoomScale() {
          if (!this.m_prevLeftAndVisible) return;
          const [e, t] = this.m_prevLeftAndVisible;
          (this.m_prevLeftAndVisible = null),
            this.ScrollToOffset(e),
            (this.m_msVisible = t);
        }
        GetTimelineGapWidth() {
          return B;
        }
        GetTimelineMarginWidth() {
          return 12;
        }
        UpdateClipSummaries(e = []) {
          this.m_mapTimelineClips.clear(),
            e.forEach((e) => {
              const t = e.start_timeline_id;
              this.m_mapTimelineClips.has(t) ||
                this.m_mapTimelineClips.set(t, []);
              const r = {
                clipID: e.clip_id,
                msDuration: parseInt(e.duration_ms),
                msTimelineOffset: parseInt(e.start_offset_ms),
                timelineID: t,
              };
              this.m_mapTimelineClips.get(t).push(r);
            });
        }
        GetNumTimelines() {
          return this.m_loader.GetTimelines().length;
        }
        ComputeTimelineOffset(e) {
          const t = isNaN(parseInt(e.metadata.duration_ms))
              ? 0
              : parseInt(e.metadata.duration_ms),
            r = e.metadata.recordings.map((e) => {
              const r = parseInt(e.start_offset_ms);
              let i = parseInt(e.duration_ms);
              return (
                isNaN(i) &&
                  this.m_loader.IsActiveRecording(e.recording_id) &&
                  (i = t - r),
                {
                  recordingID: e.recording_id,
                  timelineOffsetMS: r,
                  nDurationMS: i,
                  bIsActive: this.m_loader.IsActiveRecording(e.recording_id),
                  recordingType: e.recording_type,
                }
              );
            });
          return {
            timelineID: e.metadata.timeline_id,
            globalOffsetMS: e.nGlobalOffsetMS.valMS,
            nDurationMS: t,
            recordingOffsets: r,
          };
        }
        GetCurrentZoomScale() {
          return this.m_msVisible / (this.m_scrollWindowWidth || 1) || 1;
        }
        GetClipsForTimeline(e) {
          return this.m_mapTimelineClips.get(e) || [];
        }
        ComputeEntriesForTimeline(e) {
          const t = this.m_loader.GetTimelineDataOrStartLoad(e);
          t &&
            "loaded" == t.m_strState &&
            this.m_mapTimelineEntries.set(e, {
              rgGameModes: t.m_rgGameModeChanges,
              rgHighlights: t.m_rgEntries,
            });
        }
        GetVisibleTimelineGameModes(e) {
          return this.m_mapTimelineEntries.get(e)?.rgGameModes;
        }
        GetVisibleTimelineHighlights(e) {
          return this.m_mapTimelineEntries.get(e)?.rgHighlights;
        }
        GetStateDescriptionAtGlobalMS(e) {
          return this.m_loader.GetStateDescriptionAtGlobalMS((0, f.Z6)(e));
        }
        GetTimelineOffsetMS(e) {
          return this.m_loader.GetTimelineStartBeforeGlobalZeroMS(e);
        }
        FetchTimelineEntries(e, t) {
          return this.FetchTimelineEntriesWorker(
            e,
            t,
            this.m_loader.GetIteratorEntriesWithin,
          );
        }
        FetchTimelineEntriesWorker(e, t, r) {
          const i = this.ConvertPXOffsetToGlobalMS(
            this.GetVirtualWindowEndPX(),
          );
          let n = this.m_loader.CreateTimelineIterator(t, 0);
          if (this.m_loader.HasIteratorReachedEnd(n))
            return { strState: "error", rgEntry: [] };
          let a = [];
          const o = this.m_loader.GetIteratorTimelineState(n);
          if ("loaded" == o)
            for (let o of r(n, i - t))
              if (e.includes(o.type)) {
                const e = { ...o, time: o.time - n.m_nTimelineOffsetMS };
                a.push(e);
              }
          return { strState: o, rgEntry: a };
        }
        ScrollToCenteredGlobalMS(e) {
          const t = this.ConvertGlobalMSToGlobalPXOffset(e);
          this.ScrollToOffsetCentered(t);
        }
        ScrollToOffset(e) {
          this.m_scrollLeftPX = (0, c.Lh)(e, 0, this.GetMaxScrollLeftPX());
        }
        ScrollToOffsetCentered(e) {
          const t = Math.max(0, e - 0.5 * this.m_scrollWindowWidth);
          this.ScrollToOffset(t);
        }
        ScrollBy(e) {
          const t = this.m_scrollLeftPX + e;
          this.ScrollToOffset(t);
        }
        GetAutoScrollPaused() {
          return this.m_bAutoScrollPaused;
        }
        SetAutoScrollPaused(e) {
          this.ClearAutoScrollPauseTimeout(), (this.m_bAutoScrollPaused = e);
        }
        GetAutoScrollPauseTimeout() {
          return this.m_autoScrollPauseTimeout;
        }
        ClearAutoScrollPauseTimeout() {
          this.m_autoScrollPauseTimeout &&
            clearTimeout(this.m_autoScrollPauseTimeout),
            (this.m_autoScrollPauseTimeout = null);
        }
        SetAutoScrollPauseTimeout(e = 5e3) {
          this.ClearAutoScrollPauseTimeout(),
            (this.m_autoScrollPauseTimeout = window.setTimeout(() => {
              this.SetAutoScrollPaused(!1);
            }, e));
        }
        ScrollToEnd() {
          this.ScrollToOffset(this.GetMaxScrollLeftPX());
        }
        SetScrollWindowWidth(e) {
          (this.m_scrollWindowWidth = e),
            this.m_loader.BInitialized() &&
              (this.ScrollToOffset(this.m_scrollLeftPX),
              this.InitDefaultsIfReady());
        }
        SetScrollWindowOffset(e) {
          this.m_scrollWindowOffsetPX = e;
        }
        GetScrollWindowOffset() {
          return this.m_scrollWindowOffsetPX;
        }
        GetScrollableWidthPX() {
          if (!this.m_rgTimelineOffsets?.length) return 0;
          const e = this.m_rgTimelineOffsets.length - 1,
            t = this.m_rgTimelineOffsets[e];
          return (
            e * B +
            this.ConvertDurationMSToDeltaPX(t.globalOffsetMS + t.nDurationMS)
          );
        }
        GetOverscanWidth() {
          return (10 * this.GetScrollWindowWidth()) / 100;
        }
        GetScrollWindowWidth() {
          return this.m_scrollWindowWidth;
        }
        GetMaxScrollLeftPX() {
          return Math.max(
            0,
            this.GetScrollableWidthPX() -
              this.GetScrollWindowWidth() +
              2 * this.GetTimelineMarginWidth(),
          );
        }
        BReachedMaxScroll() {
          return (
            Math.ceil(this.m_scrollLeftPX) ===
            Math.ceil(this.GetMaxScrollLeftPX())
          );
        }
        BReachedMinScroll() {
          return 0 === this.m_scrollLeftPX;
        }
        GetVisualWindowStartPX() {
          return this.m_scrollLeftPX;
        }
        GetVisualWidth() {
          return Math.min(
            this.m_scrollWindowWidth,
            this.GetScrollableWidthPX() + 2 * this.GetTimelineMarginWidth(),
          );
        }
        GetVirtualWindowStartPX() {
          return Math.max(this.m_scrollLeftPX - this.GetOverscanWidth(), 0);
        }
        GetVirtualWindowWidthPX() {
          const e = (0, c.Lh)(this.m_scrollLeftPX, 0, this.GetOverscanWidth()),
            t = Math.min(
              this.GetScrollableWidthPX() -
                (this.m_scrollLeftPX + this.m_scrollWindowWidth),
              this.GetOverscanWidth(),
            );
          return e + this.m_scrollWindowWidth + t;
        }
        GetVirtualWindowEndPX() {
          return (
            this.GetVirtualWindowStartPX() + this.GetVirtualWindowWidthPX()
          );
        }
        GetVisibleTimelines() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.GetVirtualWindowStartPX(),
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              this.GetVirtualWindowEndPX(),
            );
          return this.m_rgTimelineOffsets.slice(e, t + 1).map((e) => {
            const t = Math.max(
                e.globalOffsetMS,
                this.ConvertPXOffsetToGlobalMS(this.GetVirtualWindowStartPX()),
              ),
              r = Math.min(
                e.nDurationMS - (t - e.globalOffsetMS),
                this.ConvertDeltaPXToDurationMS(this.GetVirtualWindowWidthPX()),
              ),
              i = this.ConvertGlobalMSToGlobalPXOffset(t),
              n = this.ConvertDurationMSToDeltaPX(r),
              a = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
              o = this.ConvertDurationMSToDeltaPX(e.nDurationMS);
            return {
              ...e,
              pxStart: a,
              pxDuration: o,
              msVisibleStart: t,
              msVisibleDuration: r,
              pxVisibleStart: i,
              pxVisibleDuration: n,
            };
          });
        }
        GetVisibleRecordings() {
          const e = [];
          return (
            this.GetVisibleTimelines().forEach((t) => {
              t.recordingOffsets.forEach((r) => {
                const i = t.pxStart + this.GetPXForDuration(r.timelineOffsetMS),
                  n = i + this.GetPXForDuration(r.nDurationMS);
                n < this.GetVirtualWindowStartPX() ||
                  i > this.GetVirtualWindowEndPX() ||
                  e.push({
                    recordingID: r.recordingID,
                    nStartPX: i,
                    nEndPX: n,
                    bIsActive: r.bIsActive,
                    recordingType: r.recordingType,
                  });
              });
            }),
            e
          );
        }
        GetVisibleClips() {
          const e = [];
          return (
            this.GetVisibleTimelines().forEach((t) => {
              const r = this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS);
              this.GetClipsForTimeline(t.timelineID).forEach((i) => {
                const n = r + this.GetPXForDuration(i.msTimelineOffset),
                  a = this.ConvertGlobalMSToGlobalPXOffset(
                    t.globalOffsetMS + i.msTimelineOffset + i.msDuration,
                  );
                a < this.GetVirtualWindowStartPX() ||
                  n > this.GetVirtualWindowEndPX() ||
                  e.push({ clipID: i.clipID, pxClipStart: n, pxClipEnd: a });
              });
            }),
            e
          );
        }
        GetPXForDuration(e) {
          return e / this.GetCurrentZoomScale();
        }
        GetVisibleTimelinesInWindow() {
          const e =
              this.FindIndexOfClosestTimelineEndForOffsetPX(
                this.m_scrollLeftPX,
              ) + 1,
            t = this.FindIndexOfClosestTimelineStartForOffsetPX(
              this.m_scrollLeftPX + this.m_scrollWindowWidth,
            );
          return this.m_rgTimelineOffsets.slice(e, t + 1);
        }
        GetVisibleWindowRelativeTimelines() {
          return this.GetVisibleTimelinesInWindow().map((e) => {
            const t = this.m_scrollLeftPX,
              r = this.GetVirtualWindowEndPX() - this.GetOverscanWidth(),
              i = this.ConvertGlobalMSToGlobalPXOffset(e.globalOffsetMS),
              n = i + this.ConvertDurationMSToDeltaPX(e.nDurationMS),
              a = Math.max(i, t),
              o = Math.min(n, r);
            return {
              timelineID: e.timelineID,
              nVisibleStartPX: a,
              nEndPX: o,
              nTimelineStartMS: this.ConvertPXToTimelineRelativeMS(t),
              nGlobalStartMS: this.ConvertPXOffsetToGlobalMS(t),
            };
          });
        }
        ConvertPXToTimelineRelativeMS(e, t = "start") {
          const r = this.ConvertPXOffsetToGlobalMS(e);
          let i = this.m_loader.GetTimelineOffsetFromGlobal(r, 0);
          return "end-if-active" == t &&
            i.strTimelineID &&
            this.m_loader.IsActiveTimeline(i.strTimelineID)
            ? this.MakeRelativeToTimelineEndIfActive(
                i.strTimelineID,
                i.nTimelineOffsetMS.valMS,
              )
            : i.nTimelineOffsetMS.valMS;
        }
        MakeRelativeToTimelineEndIfActive(e, t) {
          if (!this.m_loader.IsActiveTimeline(e)) return t;
          const r = this.m_loader.GetTimelineMetadata(e);
          if (!r) return t;
          let i = parseInt(r.metadata.duration_ms);
          return Math.min(t - i, 0);
        }
        GetTimeRecorded(e) {
          const t = this.m_loader.GetTimelineMetadata(e);
          return t ? t.metadata.date_recorded : null;
        }
        ConvertGlobalMSToClipOrNone(e) {
          const t = this.m_loader.GetTimelineOffsetFromGlobal(e, 0);
          if (!t) return null;
          const { nTimelineOffsetMS: r, strTimelineID: i } = t;
          if (!i) return null;
          if (this.m_mapTimelineClips.has(i)) {
            return this.m_mapTimelineClips
              .get(i)
              .find(
                (e) =>
                  e.msTimelineOffset <= r.valMS &&
                  e.msTimelineOffset + e.msDuration >= r.valMS,
              );
          }
          return null;
        }
        ConvertGlobalMSToScrollWindowPXOffset(e) {
          return this.ConvertGlobalMSToGlobalPXOffset(e) - this.m_scrollLeftPX;
        }
        ConvertGlobalMSToGlobalPXOffset(e, t = -1) {
          t < 0 &&
            (t = u.sL(this.m_rgTimelineOffsets, (t) => e - t.globalOffsetMS));
          const r = t * B;
          return this.ConvertDurationMSToDeltaPX(e) + r;
        }
        ConvertPXOffsetToGlobalMS(e, t = !0) {
          if (this.BPositionInGap(e)) {
            if (!t) return null;
            const r = this.FindClosestTimelineEndForOffsetPX(e);
            return r ? r.globalOffsetMS + r.nDurationMS : 0;
          }
          const r = this.FindClosestTimelineStartForOffsetPX(e);
          if (!r) return null;
          const i = this.ConvertGlobalMSToGlobalPXOffset(r.globalOffsetMS),
            n = this.ConvertDeltaPXToDurationMS(e - i);
          return r.globalOffsetMS + n;
        }
        FindClosestTimelineEndForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
          if (t < 0) return null;
          return this.m_rgTimelineOffsets[t];
        }
        FindClosestTimelineStartForOffsetPX(e) {
          const t = this.FindIndexOfClosestTimelineStartForOffsetPX(e);
          if (t < 0) return null;
          return this.m_rgTimelineOffsets[t];
        }
        FindIndexOfClosestTimelineEndForOffsetPX(e) {
          return u.sL(this.m_rgTimelineOffsets, (t) => {
            const r =
              this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS) +
              this.ConvertDurationMSToDeltaPX(t.nDurationMS);
            return e - r;
          });
        }
        FindIndexOfClosestTimelineStartForOffsetPX(e) {
          return u.sL(this.m_rgTimelineOffsets, (t) => {
            const r = this.ConvertGlobalMSToGlobalPXOffset(t.globalOffsetMS);
            return e - r;
          });
        }
        FindTimelineOffsets(e) {
          return this.m_rgTimelineOffsets.find((t) => t.timelineID === e);
        }
        BPositionInGap(e) {
          const t = this.FindIndexOfClosestTimelineEndForOffsetPX(e);
          if (t < 0) return !1;
          const r = t + 1;
          if (r >= this.m_rgTimelineOffsets.length) return !1;
          const i = this.m_rgTimelineOffsets[t],
            n = this.m_rgTimelineOffsets[r],
            a = this.ConvertGlobalMSToGlobalPXOffset(i.globalOffsetMS);
          return (
            e < this.ConvertGlobalMSToGlobalPXOffset(n.globalOffsetMS) &&
            e !== a
          );
        }
        ConvertDurationMSToDeltaPX(e) {
          return e / this.GetCurrentZoomScale();
        }
        ConvertDeltaPXToDurationMS(e) {
          return e * this.GetCurrentZoomScale();
        }
      }
      (0, s.gn)([l.LO], R.prototype, "m_durationMS", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_scrollLeftPX", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_scrollWindowWidth", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_scrollWindowOffsetPX", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_bAutoScrollPaused", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_autoScrollPauseTimeout", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_msVisible", void 0),
        (0, s.gn)([l.LO.ref], R.prototype, "m_rgTimelineOffsets", void 0),
        (0, s.gn)([l.LO], R.prototype, "m_bInitialized", void 0),
        (0, s.gn)([l.aD], R.prototype, "OnLoaderInitialized", null),
        (0, s.gn)([l.aD], R.prototype, "InitDefaultsIfReady", null),
        (0, s.gn)([l.aD], R.prototype, "OnInvalidate", null),
        (0, s.gn)([l.aD], R.prototype, "ZoomIn", null),
        (0, s.gn)([l.aD], R.prototype, "ZoomOut", null),
        (0, s.gn)([l.aD], R.prototype, "SetTempZoomScale", null),
        (0, s.gn)([l.aD], R.prototype, "ClearTempZoomScale", null),
        (0, s.gn)([l.aD], R.prototype, "UpdateClipSummaries", null),
        (0, s.gn)([m.ak], R.prototype, "BReachedMaxScroll", null),
        (0, s.gn)([m.ak], R.prototype, "BReachedMinScroll", null);
      const E = i.createContext(null);
      function w(e) {
        let {
            loader: t,
            playbackCoordinator: r,
            children: n,
            clipSummaries: a,
            refTimelineParentCtn: o,
          } = e,
          [s, l] = (0, i.useState)(null);
        return (
          (0, i.useEffect)(() => {
            if (!t) return;
            let e = new R(t, r, a);
            return l(e), () => e.Close();
          }, [t]),
          (0, i.useEffect)(() => {
            s && s.UpdateClipSummaries(a);
          }, [s, a]),
          (0, i.useEffect)(() => {
            s && o && s.SetTimelineParentCtnRef(o.current);
          }, [s, o]),
          (function (e) {
            let t = i.useCallback(
              (t, r) => {
                if (!e) return;
                if (!t || !r) return void e.ClearTempZoomScale();
                let i = Math.floor(0.1 * (r.valMS - t.valMS)),
                  n = t.valMS - i,
                  a = r.valMS + i;
                e.SetTempZoomScale(n, a);
              },
              [e],
            );
            !(function (e) {
              let t = (0, i.useContext)(g),
                r = t.selectionZoomCount,
                n = t.globalStartMS,
                a = t.globalEndMS,
                o = (0, i.useRef)(r),
                s = (0, i.useRef)(null);
              (s.current = e),
                (0, i.useEffect)(() => {
                  if (!s.current) return;
                  let e = !isNaN(n?.valMS) && !isNaN(a?.valMS);
                  (o.current == r && e) ||
                    ((o.current = r),
                    e && r ? s.current(n, a) : s.current(null, null));
                }, [r, n, a, o, s]);
            })(t);
          })(s),
          s ? i.createElement(E.Provider, { value: s }, n) : null
        );
      }
      function C() {
        return (0, i.useContext)(E);
      }
      var G = r(97929);
      const P = [1e3, 5e3, 3e4, 6e4, 15e4, 3e5, 9e5, 18e5],
        I = i.memo(function (e) {
          const t = C(),
            r = (0, n.SZ)(() => t.GetVisibleTimelines());
          return i.createElement(
            i.Fragment,
            null,
            r.map((e) =>
              i.createElement(D, {
                key: e.timelineID,
                msVisibleStart: e.msVisibleStart,
                pxVisibleDuration: e.pxVisibleDuration,
                pxVisibleStart: e.pxVisibleStart,
                msTimelineStart: e.globalOffsetMS,
              }),
            ),
          );
        }),
        D = i.memo(function (e) {
          const {
              msVisibleStart: t,
              msTimelineStart: r,
              pxVisibleDuration: a,
              pxVisibleStart: o,
            } = e,
            { msTickSpacing: s, pxTickSpacing: l } = (function () {
              const e = C(),
                t = (0, n.SZ)(() => e.GetCurrentZoomScale()),
                r = 300,
                i = (e) => Math.abs(r - e / t),
                a = P.reduce((e, t) => (i(e) - i(t) < 0 ? e : t)) / 20,
                o = a / t;
              return { msTickSpacing: a, pxTickSpacing: o };
            })(),
            c = C(),
            u = Math.ceil((t - r) / s),
            d = r + u * s,
            m = c.ConvertGlobalMSToGlobalPXOffset(d),
            f = (0, i.useMemo)(() => {
              const e = Math.ceil(a / l),
                t = [];
              for (let r = 0; r < e; r++) {
                const e = m + r * l,
                  i = `${d + s * r}`;
                t.push({ key: i, offsetPX: e, iTimelineRelativeTick: u + r });
              }
              return t;
            }, [a, l, d, s, m, u]);
          return f
            ? i.createElement(
                i.Fragment,
                null,
                i.createElement("div", {
                  className: G.TimelineBacking,
                  style: { transform: `translateX(${o}px)`, width: a },
                }),
                f.map((e) =>
                  i.createElement(O, {
                    key: e.key,
                    timelineRelativeIndex: e.iTimelineRelativeTick,
                    globalOffsetPX: e.offsetPX,
                  }),
                ),
              )
            : null;
        });
      function O(e) {
        const { globalOffsetPX: t, timelineRelativeIndex: r } = e,
          n = r % 20 == 0 ? G.Major : G.Minor;
        return i.createElement(
          "div",
          { className: G.TimeTick, style: { transform: `translateX(${t}px)` } },
          i.createElement("div", { className: (0, o.Z)(G.TickLine, n) }),
        );
      }
      var F = r(86946),
        z = r(13944),
        x = r(74666),
        A = r(10082),
        W = r(72478),
        k = r(91707),
        N = r(37796),
        L = r(2253);
      function X(e) {
        let {
          entry: t,
          strMarkerIcon: r,
          onClick: n,
          onMouseEnter: a,
          onMouseLeave: s,
          onContextMenu: l,
          classNames: c,
          style: u,
          faded: d,
          bSelectedMarker: m,
        } = e;
        return i.createElement(
          "div",
          {
            style: u ?? {},
            className: (0, o.Z)(c, {
              [W.HighlightIcon]: !0,
              [W.Selected]: m,
              [W.Faded]: d,
            }),
            onClick: (e) => {
              n && n(e);
            },
            onContextMenu: l,
            onMouseEnter: a,
            onMouseLeave: s,
          },
          i.createElement(U, { entry: t, strMarkerIcon: r }),
        );
      }
      function U(e) {
        let { entry: t, strMarkerIcon: r } = e;
        const n = (0, z.we)().GetGameID();
        return (0, x.m6)(t)
          ? i.createElement(j, { achievementEntry: t, strGameID: n })
          : (0, x.CR)(t)
            ? i.createElement(V, { entry: t })
            : (0, A.jq)(r)
              ? i.createElement(H, { entry: t, strMarkerIcon: r })
              : i.createElement(q, { strMarkerIcon: r, strGameID: n });
      }
      function j(e) {
        const { achievementEntry: t, strGameID: r } = e,
          n = new N.N1(r),
          a = (0, k.$H)(n.GetAppID(), t.achievement_name);
        let o, s;
        if (a) (o = "white"), (s = i.createElement("img", { src: a.iconURL }));
        else {
          const e = (0, A.cY)();
          (o = (0, A.Mv)(e.color)), (s = e.func({}));
        }
        return i.createElement(
          "div",
          { className: W.Marker, style: { color: o } },
          s,
        );
      }
      function H(e) {
        const { entry: t, strMarkerIcon: r } = e;
        let n, a;
        (0, x.ph)(t)
          ? ((n = (0, A.vt)()), (a = W.CustomMarker))
          : (n = (0, A.XT)(r));
        const o = (0, A.Mv)(n.color),
          s = n.func({}),
          l = i.createElement("div", { className: a }, s);
        return i.createElement(Z, { element: l, color: o });
      }
      function V(e) {
        const { entry: t } = e;
        let r = (0, A.XT)("steam_invalid");
        const n = (0, A.Mv)(r.color),
          a = r.func({}),
          o = i.createElement("div", null, a);
        return i.createElement(Z, { element: o, color: n });
      }
      function q(e) {
        const { strMarkerIcon: t, strGameID: r } = e,
          n = new N.N1(r).GetAppID(),
          a = (0, L.B)(n, t);
        if (null === a) return null;
        if (void 0 === a) {
          const e = (0, A.Q2)(),
            t = i.createElement("div", null, e.func({}));
          return i.createElement(Z, { color: (0, A.Mv)(e.color), element: t });
        }
        let o = "";
        o = "string" != typeof a ? new XMLSerializer().serializeToString(a) : a;
        const s = i.createElement(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
          i.createElement("g", { dangerouslySetInnerHTML: { __html: o } }),
        );
        return i.createElement(Z, { element: s });
      }
      function Z(e) {
        const { element: t, color: r } = e;
        return i.createElement(
          "div",
          { className: W.MarkerCtn },
          i.createElement(
            "div",
            { className: W.Marker, style: r ? { color: r } : null },
            t,
          ),
        );
      }
      var Y = r(42695),
        J = r(59728),
        K = r(12251),
        Q = r(31846),
        $ = r(29480),
        ee = r(62210),
        te = r(65255),
        re = r(93882);
      class ie {
        k_QueueWaitUntilRequestMS = 10;
        k_nMaxBatchSize = 50;
        m_nMaxCacheSize = 18e5 / re.Ms;
        m_LRUTrackerSet = new Set();
        m_mapPromises = new Map();
        m_mapThumbnailImages = new Map();
        m_rgPendingRequest = new Array();
        m_PendingInfoPromise;
        m_PendingInfoResolve = void 0;
        m_PendingTimer = void 0;
        k_AlreadyResolvedOK = Promise.resolve(!0);
        m_rgThumbnailPerf = [];
        constructor() {
          (0, l.rC)(this);
        }
        AddPerfMeasure(e) {
          this.m_rgThumbnailPerf.push(e);
        }
        GetPerfMeasures() {
          if (!this.m_rgThumbnailPerf.length) return null;
          const e = this.m_rgThumbnailPerf.length,
            t = this.m_rgThumbnailPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgThumbnailPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            i = Math.max(...this.m_rgThumbnailPerf),
            n = Math.min(...this.m_rgThumbnailPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: i,
            nMin: n,
            nLength: e,
            nLastVal: this.m_rgThumbnailPerf[e - 1],
          };
        }
        GetKey(e, t, r, i, n, a, o) {
          const s = n + i;
          return `${e}_${t}_${r}_${o ? s : s - (s % re.Ms)}_${a}_${o}`;
        }
        GetThumbnailData(e) {
          const t = this.m_mapThumbnailImages.get(e);
          return (
            t &&
              (this.m_LRUTrackerSet.has(e) && this.m_LRUTrackerSet.delete(e),
              this.m_LRUTrackerSet.add(e)),
            t
          );
        }
        SetThumbnailData(e, t) {
          if (
            (this.m_LRUTrackerSet.has(e) && this.m_LRUTrackerSet.delete(e),
            this.m_LRUTrackerSet.add(e),
            this.m_mapThumbnailImages.set(e, t),
            this.m_LRUTrackerSet.size >= this.m_nMaxCacheSize)
          ) {
            const e = this.m_LRUTrackerSet.keys().next().value;
            this.m_LRUTrackerSet.delete(e), this.m_mapThumbnailImages.delete(e);
          }
        }
        ClearThumbnailData() {
          this.m_LRUTrackerSet.clear(), this.m_mapThumbnailImages.clear();
        }
        GetThumbnail(e, t, r, i, n, a, o) {
          if (!t) return;
          const s = this.GetKey(e, t, r, i, n, a, o);
          return this.GetThumbnailData(s);
        }
        GetOrQueueThumbnail(e, t, r, i, n, a, o) {
          if (!t) return;
          const s = this.GetKey(e, t, r, i, n, a, o);
          let l = this.GetThumbnailData(s);
          if (!l) {
            let c = `thumbnail_${e}_${a}_${o}`;
            performance.mark(c),
              this.QueueThumbnailRequest(e, t, r, i, n, a, o).then(() => {
                try {
                  const e = performance.measure(`measure_${c}`, c);
                  e && ie.Get().AddPerfMeasure(e.duration);
                } catch (e) {
                  (0, d.hB)(`CThumbnailCache:: cant measure ${c}, error: ${e}`);
                }
              }),
              (l = this.GetThumbnailData(s));
          }
          return l;
        }
        QueueThumbnailRequest(e, t, r, i, n, a, o) {
          const s = this.GetKey(e, t, r, i, n, a, o),
            l = this.GetThumbnailData(s);
          if (l && (l.data || l.bIsLoading)) return this.k_AlreadyResolvedOK;
          this.SetThumbnailData(s, { data: null, bIsLoading: !0 }),
            this.m_PendingInfoPromise &&
              (this.m_rgPendingRequest[0].strRecordingID != t ||
                this.m_rgPendingRequest.length > this.k_nMaxBatchSize) &&
              (this.m_PendingTimer && window.clearTimeout(this.m_PendingTimer),
              this.FlushPendingInfo()),
            (this.m_PendingInfoPromise &&
              this.m_rgPendingRequest[0].strRecordingID == t) ||
              ((this.m_PendingInfoPromise = new Promise(
                (e) => (this.m_PendingInfoResolve = e),
              )),
              (this.m_PendingTimer = window.setTimeout(
                () => this.FlushPendingInfo(),
                this.k_QueueWaitUntilRequestMS,
              )));
          const c = {
            gameID: e,
            strRecordingID: t,
            strClipID: r,
            nRecordingOffsetMS: i,
            nRecordingStartOffsetMS: n,
            cPxMajorAxis: a,
            bPreciseTiming: o,
          };
          return (
            this.m_rgPendingRequest.some((e) => {
              return (
                (r = c),
                (t = e).strRecordingID === r.strRecordingID &&
                  t.strClipID === r.strClipID &&
                  t.nRecordingOffsetMS === r.nRecordingOffsetMS &&
                  t.nRecordingStartOffsetMS === r.nRecordingStartOffsetMS &&
                  t.cPxMajorAxis === r.cPxMajorAxis &&
                  t.bPreciseTiming == r.bPreciseTiming
              );
              var t, r;
            }) ||
              (this.m_rgPendingRequest.push(c),
              this.m_mapPromises.set(s, this.m_PendingInfoPromise)),
            this.m_PendingInfoPromise
          );
        }
        async FlushPendingInfo() {
          if (void 0 === this.m_PendingInfoResolve) return;
          const e = this.m_PendingInfoResolve,
            t = this.m_rgPendingRequest;
          (this.m_PendingInfoPromise = void 0),
            (this.m_PendingInfoResolve = void 0),
            (this.m_rgPendingRequest = []),
            (this.m_PendingTimer = void 0),
            await this.InternalLoadMultipleThumbnails(t),
            e();
        }
        async InternalLoadMultipleThumbnails(e) {
          e.sort((e, t) => e.nRecordingOffsetMS - t.nRecordingOffsetMS);
          try {
            const t = e.map((e) => 1e3 * e.nRecordingOffsetMS),
              r = await (0, k.no)(
                e[0].strRecordingID,
                e[0].strClipID,
                void 0,
                t,
                e[0].cPxMajorAxis,
                e[0].bPreciseTiming,
              );
            (0, ee.X)(
              r?.length == t.length,
              `CThumbnailCache.InternalLoadMultipleThumbnails request ${t.length} and got back ${r?.length}`,
            );
            for (let i = 0; i < t.length && i < r?.length; ++i) {
              const t = e[i],
                n = this.GetKey(
                  t.gameID,
                  t.strRecordingID,
                  t.strClipID,
                  t.nRecordingOffsetMS,
                  t.nRecordingStartOffsetMS,
                  t.cPxMajorAxis,
                  t.bPreciseTiming,
                );
              let a = r ? r[i].image_data() : null;
              this.SetThumbnailData(n, { data: a, bIsLoading: !1 });
            }
          } catch (t) {
            (0, d.F0)("Failed to load multiple request thumbnails", t);
            for (let t = 0; t < e.length; ++t) {
              const r = e[t],
                i = this.GetKey(
                  r.gameID,
                  r.strRecordingID,
                  r.strClipID,
                  r.nRecordingOffsetMS,
                  r.nRecordingStartOffsetMS,
                  r.cPxMajorAxis,
                  e[0].bPreciseTiming,
                );
              this.SetThumbnailData(i, { data: null, bIsLoading: !1 });
            }
          }
        }
        async LoadThumbnail(e, t, r, i, n, a, o) {
          const s = this.GetKey(e, t, r, i, n, a, o),
            l = this.GetThumbnailData(s);
          return (
            !(!l || !l.data) ||
            (this.m_mapPromises.has(s) ||
              this.m_mapPromises.set(
                s,
                this.InternalLoadThumbnail(e, t, r, i, n, a, o),
              ),
            this.m_mapPromises.get(s))
          );
        }
        async InternalLoadThumbnail(e, t, r, i, n, a, o) {
          const s = this.GetKey(e, t, r, i, n, a, o);
          try {
            const e = await (0, k.no)(t, r, void 0, [1e3 * i], a, o);
            if (e?.length > 0) {
              let t = e ? e[0].image_data() : null;
              return this.SetThumbnailData(s, { data: t, bIsLoading: !1 }), !0;
            }
            (0, d.aF)(
              `ThumbnailImage: got empty jpeg ${e.length} list back ${t} @ ${i}`,
            );
          } catch (e) {
            (0, d.F0)(
              `ThumbnailImage: Fail to load thumbnail ${t} @ ${i} with ${e}`,
            ),
              this.SetThumbnailData(s, { data: null, bIsLoading: !1 });
          }
          return !1;
        }
        static s_Singleton;
        static Get() {
          return (
            ie.s_Singleton ||
              ((ie.s_Singleton = new ie()),
              "dev" == te.De.WEB_UNIVERSE &&
                (window.g_ThumbnailCache = ie.s_Singleton)),
            ie.s_Singleton
          );
        }
      }
      function ne(e, t, r, a, o, s, l) {
        const c = (0, n.SZ)(() =>
          ie.Get().GetOrQueueThumbnail(e, r, t, a, o, s, l),
        );
        return (function (e) {
          const t = (0, i.useRef)(null),
            r = (0, m.NW)(),
            n = (0, $.T)("useThumbnailAsURL");
          return (
            (0, i.useEffect)(() => {
              if (e && !n?.token?.reason) {
                const i = new Blob([e], { type: "image/jpeg" }),
                  n = URL.createObjectURL(i);
                (t.current = n), r();
              }
              return () => {
                t.current &&
                  (URL.revokeObjectURL(t.current), (t.current = void 0));
              };
            }, [n?.token?.reason, e, r]),
            t.current
          );
        })(c?.data);
      }
      (0, s.gn)([l.LO], ie.prototype, "m_mapThumbnailImages", void 0);
      var ae = r(77556),
        oe = r(58538);
      class se {
        m_reservations = [];
        m_nIconWidth;
        constructor(e) {
          this.m_nIconWidth = e;
        }
        BAllowIcon(e) {
          const t = {
            nStart: e - this.m_nIconWidth / 2,
            nEnd: e + this.m_nIconWidth / 2,
          };
          let r = 0;
          for (; r < this.m_reservations.length; r++) {
            const e = this.m_reservations[r];
            if (e.nStart >= t.nEnd) break;
            if (!((i = t).nStart >= (n = e).nEnd || i.nEnd <= n.nStart))
              return !1;
          }
          var i, n;
          return this.m_reservations.splice(r, 0, t), !0;
        }
      }
      var le = r(83743),
        ce = r(77178),
        ue = r(1485);
      function de(e) {
        const {
            closeModal: t,
            strTimelineID: r,
            entry: n,
            playbackCoordinator: a,
            fnClearSelection: o,
          } = e,
          [s, l] = i.useState(n.title || ""),
          [c, u] = i.useState(n.description || ""),
          d = (0, le.tx)();
        return d.bLoading
          ? i.createElement(le.NT, {
              state: d,
              strDialogTitle: (0, Q.Xx)("#Marker_Dialog"),
              closeModal: t,
            })
          : i.createElement(
              ce.uH,
              {
                strTitle: (0, Q.Xx)("#Marker_Dialog"),
                strMiddleButtonText: (0, Q.Xx)("#Marker_Action_Delete"),
                onCancel: t,
                onOK: async () => {
                  d.fnSetLoading(!0);
                  (await a.UpdateUserMarker(r, n, s, c))
                    ? t()
                    : (d.fnSetError(!0),
                      d.fnSetStrError((0, Q.Xx)("#Marker_UpdateFailed")));
                },
              },
              i.createElement(ue.II, {
                type: "text",
                value: s,
                onChange: (e) => l(e.currentTarget.value),
                label: (0, Q.Xx)("#Marker_Title"),
              }),
              i.createElement(ue.II, {
                type: "text",
                value: c,
                onChange: (e) => u(e.currentTarget.value),
                label: (0, Q.Xx)("#Marker_Description"),
              }),
            );
      }
      var me = r(90069),
        fe = r(50423);
      const pe = (0, i.createContext)({});
      function ge() {
        return (0, i.useContext)(pe);
      }
      var be,
        he = r(18877);
      !(function (e) {
        (e.Playhead = "Playhead"),
          (e.Range = "Range"),
          (e.Highlight = "Highlight");
      })(be || (be = {}));
      const _e = i.createContext({
        bInContainer: null,
        bContainerFocus: null,
        nMouseClientXPX: null,
        globalMouseXPX: null,
        scrollWindowMouseXPX: null,
        fnRegisterMouseEvent: null,
        activeComponent: null,
        setActiveComponent: () => {},
      });
      function Se(e) {
        const { children: t } = e,
          [r, a] = (0, i.useState)(),
          [o, s] = (0, i.useState)(),
          [l, u] = (0, i.useState)(),
          [d, m] = (0, i.useState)(),
          p = (0, i.useRef)(),
          g = C(),
          b = (0, n.SZ)(() => g.GetScrollableWidthPX()),
          h = (0, n.SZ)(() => g.GetVisualWindowStartPX()),
          _ = (0, n.SZ)(() => g.GetScrollWindowWidth()),
          S = (0, n.SZ)(() => g.GetScrollWindowOffset()),
          v = (0, n.SZ)(() => g.GetTimelineMarginWidth()),
          y = i.useMemo(() => {
            if (p.current) {
              const e = h - S - v;
              return (0, f.bu)(c.Lh(l + e, 0, b));
            }
            return (0, f.bu)(0);
          }, [v, l, S, h, b]),
          M = i.useMemo(() => {
            if (p.current) {
              const e = p.current.getBoundingClientRect(),
                t = b > _ ? S : e.x;
              return (0, f.yj)(c.Lh(l - t, 0, _));
            }
            return (0, f.yj)(0);
          }, [l, S, _, b]),
          T = (0, i.useCallback)(
            (e, t) => (
              p.current && p.current.addEventListener(e, t),
              () => p.current?.removeEventListener(e, t)
            ),
            [],
          ),
          B = (0, i.useCallback)(() => {
            a(!0);
          }, []),
          R = (0, i.useCallback)(() => {
            a(!1);
          }, []),
          E = (0, i.useCallback)((e) => {
            u(e.clientX);
          }, []),
          w = (0, i.useCallback)((e) => {
            s(!0);
          }, []),
          G = (0, i.useCallback)((e) => {
            s(!1);
          }, []);
        (0, i.useEffect)(() => {
          const e = (0, fe.kR)(p.current);
          return (
            e.addEventListener("mousemove", E),
            () => e.removeEventListener("mousemove", E)
          );
        }, [E]);
        const P = (0, i.useMemo)(
          () => ({
            bContainerFocus: o,
            bInContainer: r,
            nMouseClientXPX: l,
            globalMouseXPX: y,
            scrollWindowMouseXPX: M,
            fnRegisterMouseEvent: T,
            activeComponent: d,
            setActiveComponent: m,
          }),
          [o, r, l, y, M, T, d],
        );
        return i.createElement(
          _e.Provider,
          { value: P },
          i.createElement(
            "div",
            {
              ref: p,
              onMouseOver: w,
              onFocus: w,
              onMouseOut: G,
              onBlur: G,
              onMouseEnter: B,
              onMouseLeave: R,
              className: he.MouseListenerContainer,
            },
            t,
          ),
        );
      }
      function ve() {
        return (0, i.useContext)(_e).globalMouseXPX;
      }
      function ye() {
        return (0, i.useContext)(_e).scrollWindowMouseXPX;
      }
      function Me() {
        return (0, i.useContext)(_e).setActiveComponent;
      }
      function Te() {
        return (0, i.useContext)(_e).activeComponent;
      }
      function Be(e, t) {
        const r = (0, i.useContext)(_e).fnRegisterMouseEvent,
          n = (0, i.useRef)(),
          a = (0, i.useCallback)(() => {
            n.current = r(e, t);
          }, [r, t, e]),
          o = (0, i.useCallback)(() => {
            n.current && n.current();
          }, []);
        (0, i.useEffect)(() => (a(), () => o()), [a, o]);
      }
      function Re(e) {
        const {
            markerInfo: t,
            view: r,
            coordinator: a,
            gameID: s,
            clipID: l,
            timelineID: c,
            faded: u,
          } = e,
          d = t.nGlobalMS,
          m = (0, n.SZ)(() => r.ConvertGlobalMSToGlobalPXOffset(d.valMS)),
          { selectedMarker: p } = M(),
          g =
            t.entry?.id == p?.strEntryID && t.strTimelineID == p?.strTimelineID,
          { tooltip: b, ...h } = Ee(r, a, s, l, t),
          _ = i.useCallback(
            (e) => {
              const i = d.valMS - 5e3,
                n = r.FindTimelineOffsets(c),
                o = Math.max(i, n.globalOffsetMS);
              a.SetPlaytimeFromGlobalMS((0, f.Z6)(o)),
                a.SetDisplayHighlightEntry(t.entry),
                e.stopPropagation(),
                Y.q.ReportTrackedAction(
                  `/GameRecording/Marker/Click/${t.entry.type}`,
                );
            },
            [a, d.valMS, c, r, t],
          ),
          S = { transform: `translateX( calc( ${m}px - 50% ))` };
        return i.createElement(
          i.Fragment,
          null,
          i.createElement(
            "div",
            {
              key: d.valMS,
              className: (0, o.Z)(F.TimelineMarkerCtn, u && F.Faded),
              style: S,
              ...h,
            },
            b,
            i.createElement(X, {
              classNames: F.TimelineMarker,
              key: t.entry.id,
              entry: t.entry,
              strMarkerIcon: t.strMarkerIcon,
              faded: u,
              onClick: _,
              bSelectedMarker: g,
            }),
          ),
          i.createElement(we, { offsetPixelVal: m }),
        );
      }
      function Ee(e, t, r, a, o) {
        const s = i.useRef(),
          l = i.useRef(),
          c = i.useRef(),
          u = (0, n.SZ)(() =>
            e.GetStateDescriptionAtGlobalMS(o.nGlobalMS.valMS),
          ),
          d = (0, n.SZ)(() =>
            t.GetRecordingMode() === z.tP.Overlay ? "bottom" : "top",
          ),
          m = Me(),
          f = Te(),
          p = (0, J.lL)({
            toolTipContent: i.createElement(Ce, {
              markerInfo: o,
              gameID: r,
              clipID: a,
              tooltipDirection: d,
              strStateDescription: u?.title,
              ref: s,
            }),
            direction: d,
            nDelayShowMS: 20,
            nBodyDistance: 0,
            nAllowOffscreenPx: 0,
            nMaxLateralMoveOnScreen: 320,
            bTopmost: !0,
          }),
          { onMouseEnter: g, onMouseLeave: b } = p.divProps,
          h = i.useCallback(() => {
            b(),
              m(null),
              c.current && c.current(),
              (c.current = null),
              e.GetAutoScrollPaused() && e.SetAutoScrollPauseTimeout();
          }, [b, m, e]);
        i.useEffect(
          () => () => {
            h();
          },
          [h],
        ),
          i.useEffect(() => {
            f && f !== be.Highlight && h();
          }, [h, f]);
        const _ = i.useCallback(
          (e) => {
            if (!l.current) return;
            const t = l.current.getBoundingClientRect();
            if (e.clientY >= t.top && e.clientY <= t.bottom)
              return t.left - e.clientX > 1 || e.clientX - t.right > 1
                ? void h()
                : void 0;
            if (!s.current) return void h();
            const r = s.current.getBoundingClientRect(),
              i = "top" === d ? r : t,
              n = "top" === d ? t : r;
            if (e.clientY <= i.top || e.clientY >= n.bottom) return void h();
            if (e.clientY >= r.top && e.clientY <= r.bottom)
              return void (
                (e.clientX <= r.left || e.clientX >= r.right) &&
                h()
              );
            const a = i.left,
              o = i.bottom,
              c = i.right,
              u = i.bottom,
              m = n.left,
              f = n.top,
              p = n.right,
              g = n.top,
              b = ((a - m) / (o - f)) * (e.clientY - o) + a < e.clientX,
              _ = ((c - p) / (u - g)) * (e.clientY - u) + c > e.clientX;
            (b && _) || h();
          },
          [h, d],
        );
        return {
          tooltip: p.tooltip,
          ref: l,
          onMouseOver: (e) => {
            if ((m(be.Highlight), g(e), !c.current)) {
              const t = (0, fe.RA)(e);
              t.addEventListener("mousemove", _),
                (c.current = () => t.removeEventListener("mousemove", _));
            }
          },
          onMouseLeave: (e) => {
            const t = l.current.getBoundingClientRect(),
              r = t.left,
              i = t.right;
            e.clientX - r < 1 || i - e.clientX < 1
              ? h()
              : (0, fe.ni)(l.current, e.relatedTarget) ||
                (e.clientY - t.top > 1 &&
                  t.bottom - e.clientY > 1 &&
                  e.clientX - t.left > 1 &&
                  t.right - e.clientX > 1 &&
                  h());
          },
        };
      }
      function we(e) {
        const { offsetPixelVal: t } = e,
          r = { transform: `translateX( ${t - 1}px )` };
        return i.createElement(
          "div",
          { className: F.DroplineCtn, style: r },
          i.createElement("div", {
            className: (0, o.Z)(F.TimelineMarkerDropLine),
          }),
        );
      }
      const Ce = i.forwardRef(function (e, t) {
          const {
            markerInfo: r,
            gameID: n,
            clipID: a,
            strStateDescription: o,
          } = e;
          return (0, x.l8)(r.entry)
            ? i.createElement(
                Ge,
                {
                  markerInfo: r,
                  gameID: n,
                  clipID: a,
                  entryTime: r.entry.time,
                  stateDescription: o,
                  bPreciseTiming: !0,
                  ref: t,
                },
                i.createElement(Pe, { markerInfo: r }),
                i.createElement(Fe, { entry: r.entry, gameID: n }),
                i.createElement(Ie, { markerInfo: r }),
              )
            : (0, x.CR)(r.entry)
              ? i.createElement(
                  Ge,
                  {
                    markerInfo: r,
                    description:
                      (0, Q.Xx)(r.entry.description) ||
                      "#GameRecording_UnknownError",
                    gameID: n,
                    clipID: a,
                    entryTime: r.entry.time,
                    stateDescription: o,
                    ref: t,
                  },
                  i.createElement(Pe, { markerInfo: r }),
                  i.createElement(Ie, { markerInfo: r }),
                )
              : (0, x.ph)(r.entry)
                ? i.createElement(
                    Ge,
                    {
                      markerInfo: r,
                      title: r.entry.title
                        ? r.entry.title
                        : (0, Q.Xx)("#Marker_UserMarker_Title"),
                      description: r.entry.description || "",
                      gameID: n,
                      clipID: a,
                      entryTime: r.entry.time,
                      stateDescription: o,
                      ref: t,
                    },
                    i.createElement(Oe, { markerInfo: r }),
                    i.createElement(Pe, { markerInfo: r }),
                    i.createElement(De, { markerInfo: r }),
                    i.createElement(Ie, { markerInfo: r }),
                  )
                : (0, x.m6)(r.entry)
                  ? i.createElement(ze, {
                      markerInfo: r,
                      entry: r.entry,
                      gameID: n,
                      clipID: a,
                      stateDescription: o,
                      ref: t,
                    })
                  : (0, x.tm)(r.entry)
                    ? i.createElement(
                        Ge,
                        {
                          markerInfo: r,
                          title: r.entry.title || "",
                          description: r.entry.description || "",
                          gameID: n,
                          clipID: a,
                          entryTime: r.entry.time,
                          stateDescription: o,
                          ref: t,
                        },
                        i.createElement(Pe, { markerInfo: r }),
                        i.createElement(Ie, { markerInfo: r }),
                      )
                    : null;
        }),
        Ge = i.forwardRef(function (e, t) {
          const {
              markerInfo: r,
              gameID: a,
              entryTime: s,
              title: l,
              description: c,
              children: u,
              clipID: d,
              stateDescription: m,
              bPreciseTiming: p,
            } = e,
            g = (0, z.we)(),
            b = C().GetTimelineOffsetMS(r.strTimelineID),
            h = parseInt(s),
            _ = (0, f.pX)(h - b),
            S = (0, n.SZ)(() => g.GetRecordingMode()),
            v = (0, n.SZ)(() =>
              g.ConvertGlobaOffsetToRecordingAndRelativeOffset(
                r.nGlobalMS.valMS,
              ),
            ),
            y = ne(
              a,
              d,
              v?.strRecordingID,
              v?.nRecordingOffsetMS,
              v?.nStartOffsetMS,
              200,
              p,
            ),
            M = v?.strRecordingID && !y;
          return i.createElement(
            "div",
            { className: (0, o.Z)(F.TooltipOffset, F[S]) },
            i.createElement(
              "div",
              { className: (0, o.Z)(F.TooltipContainer, M && F.Hide) },
              i.createElement(
                "div",
                { className: F.ImageHighlightPosition },
                i.createElement(
                  "div",
                  { className: F.ImageHighlightBlock },
                  v?.strRecordingID
                    ? i.createElement("img", { src: y })
                    : i.createElement(
                        "div",
                        { className: F.NoRecordedContent },
                        (0, Q.Xx)("#GameRecording_PlayerNoContent"),
                      ),
                  (l || c) &&
                    i.createElement(
                      "div",
                      { className: F.TooltipHighlight },
                      i.createElement(
                        "div",
                        { className: F.HighlightHeader },
                        i.createElement(
                          "div",
                          { className: F.HighlightIcon },
                          i.createElement(U, {
                            entry: r.entry,
                            strMarkerIcon: r.strMarkerIcon,
                          }),
                        ),
                        l &&
                          i.createElement(
                            "div",
                            { className: F.HighlightTitle },
                            l,
                          ),
                      ),
                      i.createElement(
                        "div",
                        { className: F.HighlightInfoBlock },
                        c &&
                          i.createElement(
                            "div",
                            { className: F.HighlightDesc },
                            c,
                          ),
                      ),
                    ),
                ),
              ),
              i.createElement(
                "div",
                { className: F.TooltipContents, ref: t },
                m &&
                  i.createElement("div", { className: F.StateDescription }, m),
                i.createElement(
                  "div",
                  { className: (0, o.Z)(F.TimestampCtn, F[S]) },
                  i.createElement(
                    "div",
                    { className: F.Timestamp },
                    (0, K.SF)(_.valMS / 1e3, !1),
                  ),
                  (0, x.pf)(r.entry) &&
                    i.createElement(
                      i.Fragment,
                      null,
                      i.createElement("div", null, "-"),
                      i.createElement(
                        "div",
                        { className: F.Timestamp },
                        (0, K.SF)(
                          (_.valMS + parseInt(r.entry.duration)) / 1e3,
                          !1,
                        ),
                      ),
                    ),
                ),
                i.createElement("div", { className: F.TooltipButtons }, u),
              ),
            ),
            i.createElement("div", {
              className: (0, o.Z)(F.TooltipHitBox, F[S]),
            }),
          );
        });
      function Pe(e) {
        const { setSelectedMarker: t } = M(),
          { markerInfo: r } = e,
          a = (0, z.we)(),
          s = (0, n.SZ)(() => a.ShouldModeShowClipControls()),
          l = (0, n.SZ)(() =>
            a.ConvertGlobaOffsetToRecordingAndRelativeOffset(r.nGlobalMS.valMS),
          ),
          c = (0, k.B$)();
        return l?.strRecordingID && s
          ? i.createElement(
              J.HP,
              {
                toolTipContent: (0, Q.Xx)(
                  c
                    ? "#RecordingState_Clip_LowDiskSpace"
                    : "#TimelineDialog_ClipVideo",
                ),
                direction: "top",
                bTopmost: !0,
              },
              i.createElement(
                "div",
                {
                  className: (0, o.Z)(F.Button, F.CreateClipButton),
                  onClick: (e) => {
                    let i = 5e3,
                      n = 3e3;
                    (0, x.pf)(r.entry) &&
                      ((i = 0), (n = parseInt(r.entry.duration)));
                    const [o, s] = a
                      .GetLoader()
                      .CreateGlobalRangeForTimeline(
                        r.strTimelineID,
                        r.nGlobalMS.valMS,
                        i,
                        n,
                      );
                    a.SetPlaytimeFromGlobalMS((0, f.Z6)(o)),
                      t?.(r.entry.id, r.strTimelineID, o, s),
                      Y.q.ReportTrackedAction(
                        "/GameRecording/Tooltip/ClipFromHighlight",
                      ),
                      e.stopPropagation();
                  },
                },
                i.createElement(ae.cW, null),
              ),
            )
          : null;
      }
      function Ie(e) {
        const { markerInfo: t } = e,
          r = C(),
          a = (0, n.SZ)(() => r.ConvertGlobalMSToClipOrNone(t.nGlobalMS.valMS)),
          { onNavigateToClip: s } = ge();
        return a
          ? i.createElement(
              J.HP,
              {
                toolTipContent: (0, Q.Xx)("#TimelineDialog_ViewClip"),
                direction: "top",
                bTopmost: !0,
              },
              i.createElement(
                "div",
                {
                  className: (0, o.Z)(F.Button, F.GoToClip),
                  onClick: () => {
                    a &&
                      (Y.q.ReportTrackedAction(
                        `/GameRecording/Tooltip/ViewClip/${t.entry.type}`,
                      ),
                      s(a.clipID));
                  },
                },
                i.createElement(oe.nkn, null),
              ),
            )
          : null;
      }
      function De(e) {
        const { markerInfo: t } = e,
          r = (0, z.we)();
        return i.createElement(
          J.HP,
          {
            toolTipContent: (0, Q.Xx)("#Marker_Action_Delete"),
            direction: "top",
            bTopmost: !0,
          },
          i.createElement(
            "div",
            {
              className: (0, o.Z)(F.Button, F.DeleteMarker),
              onClick: (e) => {
                Y.q.ReportTrackedAction(
                  `/GameRecording/Marker/Delete/${t.entry.type}`,
                ),
                  r.RemoveUserMarker(t.strTimelineID, t.entry.id);
              },
            },
            i.createElement(oe.rFk, null),
          ),
        );
      }
      function Oe(e) {
        const { markerInfo: t } = e,
          r = (0, z.we)(),
          n = (0, i.useContext)(g).clearSelection;
        return i.createElement(
          J.HP,
          {
            toolTipContent: (0, Q.Xx)("#Marker_Action_Edit"),
            direction: "top",
            bTopmost: !0,
          },
          i.createElement(
            "div",
            {
              className: (0, o.Z)(F.Button, F.EditMarker),
              onClick: (e) => {
                if (!(0, x.ph)(t.entry)) return;
                Y.q.ReportTrackedAction(
                  `/GameRecording/Marker/Edit/${t.entry.type}`,
                );
                let a = i.createElement(de, {
                  entry: t.entry,
                  playbackCoordinator: r,
                  fnClearSelection: n,
                  strTimelineID: t.strTimelineID,
                });
                (0, me.AM)(a, (0, fe.RA)(e)),
                  e.stopPropagation(),
                  e.preventDefault();
              },
            },
            i.createElement(ae.I8, null),
          ),
        );
      }
      function Fe(e) {
        const { entry: t, gameID: r } = e,
          n = t.handle,
          { onNavigateToScreenshot: a } = ge();
        return i.createElement(
          J.HP,
          {
            toolTipContent: (0, Q.Xx)("#TimelineDialog_ViewScreenshot"),
            direction: "top",
            bTopmost: !0,
          },
          i.createElement(
            "div",
            {
              className: (0, o.Z)(F.Button, F.ViewScreenshot),
              onClick: () => {
                n &&
                  (Y.q.ReportTrackedAction("/GameRecording/Tooltip/Screenshot"),
                  a(r, n));
              },
            },
            i.createElement(ae.w_, null),
          ),
        );
      }
      const ze = i.forwardRef(function (e, t) {
        const {
            markerInfo: r,
            entry: n,
            gameID: a,
            clipID: o,
            stateDescription: s,
          } = e,
          l = new N.N1(a),
          c = (0, k.$H)(l.GetAppID(), n.achievement_name);
        return c
          ? i.createElement(
              Ge,
              {
                markerInfo: r,
                title: c.name ?? "",
                entryTime: n.time,
                description: c.description ?? "",
                gameID: a,
                clipID: o,
                stateDescription: s,
                ref: t,
              },
              i.createElement(Pe, { markerInfo: r }),
              i.createElement(Ie, { markerInfo: r }),
            )
          : null;
      });
      function xe(e) {
        return "achievement" === e.type ? 9e3 : e.priority;
      }
      const Ae = i.memo(function (e) {
          const t = C(),
            r = (0, n.SZ)(() => t.GetVisibleTimelines());
          return i.createElement(
            i.Fragment,
            null,
            r.map((e) =>
              i.createElement(Ne, { key: e.timelineID, timeline: e }),
            ),
          );
        }),
        We = { screenshot: 0, event: 0, achievement: 1, usermarker: 2 };
      function ke(e, t) {
        if (We[e.type] !== We[t.type]) return We[t.type] - We[e.type];
        const r = xe(e),
          i = xe(t);
        return r != i
          ? i - r
          : e.time != t.time
            ? parseInt(e.time) - parseInt(t.time)
            : e.id.localeCompare(t.id);
      }
      const Ne = i.memo(function (e) {
        const { timeline: t } = e,
          r = C(),
          a = (0, z.we)(),
          o = (0, n.SZ)(() =>
            [...(r.GetVisibleTimelineHighlights(t.timelineID) || [])].sort(ke),
          ),
          s = (0, n.SZ)(() => r.GetTimelineOffsetMS(t.timelineID)),
          l = t.globalOffsetMS - s,
          c = a.GetGameID(),
          u = a.GetClipID(),
          m = 16 * r.GetCurrentZoomScale();
        let p = new se(m),
          g = [];
        return (
          o.forEach((e, n) => {
            if (
              "event" !== e.type &&
              "usermarker" !== e.type &&
              "achievement" !== e.type &&
              "screenshot" !== e.type &&
              "error" !== e.type
            )
              return;
            const o = `${e.type}_${e.id}_${t.timelineID}_${n}`,
              s = (function (e, t, r) {
                if (
                  ![
                    "event",
                    "usermarker",
                    "screenshot",
                    "achievement",
                    "error",
                  ].includes(r.type)
                )
                  return (
                    (0, d.hB)(
                      `Unexpected timeline entry type ${r.type}, returning empty highlight marker`,
                    ),
                    null
                  );
                let i = r;
                const n = (0, x.m6)(i),
                  a = {
                    entry: i,
                    strMarkerIcon: n ? "steam_achievement" : i.icon,
                    nMarkerPriority: xe(i),
                    strTimelineID: e,
                    strTitle: (!n && i.title) || "",
                    strDescription: (!n && i.description) || "",
                    nGlobalMS: (0, f.Z6)(parseInt(i.time) + t),
                  };
                return a;
              })(t.timelineID, l, e),
              m = p.BAllowIcon(s.nGlobalMS.valMS);
            g.push(
              i.createElement(Re, {
                gameID: c,
                clipID: u,
                key: o,
                view: r,
                coordinator: a,
                faded: !m,
                timelineID: t.timelineID,
                markerInfo: s,
              }),
            );
          }),
          i.createElement(i.Fragment, null, g.reverse())
        );
      });
      var Le = r(72759);
      function Xe(e) {
        const {
            view: t,
            entry: r,
            nGlobalEntryEndMS: a,
            nGlobalTLStartMS: s,
          } = e,
          l = (0, z.we)(),
          c = (0, f.Z6)(parseInt(r.time) + s.valMS),
          u = (0, n.SZ)(() => {
            const e = t.ConvertGlobalMSToGlobalPXOffset(c.valMS),
              r = t.GetVirtualWindowStartPX();
            return r < e ? e : r;
          }),
          d = (0, n.SZ)(() => {
            const e = t.ConvertGlobalMSToGlobalPXOffset(a.valMS),
              r = t.GetVirtualWindowEndPX();
            return r < e ? r : e;
          }),
          m = !!l.GetClipID(),
          p = { transform: `translateX( ${u}px )`, width: d - u },
          g = (0, o.Z)({
            [Le.Unspecified]: r.mode === x.Ml.Invalid,
            [Le.Staging]: r.mode === x.Ml.Staging,
            [Le.Menus]: r.mode === x.Ml.Menus,
            [Le.Playing]: r.mode === x.Ml.Playing,
          });
        return i.createElement("div", {
          key: r.id,
          className: (0, o.Z)(Le.GameModeMarker, g, m && Le.GameModeMarkerClip),
          style: p,
        });
      }
      const Ue = i.memo(function (e) {
          const t = C(),
            r = (0, n.SZ)(() => t.GetVisibleTimelines());
          return i.createElement(
            i.Fragment,
            null,
            r.map((e) =>
              i.createElement(je, { key: e.timelineID, timeline: e }),
            ),
          );
        }),
        je = i.memo(function (e) {
          const {
              timelineID: t,
              globalOffsetMS: r,
              nDurationMS: a,
            } = e.timeline,
            o = C(),
            s = (0, n.SZ)(() => {
              const e = o.GetVisibleTimelineGameModes(t);
              return e && 0 !== e.length
                ? e
                : [
                    {
                      time: "0",
                      type: "gamemode",
                      mode: x.Ml.Invalid,
                      id: "synthetic",
                    },
                  ];
            }),
            l = (0, f.Z6)(r + a),
            c = r - o.GetTimelineOffsetMS(t);
          let u = [];
          for (let e = 0; e < s.length; e++) {
            const r = (0, f.Z6)(
              e < s.length - 1 ? parseInt(s[e + 1].time) + c : l.valMS - 1,
            );
            u.push(
              i.createElement(Xe, {
                key: `gameMode_${t}_${e}`,
                view: o,
                entry: s[e],
                nGlobalEntryEndMS: r,
                nGlobalTLStartMS: (0, f.Z6)(c),
              }),
            );
          }
          return i.createElement(i.Fragment, null, u);
        });
      var He = r(90254),
        Ve = r(28349),
        qe = r(22042),
        Ze = r(95315),
        Ye = r(37151);
      function Je() {
        const e = C(),
          t = (0, z.we)(),
          r = (function () {
            const e = S(),
              t = v(),
              r = y(),
              n = b();
            return i.useCallback(
              (i, a, o, s) => {
                if (void 0 === o && void 0 === s) return;
                let l = o || n.nGlobalStartMS,
                  c = s || n.nGlobalEndMS;
                l &&
                  c &&
                  c.valMS <= l.valMS &&
                  (void 0 !== o ? (c = void 0) : (l = void 0));
                const u = p.nBeforeMS + p.nAfterMS;
                void 0 === l && (l = (0, f.Z6)(c.valMS - u)),
                  void 0 === c && (c = (0, f.Z6)(l.valMS + u));
                const d = l != n.nGlobalStartMS,
                  m = c != n.nGlobalEndMS;
                d && m ? e(a, l, c) : d ? t(a, l) : m && r(a, c);
              },
              [n, e, t, r],
            );
          })(),
          a = (0, n.SZ)(() => !t.ShouldModeShowClipControls()),
          o = (0, k.B$)(),
          { onMarkerCreated: s, onNavigateToClip: l } = ge();
        return i.useCallback(
          (n, c, u, d) => {
            if (a || o) return;
            const m = i.createElement(Ke, {
              isCurrentPlayback: u,
              nGlobalOffsetMS: c,
              playbackCoordinator: t,
              timelineView: e,
              fnSetSelectionClipRange: r,
              onMarkerCreated: s,
              onNavigateToClip: l,
            });
            (0, Ze.yV)(m, n, d);
          },
          [a, o, t, e, r, s, l],
        );
      }
      function Ke(e) {
        const {
            playbackCoordinator: t,
            timelineView: r,
            nGlobalOffsetMS: a,
            fnSetSelectionClipRange: s,
            isCurrentPlayback: l,
            onMarkerCreated: c,
            onNavigateToClip: u,
          } = e,
          d = (0, n.SZ)(() => r.GetAutoScrollPauseTimeout()),
          m = (0, n.SZ)(() => r.GetVisualWindowStartPX()),
          f = (0, n.SZ)(() => t.GetClipsAtGlobalMS(a)),
          p = (0, i.useRef)(),
          g = (0, i.useRef)();
        (0, i.useLayoutEffect)(() => {
          p.current && g.current ? g.current.Hide() : (p.current = !0);
        }, [m]),
          (0, i.useEffect)(() => {
            r.SetAutoScrollPaused(!0);
          }, [r]),
          (0, i.useEffect)(() => {
            d && r.ClearAutoScrollPauseTimeout();
          }, [d, r]);
        return i.createElement(
          qe.xV,
          { refInstance: g },
          i.createElement(
            qe.Zo,
            {
              onSelected: (e) => {
                t.AddUserMarkerAtGlobalMS(
                  a,
                  "/GameRecording/AddMarker/TimelineCtxMenu",
                  (t, r) => {
                    c && c(t, r, e);
                  },
                ),
                  t.SetPlaytimeFromGlobalMS(a),
                  t.FocusGlobalMS(a);
              },
              className: Ye.TimelineContextMenuItem,
            },
            i.createElement(
              "div",
              { className: (0, o.Z)(Ye.MenuItem, Ye.AddUserMarker) },
              i.createElement(ae.KT, null),
              (0, Q.Xx)(
                l
                  ? "#Playback_UserSelectionControls_AddUserMarker"
                  : "#TimelineDialog_AddMarker",
              ),
            ),
          ),
          i.createElement(
            qe.Zo,
            {
              onSelected: () => {
                s(t, 4, a, void 0),
                  t.SetPlaytimeFromGlobalMS(a),
                  t.FocusGlobalMS(a);
              },
              className: Ye.TimelineContextMenuItem,
            },
            i.createElement(
              "div",
              { className: (0, o.Z)(Ye.MenuItem, Ye.StartEndClip) },
              i.createElement(ae.Eq, { direction: "left" }),
              (0, Q.Xx)(
                l
                  ? "#Playback_UserSelectionControls_SetClipStart"
                  : "#TimelineContext_SetClipStart",
              ),
            ),
          ),
          i.createElement(
            qe.Zo,
            {
              onSelected: () => {
                s(t, 4, void 0, a),
                  t.SetPlaytimeFromGlobalMS(a),
                  t.FocusGlobalMS(a);
              },
              className: Ye.TimelineContextMenuItem,
            },
            i.createElement(
              "div",
              { className: (0, o.Z)(Ye.MenuItem, Ye.StartEndClip) },
              i.createElement(ae.Eq, { direction: "right" }),
              (0, Q.Xx)(
                l
                  ? "#Playback_UserSelectionControls_SetClipEnd"
                  : "#TimelineContext_SetClipEnd",
              ),
            ),
          ),
          f.length > 0 &&
            i.createElement(
              qe.Zo,
              {
                onSelected: () => {
                  f.length > 0 &&
                    (Y.q.ReportTrackedAction(
                      "/GameRecording/Tooltip/ViewClip/TimelineCtxMenu",
                    ),
                    u && u(f[0].strClipID));
                },
                className: Ye.TimelineContextMenuItem,
              },
              i.createElement(
                "div",
                { className: (0, o.Z)(Ye.MenuItem, Ye.ViewClip) },
                i.createElement(ae.TU, null),
                (0, Q.Xx)("#TimelineDialog_ViewClip"),
              ),
            ),
        );
      }
      var Qe = r(65772);
      const $e = parseInt(Qe.thumbnailWidth),
        et = i.forwardRef(function (e, t) {
          const {
              globalMS: r,
              children: a,
              imgClassName: s,
              className: l,
              ...c
            } = e,
            u = (0, z.we)(),
            d = u.GetGameID(),
            m = u.GetClipID(),
            f = (0, n.SZ)(() => u.GetRecordingMode()),
            p = (0, n.SZ)(() =>
              u.ConvertGlobaOffsetToRecordingAndRelativeOffset(r),
            ),
            g = ne(
              d,
              m,
              p?.strRecordingID,
              p?.nRecordingOffsetMS,
              p?.nStartOffsetMS,
              $e,
              false,
            ),
            [b, h] = (0, i.useState)();
          return (
            (0, i.useEffect)(() => {
              g && h(g);
            }, [g]),
            p?.strRecordingID
              ? i.createElement(
                  "div",
                  {
                    ref: t,
                    className: (0, o.Z)(Qe.TooltipOffset, Qe[f], l),
                    ...c,
                  },
                  i.createElement(
                    "div",
                    {
                      className: (0, o.Z)(
                        Qe.TooltipContents,
                        !b && Qe.Hide,
                        Qe[f],
                      ),
                    },
                    i.createElement(
                      "div",
                      { className: Qe.TooltipImageCtn },
                      b &&
                        i.createElement("img", {
                          className: (0, o.Z)(Qe.TooltipImage, s),
                          src: b,
                        }),
                    ),
                    i.createElement(
                      "div",
                      { className: (0, o.Z)(Qe.TooltipChildren) },
                      a,
                    ),
                  ),
                  i.createElement("div", {
                    className: (0, o.Z)(Qe.TooltipHitBox),
                  }),
                )
              : null
          );
        });
      function tt(e) {
        const t = (0, z.we)(),
          r = (0, n.SZ)(() => t.GetHidePlayer()),
          [a, o] = (0, i.useState)({ bDragActive: !1, bPausedOnDragStart: !1 }),
          s = C(),
          l = (0, n.SZ)(() => {
            if (
              s.GetAutoScrollPaused() ||
              s.BReachedMaxScroll() ||
              s.BReachedMinScroll() ||
              t.BIsVideoElementPaused()
            )
              return !1;
            const e = t.GetGlobalMSPlaytime();
            return (
              s.ConvertGlobalMSToGlobalPXOffset(e.valMS) <
              s.GetMaxScrollLeftPX() + 0.5 * s.GetScrollWindowWidth()
            );
          });
        return r
          ? i.createElement(it, { setDragActive: o })
          : l
            ? i.createElement(rt, { view: s, setDragActive: o })
            : i.createElement(nt, { dragState: a, setDragActive: o });
      }
      function rt(e) {
        const { view: t, setDragActive: r } = e,
          a = (0, n.SZ)(
            () => t.GetVisualWindowStartPX() + t.GetScrollWindowWidth() / 2,
          );
        return i.createElement(
          ct,
          { playheadPosition: a },
          i.createElement(at, { setDragActive: r }),
        );
      }
      const it = (0, i.memo)(function (e) {
          const { setDragActive: t } = e,
            r = C(),
            a = (0, n.SZ)(() => r.GetScrollableWidthPX()),
            o = (0, m.fB)(100),
            s = (0, i.useCallback)(
              (e) => {
                r.GetAutoScrollPaused() || o(() => r.ScrollToOffset(e));
              },
              [o, r],
            );
          return (
            (0, i.useEffect)(() => r.ScrollToEnd(), [r]),
            (0, i.useEffect)(() => s(a), [a, s]),
            i.createElement(
              ct,
              { playheadPosition: a },
              i.createElement(at, { setDragActive: t }),
            )
          );
        }),
        nt = (0, i.memo)(function (e) {
          const { dragState: t, setDragActive: r } = e,
            { bDragActive: a, bPausedOnDragStart: s } = t,
            l = (0, z.we)(),
            u = C(),
            d = Te(),
            m = Me(),
            p = d === be.Range,
            g = d === be.Highlight,
            b = ve(),
            h = (function (e, t, r, a, o) {
              const s = (0, i.useRef)(),
                l = (0, n.SZ)(() => t.GetScrollableWidthPX()),
                u = (0, n.SZ)(() => t.GetScrollWindowWidth()),
                [d, m] = (0, i.useState)(0),
                f = (0, i.useRef)(),
                p = (0, i.useRef)(),
                { clearPlaybackAnimation: g, startPlaybackAnimation: b } =
                  (function (e, t, r) {
                    const n = (0, i.useRef)(),
                      a = e.GetGameRecordingVideo(),
                      o = (0, i.useRef)(),
                      s = (0, i.useRef)(),
                      l = (0, i.useRef)(),
                      c = (0, i.useRef)(),
                      u = (0, i.useCallback)(() => {
                        if (!n.current) return;
                        const i = e.GetGlobalMSPlaytime();
                        if (i.valMS >= 0) {
                          const e = a.BVideoElementPlaying(),
                            n = a.GetVideoElementCurrentTime(),
                            u = t.GetScrollableWidthPX(),
                            d = t.GetCurrentZoomScale();
                          if (
                            o.current !== i.valMS ||
                            (c.current && c.current != d)
                          ) {
                            const e = t.ConvertGlobalMSToGlobalPXOffset(
                                i.valMS,
                              ),
                              n = Math.min(u, e);
                            r(n), (l.current = n);
                          } else if (
                            o.current &&
                            o.current === i.valMS &&
                            n &&
                            s.current &&
                            s.current !== n &&
                            e
                          ) {
                            const e = o.current + 1e3 * (n - s.current),
                              i = t.ConvertGlobalMSToGlobalPXOffset(e);
                            if (l.current && l.current < i) {
                              const e = Math.min(u, i);
                              r(e);
                            }
                            l.current = i;
                          }
                          e || ((s.current = null), (o.current = i.valMS)),
                            e &&
                              o.current !== i.valMS &&
                              ((s.current = n), (o.current = i.valMS)),
                            (c.current = d);
                        }
                        n.current = requestAnimationFrame(u);
                      }, [e, r, t, a]),
                      d = (0, i.useCallback)(() => {
                        n.current && cancelAnimationFrame(n.current),
                          (n.current = null),
                          (o.current = null),
                          (s.current = null),
                          (l.current = null);
                      }, []),
                      m = (0, i.useCallback)(() => {
                        n.current || (n.current = requestAnimationFrame(u));
                      }, [u]);
                    return {
                      clearPlaybackAnimation: d,
                      startPlaybackAnimation: m,
                    };
                  })(o, t, m);
              (0, i.useEffect)(
                () => () => {
                  f.current &&
                    (cancelAnimationFrame(f.current),
                    (f.current = null),
                    (p.current = null)),
                    g();
                },
                [g],
              );
              const h = i.useCallback(
                (e, t, r, i, n) => {
                  if (n(t))
                    m(
                      (0, c.Lh)(
                        t.GetVisualWindowStartPX() + r,
                        0,
                        t.GetScrollableWidthPX(),
                      ),
                    ),
                      cancelAnimationFrame(f.current),
                      (f.current = null),
                      (p.current = null);
                  else {
                    if (
                      (f.current &&
                        (f.current = requestAnimationFrame((e) =>
                          h(e, t, r, i, n),
                        )),
                      p.current)
                    ) {
                      const r = ((e - p.current) / 500) * i;
                      t.ScrollBy(r),
                        m((e) => (0, c.Lh)(e + r, 0, t.GetScrollableWidthPX()));
                    }
                    p.current = e;
                  }
                },
                [m],
              );
              return (
                (0, i.useEffect)(() => {
                  const i = u * Kt,
                    n = u * Qt;
                  if (
                    (f.current &&
                      (cancelAnimationFrame(f.current),
                      (f.current = null),
                      (p.current = null)),
                    r)
                  )
                    if ((g(), e.valPX < n && !t.BReachedMinScroll())) {
                      if (e.valPX <= s.current) {
                        const r = e.valPX - n,
                          i = (0, c.Lh)(Math.abs(r / n), 0, 1) * r;
                        f.current = requestAnimationFrame((r) =>
                          h(r, t, e.valPX, i, t.BReachedMinScroll),
                        );
                      }
                      s.current = e.valPX;
                    } else if (e.valPX > i && !t.BReachedMaxScroll()) {
                      if (e.valPX >= s.current) {
                        const r = e.valPX - i,
                          n = (0, c.Lh)(Math.abs(r / (u - i)), 0, 1) * r;
                        f.current = requestAnimationFrame((r) =>
                          h(r, t, e.valPX, n, t.BReachedMaxScroll),
                        );
                      }
                      s.current = e.valPX;
                    } else m((0, c.Lh)(a.valPX, 0, l));
                  else b();
                }, [r, g, a.valPX, u, l, h, e.valPX, b, t]),
                d
              );
            })(ye(), u, a, b, l),
            _ = (0, z.we)(),
            S = (0, n.SZ)(() => "Overlay" === _.GetRecordingMode()),
            v = (0, J.lL)({
              toolTipContent: i.createElement(ot, { globalPX: h }),
              direction: S ? "bottom" : "top",
              nDelayShowMS: 0,
              nBodyDistance: 0,
              nAllowOffscreenPx: 0,
            });
          return (
            (0, i.useEffect)(() => {
              if (!a) return;
              const e = u.ConvertPXOffsetToGlobalMS(h, !1);
              if (!e) return;
              const t = l.GetLiveEdgeMS();
              l.SetPlaytimeFromGlobalMS(t.valMS < e ? t : (0, f.Z6)(e), s);
            }, [h, s, a, l, u]),
            (0, i.useEffect)(() => m(a ? be.Playhead : null), [a, m]),
            i.createElement(
              "div",
              {
                className: (0, o.Z)(
                  Ve.PlayheadInteractionCtn,
                  a && Ve.ActiveCtn,
                ),
              },
              i.createElement(
                ct,
                { className: a ? Ve.Active : void 0, playheadPosition: h },
                i.createElement(
                  "div",
                  {
                    className: (0, o.Z)(Ve.TooltipSource, p && Ve.NoPointer),
                    ...v.divProps,
                  },
                  i.createElement(at, { setDragActive: r }),
                ),
                !g && v.tooltip,
              ),
            )
          );
        }),
        at = (0, i.memo)(function (e) {
          const { setDragActive: t } = e,
            r = (e) => e.stopPropagation(),
            n = (e) => e.stopPropagation();
          return i.createElement(
            "div",
            {
              className: Ve.PlayHeadContent,
              onMouseOver: r,
              onMouseOut: n,
              onFocus: r,
              onBlur: n,
            },
            i.createElement(st, { setDragActive: t }),
          );
        }),
        ot = (0, i.memo)(function (e) {
          const { globalPX: t } = e,
            r = C(),
            a = (0, n.SZ)(() => r.ConvertPXOffsetToGlobalMS(t, !1)),
            o = (0, n.SZ)(() =>
              a ? r.GetStateDescriptionAtGlobalMS(a) : null,
            ),
            s = (0, n.SZ)(() =>
              r.ConvertPXToTimelineRelativeMS(t, "end-if-active"),
            );
          return i.createElement(
            et,
            { globalMS: a },
            i.createElement(
              "div",
              { className: Ve.TooltipContents },
              o?.title &&
                i.createElement(
                  "div",
                  { className: Ve.StateDescription },
                  o.title,
                ),
              i.createElement(
                "div",
                { className: Ve.TooltipTime },
                Boolean(s) &&
                  i.createElement(
                    "div",
                    { className: Ve.SeekTimeContainer },
                    (0, K.SF)(s / 1e3, !1),
                  ),
              ),
            ),
          );
        }),
        st = i.memo(function (e) {
          const { setDragActive: t } = e,
            r = (0, z.we)(),
            n = Je(),
            a = Te() === be.Range,
            s = (0, i.useCallback)(
              (e) => {
                if (0 != e.button) return;
                const i = (0, fe.RA)(e);
                let n, a;
                const o = () => {
                  const e = r.GetGameRecordingVideo().IsPaused();
                  t({ bDragActive: !0, bPausedOnDragStart: e }), n();
                };
                i.addEventListener("mousemove", o),
                  (n = () => i.removeEventListener("mousemove", o));
                const s = () => {
                  t({ bDragActive: !1, bPausedOnDragStart: !1 }), n(), a();
                };
                i.addEventListener("mouseup", s),
                  (a = () => i.removeEventListener("mouseup", s));
              },
              [t, r],
            ),
            l = (0, i.useCallback)(
              (e) => {
                const t = r.GetGlobalMSPlaytime();
                n(e, t, !0, {
                  bDisableMouseOverlay: !0,
                  bForcePopup: !0,
                  bAlwaysOnTop: !0,
                }),
                  e.stopPropagation(),
                  e.preventDefault();
              },
              [r, n],
            );
          return i.createElement(
            "div",
            {
              className: (0, o.Z)(Ve.PlayHead, a && Ve.NoPointer),
              onMouseDown: s,
              onContextMenu: l,
            },
            i.createElement(lt, null),
          );
        });
      function lt(e) {
        return i.createElement(
          "svg",
          {
            ...e,
            width: "12",
            height: "32",
            viewBox: "0 0 12 24",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          i.createElement("rect", {
            x: "5",
            y: "4",
            width: "2",
            height: "40",
            fill: "currentColor",
          }),
          i.createElement("path", {
            d: "M6 6L0.803849 -9.78799e-07L11.1962 -7.02746e-08L6 6Z",
            fill: "currentColor",
          }),
        );
      }
      function ct(e) {
        const { className: t, playheadPosition: r, children: n } = e;
        return i.createElement(
          "div",
          {
            className: (0, o.Z)(Ve.PlayHeadContainer, t),
            style: { transform: `translateX( calc(${r}px - 50% ))` },
          },
          n,
        );
      }
      function ut(e) {
        const t = (0, i.useContext)(_e),
          r = Te();
        return r && (r === be.Playhead || r === be.Range)
          ? null
          : i.createElement(dt, {
              globalMouseXPX: t.globalMouseXPX.valPX || 0,
            });
      }
      const dt = i.memo(function (e) {
          const { globalMouseXPX: t } = e,
            r = C(),
            n = (0, z.we)(),
            a = (0, i.useContext)(_e).bContainerFocus,
            o = Je(),
            [s, l] = (0, i.useState)(),
            [u, d] = (0, i.useState)();
          (0, i.useEffect)(() => {
            u || l(t);
          }, [u, t, r]);
          const m = (0, i.useCallback)(
              (e) => {
                if (!a) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  i = c.Lh(e.clientX - t.x, 0, t.width),
                  o = r.ConvertPXOffsetToGlobalMS(i, !1);
                o && n.SetPlaytimeFromGlobalMS((0, f.Z6)(o));
              },
              [a, n, r],
            ),
            p = (0, i.useCallback)(
              (e) => {
                if (!a) return;
                const t = e.currentTarget.getBoundingClientRect(),
                  i = c.Lh(e.clientX - t.x, 0, t.width),
                  n = r.ConvertPXOffsetToGlobalMS(i, !1);
                n &&
                  (o(e, (0, f.Z6)(n), !1, {
                    bDisableMouseOverlay: !0,
                    bForcePopup: !0,
                    bAlwaysOnTop: !0,
                  }),
                  e.preventDefault(),
                  e.stopPropagation());
              },
              [a, r, o],
            );
          return (
            Be("click", m),
            Be("contextmenu", p),
            i.createElement(
              "div",
              {
                className: He.GhostPlayheadCtn,
                style: { transform: `translateX( calc(${s}px - 50%))` },
              },
              i.createElement(ft, { globalPX: s, setFreezeMouse: d }),
            )
          );
        }),
        mt = i.forwardRef(function (e, t) {
          const { globalPX: r } = e,
            a = C(),
            s = (0, z.we)(),
            l = (0, n.SZ)(() => a.ConvertPXOffsetToGlobalMS(r, !1)),
            c = (0, n.SZ)(() => a.GetStateDescriptionAtGlobalMS(l)),
            u = (0, n.SZ)(() =>
              a.ConvertPXToTimelineRelativeMS(r, "end-if-active"),
            ),
            d = (0, n.SZ)(() => a.ConvertGlobalMSToClipOrNone(l)),
            { onNavigateToClip: m } = ge();
          return i.createElement(
            et,
            { globalMS: l, ref: t },
            c?.title &&
              i.createElement(
                "div",
                { className: He.StateDescription },
                c.title,
              ),
            i.createElement(
              "div",
              { className: He.TooltipButtons },
              Boolean(u) &&
                i.createElement(
                  "div",
                  { className: He.SeekTimeContainer },
                  (0, K.SF)(u / 1e3, !1),
                ),
              i.createElement(
                J.HP,
                {
                  toolTipContent: (0, Q.Xx)("#TimelineDialog_AddMarker"),
                  direction: "top",
                },
                i.createElement(
                  "div",
                  {
                    className: (0, o.Z)(He.Button, He.AddMarker),
                    onClick: () => {
                      s.AddUserMarkerAtGlobalMS(
                        (0, f.Z6)(l),
                        "/GameRecording/AddMarker/Playhead",
                        null,
                      ),
                        s.SetPlaytimeFromGlobalMS((0, f.Z6)(l));
                    },
                  },
                  i.createElement(ae.Jx, null),
                ),
              ),
              d &&
                i.createElement(
                  J.HP,
                  {
                    toolTipContent: (0, Q.Xx)("#TimelineDialog_ViewClip"),
                    direction: "top",
                  },
                  i.createElement(
                    "div",
                    {
                      className: (0, o.Z)(He.Button, He.GoToClip),
                      onClick: () => {
                        d && m(d.clipID);
                      },
                    },
                    i.createElement(oe.nkn, null),
                  ),
                ),
            ),
          );
        }),
        ft = (0, i.memo)(function (e) {
          const { globalPX: t, setFreezeMouse: r } = e,
            a = C(),
            o = (0, z.we)(),
            s = Te(),
            l = s && s === be.Highlight,
            [c, u] = (0, i.useState)(!1),
            d = (0, n.SZ)(() => "Overlay" === o.GetRecordingMode()),
            m = (0, n.SZ)(() => a.ConvertPXOffsetToGlobalMS(t, !1)),
            f = (0, n.SZ)(() => a.GetTimelineParentCtnRef()),
            p = (0, i.useRef)(),
            g = (0, i.useRef)(),
            b = (0, i.useRef)(),
            h = (0, J.lL)({
              toolTipContent: i.createElement(mt, { globalPX: t, ref: p }),
              direction: d ? "bottom" : "top",
              nDelayShowMS: 0,
              nBodyDistance: 0,
              nAllowOffscreenPx: 0,
            }),
            { onMouseEnter: _, onMouseLeave: S } = h.divProps,
            v = (0, i.useCallback)(() => {
              S(), r(!1), u(!1), b.current && b.current(), (b.current = null);
            }, [S, r]),
            y = (0, i.useCallback)(() => {
              v(), a.GetAutoScrollPaused() && a.SetAutoScrollPauseTimeout();
            }, [v, a]);
          (0, i.useEffect)(() => v, [v]),
            (0, i.useEffect)(() => {
              const e = (e) => {
                p.current && !(0, fe.ni)(p.current, e.relatedTarget) && y();
              };
              return (
                f && f.addEventListener("mouseleave", e),
                () => f && f.removeEventListener("mouseleave", e)
              );
            }, [y, f]);
          const M = (0, i.useCallback)(
            (e) => {
              if (!g.current) return;
              const t = g.current.getBoundingClientRect(),
                r = t.left,
                i = t.right;
              let n = t.top,
                a = t.bottom;
              if (p.current) {
                const e = p.current.getBoundingClientRect();
                d ? (a = e.bottom) : (n = e.top);
              }
              (e.clientX <= r ||
                e.clientX >= i ||
                e.clientY <= n ||
                e.clientY >= a) &&
                y();
            },
            [d, y],
          );
          return m
            ? i.createElement(
                "div",
                {
                  ref: g,
                  className: He.GhostPlayheadHoverSource,
                  onMouseOver: (e) => {
                    if (
                      (u(!0),
                      _(e),
                      e.target === g.current && r(!1),
                      (0, fe.ni)(p.current, e.target) && r(!0),
                      !b.current)
                    ) {
                      const t = (0, fe.RA)(e);
                      t.addEventListener("mousemove", M),
                        (b.current = () =>
                          t.removeEventListener("mousemove", M));
                    }
                  },
                  onFocus: () => {},
                  onBlur: () => {},
                  onMouseOut: (e) => {
                    const t = g.current.getBoundingClientRect(),
                      i = t.left,
                      n = t.right;
                    e.clientX <= i || e.clientX >= n
                      ? y()
                      : e.target === g.current &&
                        (e.clientY >= t.top && e.clientY <= t.bottom
                          ? v()
                          : r(!0));
                  },
                },
                c && i.createElement(lt, { className: He.GhostPlayhead }),
                !l && h.tooltip,
              )
            : null;
        });
      var pt = r(94314);
      const gt = 500,
        bt = (0, i.memo)(function () {
          const [e, t] = (0, i.useState)("none"),
            r = S(),
            n = h(),
            a = _();
          return r && n && a
            ? i.createElement(
                "div",
                { className: pt.RangeControls },
                i.createElement(ht, {
                  activeControlState: e,
                  setActiveControlState: t,
                }),
              )
            : null;
        }),
        ht = (0, i.memo)(function (e) {
          const { activeControlState: t, setActiveControlState: r } = e,
            [a, s] = (0, i.useState)(),
            [l, c] = (0, i.useState)(),
            u = h(),
            d = _(),
            m = C(),
            f = (0, n.SZ)(() => m.ConvertGlobalMSToGlobalPXOffset(u.valMS)),
            p = (0, n.SZ)(() => m.ConvertGlobalMSToGlobalPXOffset(d.valMS)),
            g = (0, i.useCallback)(
              (e) => {
                "none" === t && e.stopPropagation();
              },
              [t],
            ),
            b = (0, i.useCallback)(
              (e) => {
                "none" === t && e.stopPropagation();
              },
              [t],
            );
          return i.createElement(
            "div",
            {
              className: (0, o.Z)(
                pt.RangeSelectorCtn,
                "none" !== t && pt.Active,
              ),
              onMouseOver: g,
              onMouseOut: b,
              onFocus: g,
              onBlur: b,
            },
            i.createElement(
              "div",
              { className: pt.TrackRangeControls },
              i.createElement(_t, {
                isActive: "left" === t,
                setControlState: r,
                setRangeControlPX: s,
                pxOffset: a,
              }),
              i.createElement(Tt, {
                startOffsetPX: "left" === t ? a : f,
                endOffsetPX: "right" === t ? l : p,
                className: pt.SelectedRangeMask,
              }),
              i.createElement(vt, {
                isActive: "right" === t,
                setControlState: r,
                setRangeControlPX: c,
                pxOffset: l,
              }),
            ),
          );
        });
      const _t = (0, i.memo)(function (e) {
        const {
            isActive: t,
            setControlState: r,
            setRangeControlPX: n,
            pxOffset: a,
          } = e,
          o = h();
        return t
          ? i.createElement(St, {
              setControlState: r,
              setRangeControlPX: n,
              pxOffset: a,
            })
          : i.createElement(Mt, {
              offsetMS: o.valMS,
              direction: "left",
              setControlState: r,
              setRangeControlPX: n,
            });
      });
      function St(e) {
        const { setControlState: t, setRangeControlPX: r, pxOffset: a } = e,
          o = v(),
          s = _(),
          l = C(),
          u = ve(),
          d = ye(),
          m = Me();
        return (
          (function (e, t, r, n, a, o, s, l) {
            const u = (0, i.useRef)(),
              d = (0, i.useRef)(),
              m = (0, i.useRef)();
            (0, i.useEffect)(
              () => () => {
                d.current &&
                  (cancelAnimationFrame(d.current),
                  (d.current = null),
                  (m.current = null));
              },
              [],
            );
            const f = i.useCallback(
              (e, t, r, i, n) => {
                if (n(t))
                  l(
                    c.Lh(
                      t.GetVisualWindowStartPX() + r,
                      0,
                      t.GetScrollableWidthPX(),
                    ),
                  ),
                    cancelAnimationFrame(d.current),
                    (d.current = null),
                    (m.current = null);
                else {
                  if (
                    (d.current &&
                      (d.current = requestAnimationFrame((e) =>
                        f(e, t, r, i, n),
                      )),
                    m.current)
                  ) {
                    const r = ((e - m.current) / gt) * i;
                    t.ScrollBy(r),
                      l((e) => c.Lh(e + r, 0, t.GetScrollableWidthPX()));
                  }
                  m.current = e;
                }
              },
              [l],
            );
            (0, i.useEffect)(() => {
              d.current &&
                (cancelAnimationFrame(d.current),
                (d.current = null),
                (m.current = null));
              const i = t * Kt,
                p = t * Qt,
                g = n.ConvertGlobalMSToGlobalPXOffset(a.valMS),
                b = n.ConvertGlobalMSToScrollWindowPXOffset(a.valMS);
              if (o.valPX > g) return l(g), void s("right");
              if (r.valPX < p && !n.BReachedMinScroll()) {
                if (r.valPX <= u.current) {
                  const e = r.valPX - p,
                    t = c.Lh(Math.abs(e / p), 0, 1) * e;
                  d.current = requestAnimationFrame((e) =>
                    f(e, n, r.valPX, t, n.BReachedMinScroll),
                  );
                } else l(c.Lh(o.valPX, 0, e));
                u.current = r.valPX;
              } else if (r.valPX > p && b > i && !n.BReachedMaxScroll()) {
                if (r.valPX >= u.current) {
                  const e = (e) => {
                      const t = e.ConvertGlobalMSToScrollWindowPXOffset(
                        a.valMS,
                      );
                      return e.BReachedMaxScroll() || t <= i;
                    },
                    t = r.valPX - p,
                    o = c.Lh(Math.abs(t / p), 0, 1) * t;
                  d.current = requestAnimationFrame((t) =>
                    f(t, n, r.valPX, o, e),
                  );
                } else l(c.Lh(o.valPX, 0, e));
                u.current = r.valPX;
              } else l(c.Lh(o.valPX, 0, e)), (u.current = r.valPX);
            }, [o.valPX, a.valMS, r.valPX, s, n, l, a, e, f, t]);
          })(
            (0, n.SZ)(() => l.GetScrollableWidthPX()),
            (0, n.SZ)(() => l.GetScrollWindowWidth()),
            d,
            l,
            s,
            u,
            t,
            r,
          ),
          (0, i.useEffect)(() => {
            o(5, (0, f.Z6)(l.ConvertPXOffsetToGlobalMS(a)));
          }, [a, o, l]),
          (0, i.useEffect)(() => (m(be.Range), () => m(null)), [m]),
          i.createElement(Bt, {
            offsetPX: a,
            direction: "left",
            bActiveTooltip: !0,
          })
        );
      }
      const vt = (0, i.memo)(function (e) {
        const {
            isActive: t,
            setControlState: r,
            setRangeControlPX: n,
            pxOffset: a,
          } = e,
          o = _();
        return t
          ? i.createElement(yt, {
              setControlState: r,
              setRangeControlPX: n,
              pxOffset: a,
            })
          : i.createElement(Mt, {
              offsetMS: o.valMS,
              direction: "right",
              setControlState: r,
              setRangeControlPX: n,
            });
      });
      function yt(e) {
        const { setControlState: t, setRangeControlPX: r, pxOffset: a } = e,
          o = y(),
          s = h(),
          l = C(),
          u = ve(),
          d = ye(),
          m = Me();
        return (
          (function (e, t, r, n, a, o, s, l) {
            const u = (0, i.useRef)(),
              d = (0, i.useRef)(),
              m = (0, i.useRef)();
            (0, i.useEffect)(
              () => () => {
                d.current &&
                  (cancelAnimationFrame(d.current),
                  (d.current = null),
                  (m.current = null));
              },
              [],
            );
            const f = i.useCallback(
              (e, t, r, i, n) => {
                if (n(t))
                  l(
                    c.Lh(
                      t.GetVisualWindowStartPX() + r,
                      0,
                      t.GetScrollableWidthPX(),
                    ),
                  ),
                    cancelAnimationFrame(d.current),
                    (d.current = null),
                    (m.current = null);
                else {
                  if (
                    (d.current &&
                      (d.current = requestAnimationFrame((e) =>
                        f(e, t, r, i, n),
                      )),
                    m.current)
                  ) {
                    const r = ((e - m.current) / gt) * i;
                    t.ScrollBy(r),
                      l((e) => c.Lh(e + r, 0, t.GetScrollableWidthPX()));
                  }
                  m.current = e;
                }
              },
              [l],
            );
            (0, i.useEffect)(() => {
              d.current &&
                (cancelAnimationFrame(d.current),
                (d.current = null),
                (m.current = null));
              const i = t * Kt,
                p = t * Qt,
                g = n.ConvertGlobalMSToGlobalPXOffset(a.valMS),
                b = n.ConvertGlobalMSToScrollWindowPXOffset(a.valMS);
              if (o.valPX < g) return l(g), void s("left");
              if (r.valPX > i && !n.BReachedMaxScroll()) {
                if (r.valPX >= u.current) {
                  const e = r.valPX - i,
                    a = c.Lh(Math.abs(e / (t - i)), 0, 1) * e;
                  d.current = requestAnimationFrame((e) =>
                    f(e, n, r.valPX, a, n.BReachedMaxScroll),
                  );
                } else l(c.Lh(o.valPX, 0, e));
                u.current = r.valPX;
              } else if (
                r.valPX < i &&
                b < p &&
                r.valPX <= u.current &&
                !n.BReachedMinScroll()
              ) {
                if (r.valPX <= u.current) {
                  const e = r.valPX - i,
                    o = c.Lh(Math.abs(e / (t - i)), 0, 1) * e,
                    s = (e) =>
                      e.ConvertGlobalMSToScrollWindowPXOffset(a.valMS) > p ||
                      e.BReachedMinScroll();
                  d.current = requestAnimationFrame((e) =>
                    f(e, n, r.valPX, o, s),
                  );
                } else l(c.Lh(o.valPX, 0, e));
                u.current = r.valPX;
              } else l(c.Lh(o.valPX, 0, e)), (u.current = r.valPX);
            }, [a.valMS, r.valPX, s, n, l, e, t, o.valPX, f]);
          })(
            (0, n.SZ)(() => l.GetScrollableWidthPX()),
            (0, n.SZ)(() => l.GetScrollWindowWidth()),
            d,
            l,
            s,
            u,
            t,
            r,
          ),
          (0, i.useEffect)(() => {
            o(5, (0, f.Z6)(l.ConvertPXOffsetToGlobalMS(a)));
          }, [a, o, l]),
          (0, i.useEffect)(() => (m(be.Range), () => m(null)), [m]),
          i.createElement(Bt, {
            offsetPX: a,
            direction: "right",
            bActiveTooltip: !0,
          })
        );
      }
      function Mt(e) {
        const {
            offsetMS: t,
            direction: r,
            setControlState: a,
            setRangeControlPX: o,
          } = e,
          s = C(),
          l = (0, n.SZ)(() => s.ConvertGlobalMSToGlobalPXOffset(t));
        (0, i.useEffect)(
          () => (
            o(void 0),
            () => {
              o(l);
            }
          ),
          [l, o],
        );
        const c = (0, i.useCallback)(
          (e) => {
            const t = (0, fe.RA)(e);
            let i, n;
            const o = () => {
              a(r), i();
            };
            t.addEventListener("mousemove", o),
              (i = () => t.removeEventListener("mousemove", o));
            const s = () => {
              a("none"), i(), n();
            };
            t.addEventListener("mouseup", s),
              (n = () => t.removeEventListener("mouseup", s));
          },
          [r, a],
        );
        return i.createElement(
          "div",
          { className: pt.InactiveSelectedRangeControl, onMouseDown: c },
          i.createElement(Bt, { offsetPX: l, direction: r }),
        );
      }
      const Tt = (0, i.memo)(function (e) {
          const { startOffsetPX: t, endOffsetPX: r, className: n } = e,
            a = { width: r - t || 0, transform: `translateX(${t}px)` };
          return i.createElement("div", {
            className: (0, o.Z)(pt.RangeMask, n),
            style: a,
          });
        }),
        Bt = (0, i.memo)(function (e) {
          const { direction: t, offsetPX: r, bActiveTooltip: a } = e,
            s = { transform: `translateX(${r}px)` },
            l = (0, z.we)(),
            c = (0, n.SZ)(() => "Overlay" === l.GetRecordingMode()),
            u = Te(),
            d = u && u === be.Playhead,
            m = u && u === be.Highlight,
            f = (0, J.lL)({
              toolTipContent: i.createElement(Et, { globalPX: r }),
              direction: c ? "bottom" : "top",
              nDelayShowMS: 0,
              nBodyDistance: 0,
              nAllowOffscreenPx: 0,
            });
          return i.createElement(
            "div",
            {
              className: (0, o.Z)(pt.RangeControl, a && pt.ActiveControl),
              style: s,
            },
            i.createElement(
              "div",
              {
                className: (0, o.Z)(
                  pt.RangeTooltipSource,
                  a && pt.Active,
                  d && pt.Hide,
                ),
                ...f.divProps,
              },
              i.createElement(
                "div",
                {
                  className: (0, o.Z)(
                    pt.RangeIcon,
                    "left" === t && pt.Left,
                    d && pt.Hide,
                  ),
                },
                i.createElement(Rt, { innerFill: "#171d25", direction: t }),
              ),
            ),
            !m && f.tooltip,
          );
        });
      function Rt(e) {
        return i.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 3 36",
            fill: "none",
            style: {
              transform: `rotate(${"right" === e.direction ? 180 : 0}deg)`,
            },
          },
          i.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 0)",
          }),
          i.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 10)",
          }),
          i.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 20)",
          }),
          i.createElement("rect", {
            fill: "currentColor",
            width: "3",
            height: "6.00006",
            transform: "matrix(-1 0 0 1 3 30)",
          }),
        );
      }
      const Et = (0, i.memo)(function (e) {
        const { globalPX: t } = e,
          r = C(),
          a = (0, n.SZ)(() => r.ConvertPXOffsetToGlobalMS(t, !1)),
          o = (0, n.SZ)(() => (a ? r.GetStateDescriptionAtGlobalMS(a) : null)),
          s = (0, n.SZ)(() =>
            r.ConvertPXToTimelineRelativeMS(t, "end-if-active"),
          );
        return i.createElement(
          et,
          {
            globalMS: a,
            className: pt.RangeTooltip,
            imgClassName: pt.RangeTooltipImage,
          },
          i.createElement(
            "div",
            { className: pt.TooltipContents },
            o?.title &&
              i.createElement(
                "div",
                { className: pt.StateDescription },
                o.title,
              ),
            i.createElement(
              "div",
              { className: pt.TooltipTime },
              Boolean(s) &&
                i.createElement(
                  "div",
                  { className: pt.SeekTimeContainer },
                  (0, K.SF)(s / 1e3, !1),
                ),
            ),
          ),
        );
      });
      var wt = r(60024);
      const Ct = i.memo(function (e) {
        const t = C(),
          r = (0, n.SZ)(() => t.GetVisibleWindowRelativeTimelines()),
          a = (0, z.we)().GetRecordingMode();
        let o = [],
          s = "";
        for (let e of r) {
          let r = t.GetTimeRecorded(e.timelineID),
            i = (0, Q.m9)(r);
          i != s && (o.push({ timeline: e, strLabel: i }), (s = i));
        }
        for (let e = o.length - 2; e >= 0; e--) {
          let t = o[e];
          o[e + 1].timeline.nVisibleStartPX - t.timeline.nVisibleStartPX >=
            100 || o.splice(e, 1);
        }
        return i.createElement(
          i.Fragment,
          null,
          o.map((e) =>
            i.createElement(Gt, {
              key: e.timeline.timelineID,
              startPX: e.timeline.nVisibleStartPX,
              label: e.strLabel,
              recordingMode: a,
            }),
          ),
        );
      });
      function Gt(e) {
        const { label: t, startPX: r, recordingMode: n } = e;
        let a = n == z.tP.Overlay;
        return i.createElement(
          "div",
          {
            className: (0, o.Z)(wt.TimelineRelativeDate, a && wt.Overlay),
            style: { transform: `translateX(${r}px)` },
          },
          t,
        );
      }
      var Pt = r(64287),
        It = r(7286);
      const Dt = (0, i.memo)(function (e) {
        const t = C(),
          r = (0, n.SZ)(() => t.GetVisibleRecordings());
        return i.createElement(
          i.Fragment,
          null,
          r.map((e) =>
            i.createElement(Ot, {
              key: e.recordingID,
              startPX: e.nStartPX,
              endPX: e.nEndPX,
              isActive: e.bIsActive,
              recordingType: e.recordingType,
            }),
          ),
        );
      });
      function Ot(e) {
        const { isActive: t, endPX: r, startPX: n, recordingType: a } = e,
          s = { width: r - n || 0, transform: `translateX(${n}px)` },
          l = T(),
          c = 4 === a,
          u = 2 === a;
        return i.createElement(
          i.Fragment,
          null,
          i.createElement("div", {
            className: (0, o.Z)(
              Pt.RecordingDecorator,
              c && Pt.Clip,
              u && Pt.Manual,
              l && Pt.ClipMode,
            ),
            style: s,
          }),
          t && i.createElement(Ft, { endPX: r }),
        );
      }
      function Ft(e) {
        const { endPX: t } = e,
          r = (0, z.we)(),
          a = C(),
          s = (0, n.SZ)(() => "Overlay" === r.GetRecordingMode()),
          l = (0, It.nW)(r.GetGameID()),
          c = (0, n.SZ)(() => r.GetIsLiveEdge() && !r.GetHidePlayer()),
          u = (0, n.SZ)(() => {
            const e = r.GetLiveEdgeBufferWindowStartMS();
            return a.ConvertGlobalMSToGlobalPXOffset(e.valMS);
          });
        if (!s || l !== It.m8.BackgroundRecording) return null;
        const d = { width: t - u || 0, transform: `translateX(${u}px)` };
        return i.createElement("div", {
          className: (0, o.Z)(Pt.LiveRecordingBuffer, c && Pt.IsLive),
          style: d,
        });
      }
      var zt = r(91839);
      const xt = (0, i.memo)(function (e) {
          const t = C(),
            r = (0, n.SZ)(() => t.GetVisibleClips());
          return i.createElement(
            i.Fragment,
            null,
            r.map((e) =>
              i.createElement(At, {
                key: e.clipID,
                startPX: e.pxClipStart,
                endPX: e.pxClipEnd,
              }),
            ),
          );
        }),
        At = (0, i.memo)(function (e) {
          const { endPX: t, startPX: r } = e,
            n = { width: t - r || 0, transform: `translateX(${r}px)` };
          return i.createElement("div", {
            className: zt.ClipDecorator,
            style: n,
          });
        });
      var Wt = r(95694);
      const kt = (0, i.forwardRef)(function (e, t) {
          const r = C();
          return (0, n.SZ)(() => r.GetNumTimelines())
            ? i.createElement(Lt, { ...e, timelineView: r, ref: t })
            : i.createElement(Nt, { ref: t });
        }),
        Nt = (0, i.forwardRef)(function (e, t) {
          return i.createElement("div", {
            ref: t,
            className: (0, o.Z)(Wt.ScrollbarPlaceholder, e.className),
          });
        }),
        Lt = (0, i.forwardRef)(function (e, t) {
          const r = (0, z.we)(),
            { children: a, className: s, timelineView: l, disableZoom: c } = e,
            [u, d] = (0, i.useState)(),
            f = i.useCallback(
              (e) => {
                const t = e.target.getBoundingClientRect();
                l.SetScrollWindowOffset(t.x),
                  l.SetScrollWindowWidth(t.width),
                  d(t);
              },
              [l],
            ),
            p = (0, m.yU)(f),
            g = i.useCallback(
              (e) => {
                if (e.ctrlKey && !c) {
                  const t = u ? (e.clientX - u.x) / u.width : 0.5;
                  e.deltaY > 0
                    ? l.ZoomOut(e.deltaY / 100, t)
                    : l.ZoomIn(-e.deltaY / 100, t);
                } else l.ScrollBy(e.deltaY);
              },
              [c, u, l],
            );
          return (
            (function (e, t) {
              const r = (0, n.SZ)(
                () =>
                  !t.GetAutoScrollPaused() &&
                  e.GetGameRecordingVideo().BVideoElementPlaying(),
              );
              (0, i.useEffect)(() => {
                if (!r) return () => {};
                let i = !1,
                  n = e.GetGlobalMSPlaytime(),
                  a = Date.now();
                const o = (r) => {
                  const s = Date.now(),
                    l = s - a;
                  t.ScrollToCenteredGlobalMS(n.valMS + l);
                  const c = e.GetGlobalMSPlaytime();
                  c.valMS !== n.valMS && ((n = c), (a = s)),
                    i || requestAnimationFrame(o);
                };
                return requestAnimationFrame(o), () => (i = !0);
              }, [e, t, r]);
            })(r, l),
            i.createElement(
              "div",
              {
                ref: t,
                onWheel: g,
                onMouseOver: () => l.SetAutoScrollPaused(!0),
                onFocus: () => {},
                onMouseLeave: () => l.SetAutoScrollPauseTimeout(),
              },
              i.createElement(
                "div",
                { className: Wt.LeftControlsAndContent },
                i.createElement(
                  "div",
                  { ref: p, className: (0, o.Z)(Wt.ContentAndGradient, s) },
                  a,
                  i.createElement(Xt, { timelineView: l }),
                ),
                r.GetRecordingMode() === z.tP.Overlay &&
                  i.createElement(It.Gn, null),
              ),
              i.createElement(
                "div",
                { className: Wt.ScrollbarAndSiblings },
                !r.GetGamepadMode() && i.createElement(Ut, null),
              ),
            )
          );
        });
      function Xt(e) {
        const { timelineView: t } = e,
          r = (0, n.SZ)(() => t.GetVisualWindowStartPX()),
          a = (0, n.SZ)(() => t.BReachedMaxScroll());
        return i.createElement(
          "div",
          { className: Wt.ScrollGradientCtn },
          i.createElement("div", {
            className: (0, o.Z)(Wt.FrontGradient, 0 === r && Wt.HideGradient),
          }),
          i.createElement("div", {
            className: (0, o.Z)(Wt.EndGradient, a && Wt.HideGradient),
          }),
        );
      }
      function Ut() {
        const [e, t] = (0, i.useState)({
            scrollBarWidth: 0,
            scrollBarXOffset: 0,
          }),
          r = i.useCallback((e) => {
            const r = e.target.getBoundingClientRect();
            t({ scrollBarWidth: r.width, scrollBarXOffset: r.x });
          }, []),
          a = C(),
          s = (0, n.SZ)(
            () => a.GetScrollableWidthPX() + 2 * a.GetTimelineMarginWidth(),
          ),
          l = (0, n.SZ)(() => a.GetVisualWidth()),
          c = (0, i.useMemo)(
            () => (l * e.scrollBarWidth) / s || 0,
            [l, e.scrollBarWidth, s],
          ),
          u = (0, m.yU)(r);
        return i.createElement(
          "div",
          {
            className: (0, o.Z)(
              Wt.ScrollBarCtn,
              Math.round(c) === Math.round(e.scrollBarWidth) &&
                Wt.HideScrollBar,
            ),
            ref: u,
          },
          i.createElement(jt, { timelineView: a, scrollSize: e }),
          i.createElement(Zt, {
            scrollSize: e,
            timelineView: a,
            timelineWidth: s,
            thumbWidth: c,
          }),
        );
      }
      function jt(e) {
        const { timelineView: t, scrollSize: r } = e,
          a = (0, z.we)(),
          o = (function (e, t) {
            const r = (0, i.useRef)(),
              a = (0, i.useRef)(),
              o = (0, n.SZ)(() => e.GetScrollableWidthPX()),
              s = (0, i.useCallback)(
                (e) => (0, f.bu)((o * e) / t.scrollBarWidth),
                [t.scrollBarWidth, o],
              ),
              l = (0, i.useCallback)(() => {
                if (!r.current) return;
                const t = e.GetScrollWindowWidth(),
                  i = e.GetVisualWindowStartPX() + t / 2;
                if (
                  r.current.valPX > i - 0.1 * t &&
                  r.current.valPX < i + 0.1 * t
                )
                  return;
                const n = 0.005 * e.GetScrollableWidthPX(),
                  o = r.current.valPX - i;
                if (Math.abs(o) > n) {
                  const t = o > 0 ? n : -n;
                  e.ScrollToOffsetCentered(i + t),
                    (a.current = requestAnimationFrame(() => l()));
                } else e.ScrollToOffsetCentered(r.current.valPX);
              }, [e]),
              c = (0, i.useCallback)(
                (e) => {
                  (r.current = s(e.clientX - t.scrollBarXOffset)),
                    (a.current = requestAnimationFrame(() => l()));
                },
                [s, l, t.scrollBarXOffset],
              ),
              u = (0, i.useCallback)(() => {
                a.current && cancelAnimationFrame(a.current);
              }, []),
              d = (0, i.useCallback)(
                (e) => {
                  r.current = s(e.clientX - t.scrollBarXOffset);
                },
                [s, t.scrollBarXOffset],
              );
            return (
              (0, i.useEffect)(
                () => () => {
                  a.current && cancelAnimationFrame(a.current);
                },
                [],
              ),
              { onMouseDown: c, onMouseMove: d, onMouseUp: u, onMouseLeave: u }
            );
          })(t, r),
          s = (0, n.SZ)(() => t.GetTimelineMarginWidth()),
          l = (0, n.SZ)(() => t.GetScrollableWidthPX()),
          u = (0, i.useCallback)(
            (e) => {
              const t = e + s;
              return c.Lh((t * r.scrollBarWidth) / l, 0, r.scrollBarWidth);
            },
            [r.scrollBarWidth, s, l],
          );
        return i.createElement(
          "div",
          { className: Wt.ScrollTrack, ...o },
          i.createElement(Ht, {
            timelineView: t,
            playbackCoordinator: a,
            fnConvertGlobalPXToTrackPX: u,
            scrollBarWidth: r.scrollBarWidth,
          }),
          i.createElement(qt, {
            timelineView: t,
            fnConvertGlobalPXToTrackPX: u,
          }),
        );
      }
      function Ht(e) {
        const {
            timelineView: t,
            playbackCoordinator: r,
            fnConvertGlobalPXToTrackPX: a,
            scrollBarWidth: o,
          } = e,
          s = (0, n.SZ)(() => r.GetHidePlayer()),
          l = (0, n.SZ)(() => {
            const e = r.GetGlobalMSPlaytime();
            if (e && t.BInitialized()) {
              const r = Math.floor(t.ConvertGlobalMSToGlobalPXOffset(e.valMS));
              return a(r);
            }
            return null;
          });
        if (!l) return null;
        return i.createElement(
          "div",
          {
            className: Wt.PlayHeadAnnotation,
            onClick: () => {
              let e = r.GetGlobalMSPlaytime();
              s && (e = r.GetLiveEdgeMS()), t.ScrollToCenteredGlobalMS(e.valMS);
            },
            style: { transform: `translateX(${s ? o : l}px)` },
          },
          i.createElement(Vt, null),
        );
      }
      function Vt() {
        return i.createElement(
          "svg",
          {
            width: "52",
            height: "31",
            viewBox: "0 0 52 31",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          i.createElement("path", {
            d: "M26 31L51.1147 0.25H0.885263L26 31Z",
            fill: "#D9D9D9",
          }),
        );
      }
      function qt(e) {
        const { timelineView: t, fnConvertGlobalPXToTrackPX: r } = e,
          a = T(),
          o = b(),
          s = (0, n.SZ)(() => {
            if (a && t.BInitialized()) {
              const e = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(o.nGlobalStartMS.valMS),
                ),
                i = Math.floor(
                  t.ConvertGlobalMSToGlobalPXOffset(o.nGlobalEndMS.valMS),
                );
              return { rangeStartPX: r(e), rangeEndPX: r(i) };
            }
            return null;
          });
        if (!s) return null;
        return i.createElement("div", {
          className: Wt.RangeAnnotation,
          onClick: () => {
            t.ScrollToCenteredGlobalMS(o.nGlobalStartMS.valMS);
          },
          style: {
            width: s.rangeEndPX - s.rangeStartPX,
            transform: `translateX(${s.rangeStartPX}px)`,
          },
        });
      }
      function Zt(e) {
        const {
            scrollSize: t,
            timelineWidth: r,
            thumbWidth: a,
            timelineView: s,
          } = e,
          {
            thumbPositionPX: l,
            onMouseDown: u,
            bHiglightThumb: d,
          } = (function (e, t, r, a) {
            const [o, s] = (0, i.useState)(!1),
              [l, u] = (0, i.useState)(0),
              d = (0, n.SZ)(() => {
                const i = a.BInitialized(),
                  n = a.GetVisualWindowStartPX();
                return i
                  ? c.Lh((n * e.scrollBarWidth) / t, 0, e.scrollBarWidth - r)
                  : 0;
              }),
              [m, f] = (0, i.useState)(!1),
              p = (0, i.useRef)();
            (0, i.useEffect)(() => {
              if (a.GetAutoScrollPaused())
                return (
                  f(!0),
                  (p.current = window.setTimeout(() => {
                    f(!1);
                  }, 500)),
                  () => window.clearTimeout(p.current)
                );
            }, [d, a]);
            const g = (0, i.useCallback)(
                (t) => {
                  u(d), s(!0);
                  const r = t.nativeEvent.offsetX,
                    i = a.GetTimelineParentCtnRef() ?? (0, fe.RA)(t);
                  let n, o, l;
                  const c = (t) => {
                    u(t.clientX - e.scrollBarXOffset - r);
                  };
                  i.addEventListener("mousemove", c),
                    (n = () => i.removeEventListener("mousemove", c));
                  const m = () => {
                    s(!1), n(), o(), l();
                  };
                  i.addEventListener("mouseup", m),
                    i.addEventListener("mouseleave", m),
                    (o = () => i.removeEventListener("mouseup", m)),
                    (l = () => i.removeEventListener("mouseleave", m));
                },
                [d, e.scrollBarXOffset, a],
              ),
              b = (0, i.useMemo)(
                () => (o ? c.Lh(l, 0, e.scrollBarWidth - r) : d),
                [l, o, d, e.scrollBarWidth, r],
              );
            return (
              (0, i.useEffect)(() => {
                if (o) {
                  const r = (t * b) / e.scrollBarWidth;
                  a.ScrollToOffset(r);
                }
              }, [o, e.scrollBarWidth, b, a, t]),
              { thumbPositionPX: b, onMouseDown: g, bHiglightThumb: m }
            );
          })(t, r, a, s);
        return i.createElement("div", {
          className: (0, o.Z)(Wt.ScrollThumb, d && Wt.Highlight),
          style: { width: a, transform: `translateX(${l}px)` },
          onMouseDown: u,
        });
      }
      var Yt = r(15633),
        Jt = r(94996);
      const Kt = 0.85,
        Qt = 0.15;
      function $t(e) {
        const {
            loader: t,
            className: r,
            clipSummaries: s,
            refTimelineParentCtn: l,
            disableZoom: c,
          } = e,
          u = (0, n.SZ)(() => t.BInitialized()),
          d = (0, z.we)();
        u || i.createElement("div", { className: a.LoadingTimeline });
        let m = (0, o.Z)(
          a.ScrollAndControlsCtn,
          d.GetGamepadMode() && a.GamepadMode,
          r,
        );
        return i.createElement(
          w,
          {
            loader: t,
            clipSummaries: s,
            playbackCoordinator: d,
            refTimelineParentCtn: l,
          },
          i.createElement(
            "div",
            { className: m },
            i.createElement(ir, null),
            i.createElement(nr, null),
            i.createElement(
              Jt.Dt,
              {
                tour: "recording_timeline",
                name: "timeline",
                options: { position: "left", offset: 30 },
              },
              i.createElement(
                kt,
                { className: a.TimelineScrollContainer, disableZoom: c },
                i.createElement(er, null),
              ),
            ),
          ),
        );
      }
      const er = (0, i.memo)(function (e) {
        const t = C();
        return (0, n.SZ)(() => t.BInitialized())
          ? i.createElement(tr, null)
          : null;
      });
      function tr() {
        const e = C(),
          t = (0, n.SZ)(() => e.GetScrollableWidthPX()),
          r = (0, n.SZ)(() => e.GetVisualWindowStartPX()),
          o = (0, n.SZ)(() => e.GetTimelineMarginWidth());
        return i.createElement(
          "div",
          {
            className: a.ContentContainer,
            style: {
              minWidth: t || 0,
              marginRight: o,
              marginLeft: o,
              transform: `translateX(${-r}px)`,
            },
          },
          i.createElement(
            rr,
            { id: "recordings", className: a.RecordingDecorators },
            i.createElement(Dt, null),
          ),
          i.createElement(
            rr,
            { id: "clips", className: a.ClipDecorators },
            i.createElement(xt, null),
          ),
          i.createElement(
            rr,
            { id: "game_modes", className: a.GameModes },
            i.createElement(Ue, null),
          ),
          i.createElement(
            rr,
            { id: "date_decorators", className: a.DateDecorator },
            i.createElement(Ct, null),
          ),
          i.createElement(
            rr,
            { id: "ticks", className: a.BackgroundTicks },
            i.createElement(I, null),
          ),
          i.createElement(
            Se,
            null,
            i.createElement(
              rr,
              { id: "highlights", className: a.Highlights },
              i.createElement(Ae, null),
            ),
            i.createElement(
              rr,
              { id: "range_selection", className: a.RangeSelector },
              i.createElement(bt, null),
            ),
            i.createElement(
              rr,
              { id: "seek_scrub", className: a.SeekScrubber },
              i.createElement(ut, null),
            ),
            i.createElement(
              rr,
              { id: "play_head", className: a.PlayHead },
              i.createElement(tt, null),
            ),
          ),
        );
      }
      function rr(e) {
        const { children: t, id: r, className: n } = e;
        return i.createElement(
          "div",
          { id: r, className: (0, o.Z)(n, a.AbsoluteLayer) },
          i.createElement("div", { className: a.RelativeLayer }, t),
        );
      }
      function ir(e) {
        const t = (0, z.we)().GetRenderGlyph();
        return t ? t(Yt.eV.TRIGGER_LEFT, !1, !1, a.PositionLeft) : null;
      }
      function nr(e) {
        const t = (0, z.we)().GetRenderGlyph();
        return t ? t(Yt.eV.TRIGGER_RIGHT, !1, !1, a.PositionRight) : null;
      }
    },
    60108: (e, t, r) => {
      "use strict";
      function i() {
        return [
          {
            timeline_id: "mocktimeline_1",
            game_id: "clip_1",
            date_recorded: 1713811258,
            duration_ms: "60000",
            recordings: [
              {
                recording_id: "recording_1",
                duration_ms: "15000",
                start_offset_ms: "5000",
              },
              {
                recording_id: "recording_2",
                duration_ms: "15000",
                start_offset_ms: "25000",
              },
              {
                recording_id: "recording_3",
                duration_ms: "15000",
                start_offset_ms: "45000",
              },
            ],
          },
        ];
      }
      r.d(t, { E: () => i });
    },
    93882: (e, t, r) => {
      "use strict";
      r.d(t, { Ms: () => _, Or: () => v });
      var i = r(85556),
        n = r(80751),
        a = r.n(n),
        o = r(77185),
        s = r(87225),
        l = r(12015),
        c = r(74666),
        u = r(46984),
        d = r(45492),
        m = r(16997),
        f = r(40420),
        p = (r(47427), r(54842)),
        g = r(37796),
        b = r(45944),
        h = r(20020);
      const _ = 3e3,
        S = _ + 1e3;
      class v {
        constructor() {
          (0, p.rC)(this);
        }
        m_bInitialized = !1;
        m_rgListeners = [];
        m_gameID;
        m_clipID;
        m_ulFirstTimelineOffsetMS = 0;
        m_rgTimelineMetadata = [];
        m_mapTimelineData = new Map();
        m_mapRunningTimelines = new Map();
        m_schUpdateRunning = new d.Ar();
        m_fnTimelineURLBuilder;
        BInitialized() {
          return this.m_bInitialized;
        }
        GetTimelines() {
          return this.m_rgTimelineMetadata;
        }
        GetTimelineMetadataIndex(e) {
          return this.m_rgTimelineMetadata.findIndex(
            (t) => t.metadata.timeline_id === e,
          );
        }
        GetTimelineMetadata(e) {
          return this.m_rgTimelineMetadata.find(
            (t) => t.metadata.timeline_id === e,
          );
        }
        GetGameID() {
          return this.m_gameID;
        }
        GetClipID() {
          return this.m_clipID;
        }
        BIsTimelineRunning(e) {
          return this.m_mapRunningTimelines.has(e);
        }
        AddEventListener(e) {
          return this.m_rgListeners.push(e), () => s.Zf(this.m_rgListeners, e);
        }
        async LoadTimelinesForGame(e) {
          this.m_gameID = e;
          const t = await o.Up.GetTimelinesForApp({ game_id: e }),
            { timelines: r = [] } = t.Body().toObject();
          this.m_mapRunningTimelines.forEach((e, t) => {
            r.find((e) => e.timeline_id == t) || r.push(e.m_metadata);
          }),
            this.UpdateTimelineMetadata(r),
            (this.m_fnTimelineURLBuilder = (e) =>
              `https://steamloopback.host/gamerecordings/timelines/${e}.json`),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        async LoadTimelinesForClip(e) {
          this.m_clipID = e;
          const t = await o.Up.GetTimelinesForClip({ clip_id: e });
          if (1 != t.GetEResult()) throw new Error("Unable to load clip " + e);
          const {
            timelines: r = [],
            game_id: i,
            first_timeline_start_offset_ms: n,
          } = t.Body().toObject();
          (this.m_gameID = i), this.UpdateTimelineMetadata(r);
          for (let t of this.m_rgTimelineMetadata) {
            (0, l.hB)(`Loaded clip ${e} timeline ${t.metadata.timeline_id}`);
            for (let e of t.metadata.recordings)
              (0, l.hB)(
                `Clip recording ${e.recording_id} duration ${e.duration_ms}`,
              );
          }
          (this.m_ulFirstTimelineOffsetMS = parseInt(n)),
            (this.m_fnTimelineURLBuilder = (e) =>
              `https://steamloopback.host/gamerecordings/clips/${this.m_clipID}/timelines/${e}.json`),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        UpdateTimelineMetadata(e) {
          const t = e.slice().sort((e, t) => e.date_recorded - t.date_recorded);
          let r = [],
            i = 0;
          const n = {};
          t.forEach((t) => {
            t.recordings || (t.recordings = []),
              n[t.timeline_id]
                ? console.error(
                    "Duplicate timelines found in UpdateTimelineMetadata()",
                    t.timeline_id,
                    e,
                  )
                : (r.push({ nGlobalOffsetMS: (0, f.Z6)(i), metadata: t }),
                  (i += parseInt(t.duration_ms)),
                  (n[t.timeline_id] = !0));
          }),
            (this.m_rgTimelineMetadata = r);
        }
        LoadTimelinesForSharedClip(e) {
          this.SetPreloadedTimelines(
            0,
            e.clip_id,
            e.game_id,
            e.timelines,
            void 0,
          );
        }
        LoadTimelinesForTestGame(e, t) {
          this.SetPreloadedTimelines(
            0,
            void 0,
            e,
            t,
            (e) =>
              `https://steamloopback.host/gamerecordings/timelines/${e}.json`,
          );
        }
        LoadTimelinesForTestClip(e, t, r, i) {
          this.SetPreloadedTimelines(e, t, r, i, void 0);
        }
        SetPreloadedTimelines(e, t, r, i, n) {
          (this.m_gameID = r),
            (this.m_clipID = t),
            (this.m_ulFirstTimelineOffsetMS = e);
          const a = i.slice();
          this.m_mapRunningTimelines.forEach((e, t) => {
            a.find((e) => e.timeline_id == t) || a.push(e.m_metadata);
          }),
            this.UpdateTimelineMetadata(a),
            (this.m_fnTimelineURLBuilder = n),
            (this.m_bInitialized = !0),
            this.FireEvent("OnLoaderInitialized");
        }
        FireEvent(e, ...t) {
          for (let r of this.m_rgListeners) {
            let i = r[e];
            i instanceof Function && i.apply(r, t);
          }
        }
        async LoadTimelineData(e) {
          let t = this.m_mapTimelineData.get(e);
          if (t && ("loading" == t.m_strState || "error" == t.m_strState))
            return;
          if (this.IsActiveTimeline(e) && "loaded" == t.m_strState) return;
          const r = {
            m_strState: this.m_fnTimelineURLBuilder ? "loading" : "loaded",
            m_rgGameModeChanges: [],
            m_rgStateDescriptions: [],
            m_rgEntries: [],
          };
          this.m_mapTimelineData.set(e, r);
          try {
            if (this.m_fnTimelineURLBuilder) {
              const t = this.m_fnTimelineURLBuilder(e),
                i = await a().get(t, { withCredentials: !1 });
              if (200 == i.status && i.data) {
                const t = this.ProcessTimelineEntries(i.data);
                this.m_mapTimelineData.set(e, t);
              } else
                this.m_mapTimelineData.set(e, { ...r, m_strState: "error" });
            }
          } catch (t) {
            this.m_mapTimelineData.set(e, { ...r, m_strState: "error" });
          }
          this.FireEvent("OnTimelineLoaded", e);
        }
        ProcessTimelineEntries(e) {
          let t = {
            m_strState: "loaded",
            m_rgGameModeChanges: [],
            m_rgStateDescriptions: [],
            m_rgEntries: [],
          };
          if (e.entries) {
            let r = e.entries.filter((e) => (0, c.ED)(e));
            t.m_rgGameModeChanges = r.sort(
              (e, t) => parseInt(e.time) - parseInt(t.time),
            );
            let i = e.entries.filter((e) => (0, c.PA)(e));
            t.m_rgStateDescriptions = i.sort(
              (e, t) => parseInt(e.time) - parseInt(t.time),
            );
            let n = e.entries.filter(
              (e) =>
                (0, c.tm)(e) ||
                (0, c.m6)(e) ||
                (0, c.ph)(e) ||
                (0, c.l8)(e) ||
                (0, c.CR)(e),
            );
            (t.m_rgEntries = n.sort(
              (e, t) => parseInt(e.time) - parseInt(t.time),
            )),
              t.m_rgGameModeChanges.length > 0 &&
                parseInt(t.m_rgGameModeChanges[0].time) < 1e4 &&
                (t.m_rgGameModeChanges[0].time = "0");
          }
          return t;
        }
        static ApplyTimelineRounding(e, t) {
          if (0 === t) return e;
          const r = e % t;
          return 0 == r ? e : e + (t - r);
        }
        FindTimelineAtOffset(e, t) {
          const r = e + this.m_ulFirstTimelineOffsetMS;
          let i = 0;
          for (let e of this.m_rgTimelineMetadata) {
            const n = this.GetTimelineStartBeforeGlobalZeroMS(
              e.metadata.timeline_id,
            );
            let a = parseInt(e.metadata.duration_ms) + n;
            if (i + a > r)
              return {
                timeline: e,
                nTimelineOffsetMS: r - i,
                ulGlobalToTimelineOffset: n,
              };
            i += v.ApplyTimelineRounding(a, t);
          }
          return null;
        }
        GetGlobalOffsetDataForTimeline(e, t) {
          let r = 0;
          for (let i of this.m_rgTimelineMetadata) {
            let n = parseInt(i.metadata.duration_ms),
              a = v.ApplyTimelineRounding(n, t);
            if (i.metadata.timeline_id == e)
              return { nGlobalOffsetMS: r, nRoundedDurationMS: a };
            r += a;
          }
          return null;
        }
        CreateGlobalRangeForTimeline(e, t, r, i) {
          let n = t - r,
            a = t + i;
          return this.ClampGlobalRangeToTimeline(e, n, a);
        }
        ClampGlobalRangeToTimeline(e, t, r) {
          let i = this.GetGlobalOffsetDataForTimeline(e, 0);
          return i
            ? [
                Math.max(t, i.nGlobalOffsetMS),
                Math.min(r, i.nGlobalOffsetMS + i.nRoundedDurationMS - 1),
              ]
            : [0, 0];
        }
        GetTimelineOffsetFromGlobal(e, t) {
          const r = this.m_ulFirstTimelineOffsetMS + e;
          let i = 0;
          for (let e of this.m_rgTimelineMetadata) {
            const n = this.GetTimelineStartBeforeGlobalZeroMS(
                e.metadata.timeline_id,
              ),
              a = parseInt(e.metadata.duration_ms) + n;
            if (r < i + v.ApplyTimelineRounding(a, t))
              return {
                strTimelineID: e.metadata.timeline_id,
                nTimelineOffsetMS: (0, f.pX)(r - i - n),
              };
            i += a;
          }
          return { strTimelineID: void 0, nTimelineOffsetMS: (0, f.pX)(NaN) };
        }
        ConvertRecordingOffsetToGlobalOffset(e, t, r) {
          let i = 0;
          for (let n of this.m_rgTimelineMetadata) {
            let a = parseInt(n.metadata.duration_ms);
            const o = this.GetTimelineStartBeforeGlobalZeroMS(
              n.metadata.timeline_id,
            );
            let s = v.ApplyTimelineRounding(a, r);
            for (let r of n.metadata.recordings)
              if (r.recording_id === e) {
                let e =
                  (isNaN(parseInt(r.recording_zero_timeline_offset_ms))
                    ? 0
                    : parseInt(r.recording_zero_timeline_offset_ms) - o) + t;
                return (
                  (i += e),
                  {
                    nGlobalOffsetMS: i,
                    nRoundedDurationMS: s,
                    strTimelineID: n.metadata.timeline_id,
                    nTimelineOffsetMS: e,
                  }
                );
              }
            i += s;
          }
          return null;
        }
        IsActiveTimeline(e) {
          return !!e && this.m_mapRunningTimelines.has(e);
        }
        IsActiveRecording(e) {
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings)
              if (r.recording_id === e) {
                const r = this.m_mapRunningTimelines.get(
                  t.metadata.timeline_id,
                );
                return (
                  !(!r || !r.m_runningRecording) &&
                  r.m_runningRecording.recording_id === e
                );
              }
          return !1;
        }
        GetRunningTimelineDurationMS(e) {
          let t = this.m_mapRunningTimelines.get(e);
          if (!t) return 0;
          let r =
              performance.now() -
              t.m_perfCounterStart +
              t.m_nPerfCounterOffsetMS,
            i = parseInt(t.m_metadata.duration_ms) || 0;
          return Math.max(r, i);
        }
        GetRunningTimelineForRecording(e, t) {
          const r = this.m_mapRunningTimelines.get(e);
          return r &&
            r.m_runningRecording &&
            r.m_runningRecording.recording_id === t
            ? r
            : null;
        }
        ConvertGlobaOffsetToRecordingAndRelativeOffset(e) {
          if (!this.m_bInitialized) return null;
          let t = this.FindTimelineAtOffset(e, 0);
          if (!t) return null;
          let r = t.nTimelineOffsetMS - t.ulGlobalToTimelineOffset;
          for (let e of t.timeline.metadata.recordings) {
            let i = parseInt(e.start_offset_ms);
            if (i + parseInt(e.duration_ms) < r || i > r) continue;
            let n = parseInt(e.recording_zero_timeline_offset_ms),
              a = Math.max(r - i, 0);
            return (
              isNaN(n) || (a = Math.max(t.nTimelineOffsetMS - n, 0)),
              {
                strRecordingID: e.recording_id,
                nRecordingOffsetMS: a,
                nStartOffsetMS: i,
              }
            );
          }
          return null;
        }
        GetClosestNextRecordingInGlobalTimeline(e) {
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings) {
              if (
                parseInt(r.start_offset_ms) + t.nGlobalOffsetMS.valMS >
                e.valMS
              )
                return r;
            }
          return null;
        }
        GetClosestPreviousRecordingInGlobalTimeline(e) {
          let t = null;
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings) {
              if (
                parseInt(i.start_offset_ms) + r.nGlobalOffsetMS.valMS >
                e.valMS
              )
                return t;
              t = i;
            }
          return t;
        }
        ConvertRecordingTimeMStoPreTrimTimeMS(e, t) {
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings)
              if (i.recording_id === e) {
                const e = parseInt(i.recording_zero_timeline_offset_ms),
                  n = this.GetTimelineStartBeforeGlobalZeroMS(
                    r.metadata.timeline_id,
                  );
                return !n || isNaN(e) ? t : t + n - e;
              }
          return t;
        }
        GetTimelineDataOrStartLoad(e) {
          let t = this.m_mapTimelineData.get(e);
          return (
            t ||
              (this.LoadTimelineData(e), (t = this.m_mapTimelineData.get(e))),
            t
          );
        }
        GetTimelineData(e) {
          return this.m_mapTimelineData.get(e);
        }
        SetTimelineData(e, t) {
          const r = this.ProcessTimelineEntries(t);
          this.m_mapTimelineData.set(e, r);
        }
        GetClosestPreviousEntryInTimeline(e, t) {
          const r = this.GetTimelineMetadata(e),
            i = this.GetTimelineStartBeforeGlobalZeroMS(e),
            n = this.GetTimelineDataOrStartLoad(e);
          let a = null;
          if ("loaded" === n.m_strState) {
            const e = n.m_rgEntries.filter((e) => {
                const t = parseInt(e.time);
                return t < i + parseInt(r.metadata.duration_ms) && t > i;
              }),
              o = s.sL(e, (e) => t.valMS - 1 - parseInt(e.time));
            -1 !== o && (a = e[o]);
          }
          return { entry: a, timelineState: n.m_strState };
        }
        GetClosestNextEntryInTimeline(e, t) {
          const r = this.GetTimelineMetadata(e),
            i = this.GetTimelineStartBeforeGlobalZeroMS(e),
            n = this.GetTimelineDataOrStartLoad(e);
          let a = null;
          if ("loaded" === n.m_strState) {
            const e = n.m_rgEntries.filter((e) => {
                const t = parseInt(e.time);
                return t < i + parseInt(r.metadata.duration_ms) && t > i;
              }),
              o = s.sL(e, (e) => t.valMS - parseInt(e.time));
            o < e.length - 1 && (a = e[o + 1]);
          }
          return { entry: a, timelineState: n.m_strState };
        }
        GetClosestPreviousEntryInGlobalTimeline(e) {
          const t = this.GetTimelineOffsetFromGlobal(e, 0),
            r = this.GetTimelineData(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState)
            return {
              timelineID: t?.strTimelineID,
              timelineState: r?.m_strState,
              entry: null,
              globalMS: null,
            };
          const i = this.GetTimelineStartBeforeGlobalZeroMS(t.strTimelineID),
            n = t.nTimelineOffsetMS.valMS + i,
            a = s.sL(r.m_rgEntries, (e) => n - parseInt(e.time));
          if (-1 !== a) {
            const e = r.m_rgEntries[a],
              n =
                this.GetTimelineMetadata(t.strTimelineID).nGlobalOffsetMS
                  .valMS -
                i +
                parseInt(e.time);
            return n < 0
              ? {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                }
              : {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: e,
                  globalMS: (0, f.Z6)(n),
                };
          }
          let o = this.GetTimelineMetadataIndex(t.strTimelineID);
          if (o < 1)
            return {
              timelineID: t.strTimelineID,
              timelineState: r.m_strState,
              entry: null,
              globalMS: null,
            };
          for (let e = o - 1; e >= 0; e--) {
            const t = this.m_rgTimelineMetadata[e],
              r = this.GetTimelineData(t.metadata.timeline_id);
            if (r) {
              if ("loaded" !== r.m_strState)
                return {
                  timelineID: t.metadata.timeline_id,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
              if (r.m_rgEntries.length) {
                const e = r.m_rgEntries[r.m_rgEntries.length - 1],
                  i = this.GetTimelineStartBeforeGlobalZeroMS(
                    t.metadata.timeline_id,
                  ),
                  n = t.nGlobalOffsetMS.valMS - i + parseInt(e.time);
                return n < 0
                  ? {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: null,
                      globalMS: null,
                    }
                  : {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: e,
                      globalMS: (0, f.Z6)(n),
                    };
              }
            }
          }
          return {
            timelineID: this.m_rgTimelineMetadata[0].metadata.timeline_id,
            timelineState: "loaded",
            entry: null,
            globalMS: null,
          };
        }
        GetClosestNextEntryInGlobalTimeline(e) {
          const t = this.GetTimelineOffsetFromGlobal(e, 0),
            r = this.GetTimelineData(t.strTimelineID);
          if (!r || "loaded" !== r.m_strState)
            return {
              timelineID: t?.strTimelineID,
              timelineState: r?.m_strState,
              entry: null,
              globalMS: null,
            };
          const i = this.GetTimelineStartBeforeGlobalZeroMS(t.strTimelineID),
            n = t.nTimelineOffsetMS.valMS + i,
            a = s.sL(r.m_rgEntries, (e) => n - parseInt(e.time)) + 1;
          if (a <= r.m_rgEntries.length - 1) {
            const e = r.m_rgEntries[a],
              n =
                this.GetTimelineMetadata(t.strTimelineID).nGlobalOffsetMS
                  .valMS -
                i +
                parseInt(e.time);
            return n < this.GetGlobalTimelineEndMS().valMS
              ? {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: e,
                  globalMS: (0, f.Z6)(n),
                }
              : {
                  timelineID: t.strTimelineID,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
          }
          const o = this.m_rgTimelineMetadata.length;
          let l = this.GetTimelineMetadataIndex(t.strTimelineID);
          if (-1 === l || l === o - 1)
            return {
              timelineID: t.strTimelineID,
              timelineState: r.m_strState,
              entry: null,
              globalMS: null,
            };
          for (let e = l + 1; e < o; e++) {
            const t = this.m_rgTimelineMetadata[e],
              r = this.GetTimelineData(t.metadata.timeline_id);
            if (r) {
              if ("loaded" !== r.m_strState)
                return {
                  timelineID: t.metadata.timeline_id,
                  timelineState: r.m_strState,
                  entry: null,
                  globalMS: null,
                };
              if (r.m_rgEntries.length) {
                const e = r.m_rgEntries[0],
                  i = this.GetTimelineStartBeforeGlobalZeroMS(
                    t.metadata.timeline_id,
                  ),
                  n = t.nGlobalOffsetMS.valMS - i + parseInt(e.time);
                return n < this.GetGlobalTimelineEndMS().valMS
                  ? {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: e,
                      globalMS: (0, f.Z6)(n),
                    }
                  : {
                      timelineID: t.metadata.timeline_id,
                      timelineState: r.m_strState,
                      entry: null,
                      globalMS: null,
                    };
              }
            }
          }
          return {
            timelineID: this.m_rgTimelineMetadata[o - 1].metadata.timeline_id,
            timelineState: "loaded",
            entry: null,
            globalMS: null,
          };
        }
        GetStateDescriptionAtGlobalMS(e) {
          const t = this.GetTimelineOffsetFromGlobal(e.valMS, 0),
            r = this.GetTimelineDataOrStartLoad(t.strTimelineID);
          if ("loaded" !== r.m_strState) return null;
          const i = s.sL(
            r.m_rgStateDescriptions,
            (e) => t.nTimelineOffsetMS.valMS - parseInt(e.time),
          );
          return i > -1 ? r.m_rgStateDescriptions[i] : null;
        }
        AdvanceGameModeIndex(e) {
          let t = e.m_iGameModeChanges;
          for (; t + 1 < e.m_data.m_rgGameModeChanges.length; ) {
            let r = e.m_data.m_rgGameModeChanges[t + 1];
            if (parseInt(r.time) > e.m_nTimelineOffsetMS) break;
            t++;
          }
          e.m_iGameModeChanges = t;
        }
        AdvanceEntriesIndex(e) {
          for (
            -1 == e.m_iEntries && e.m_iEntries++;
            e.m_iEntries < e.m_data.m_rgEntries.length;

          ) {
            let t = e.m_data.m_rgEntries[e.m_iEntries];
            if (parseInt(t.time) >= e.m_nTimelineOffsetMS) break;
            e.m_iEntries++;
          }
        }
        CreateTimelineIterator(e, t) {
          let r = this.FindTimelineAtOffset(e, t);
          if (!r)
            return {
              m_timeline: null,
              m_data: null,
              m_nTimelineOffsetMS: 0,
              m_iGameModeChanges: -1,
              m_iEntries: -1,
            };
          let i = this.GetTimelineDataOrStartLoad(
              r.timeline.metadata.timeline_id,
            ),
            n = -1,
            a = -1;
          if ("loaded" == i.m_strState) {
            let e = (e) => r.ulGlobalToTimelineOffset - parseInt(e.time);
            (n = s.sL(i.m_rgGameModeChanges, e)), (a = s.sL(i.m_rgEntries, e));
          }
          let o = {
            m_timeline: r.timeline.metadata,
            m_data: i,
            m_nTimelineOffsetMS: Math.max(r.ulGlobalToTimelineOffset, 0),
            m_iGameModeChanges: n,
            m_iEntries: a,
          };
          return this.AdvanceEntriesIndex(o), this.AdvanceGameModeIndex(o), o;
        }
        HasIteratorReachedEnd(e) {
          return !e.m_timeline;
        }
        AdvanceIterator(e, t) {
          let r = parseInt(e.m_timeline.duration_ms);
          if (e.m_nTimelineOffsetMS + t < r + this.m_ulFirstTimelineOffsetMS)
            return (
              (e.m_nTimelineOffsetMS += t),
              this.AdvanceEntriesIndex(e),
              void this.AdvanceGameModeIndex(e)
            );
          let i = this.m_rgTimelineMetadata.findIndex(
            (t) => t.metadata == e.m_timeline,
          );
          i < 0 || i == this.m_rgTimelineMetadata.length - 1
            ? (e.m_timeline = null)
            : (i++,
              (e.m_timeline = this.m_rgTimelineMetadata[i].metadata),
              (e.m_data = this.GetTimelineDataOrStartLoad(
                e.m_timeline.timeline_id,
              )),
              (e.m_nTimelineOffsetMS = 0),
              (e.m_iGameModeChanges = 0),
              (e.m_iEntries = 0));
        }
        GetIteratorTimelineState(e) {
          return e.m_data.m_strState;
        }
        GetIteratorGameMode(e) {
          return e.m_iGameModeChanges < 0 ||
            e.m_iGameModeChanges >= e.m_data.m_rgGameModeChanges.length
            ? c.Ml.Playing
            : e.m_data.m_rgGameModeChanges[e.m_iGameModeChanges].mode;
        }
        *GetIteratorEntriesWithin(e, t) {
          let r = e.m_data.m_rgEntries;
          for (let i = e.m_iEntries; i >= 0 && i < r.length; i++) {
            let n = r[i];
            if (parseInt(n.time) >= e.m_nTimelineOffsetMS + t) break;
            yield n;
          }
        }
        *GetIteratorGameModesWithin(e, t) {
          let r = e.m_data.m_rgGameModeChanges;
          for (let i = e.m_iEntries; i >= 0 && i < r.length; i++) {
            let n = r[i];
            if (parseInt(n.time) >= e.m_nTimelineOffsetMS + t) break;
            yield n;
          }
        }
        GetFirstRecording() {
          if (!this.m_bInitialized) return "";
          const e = this.m_rgTimelineMetadata[0];
          if (!e) return "";
          const t = e.metadata.recordings[0];
          return t ? t.recording_id : "";
        }
        GetFirstRecordingOfLastTimelineSession() {
          if (!this.m_bInitialized) return "";
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (!e) return "";
          const t = e.metadata.recordings[0];
          return t ? t.recording_id : "";
        }
        GetNextRecording(e) {
          if (!this.m_bInitialized || !e) return "";
          let t = !1;
          for (let r of this.m_rgTimelineMetadata)
            for (let i of r.metadata.recordings) {
              if (t) return i.recording_id;
              i.recording_id == e && (t = !0);
            }
          return "";
        }
        BRecordingHasZeroOffset(e) {
          if (!this.m_bInitialized) return !1;
          for (let t of this.m_rgTimelineMetadata)
            for (let r of t.metadata.recordings)
              if (r.recording_id == e)
                return !isNaN(parseInt(r.recording_zero_timeline_offset_ms));
          return !1;
        }
        GetTimelineDateMS(e, t) {
          if (!this.m_bInitialized) return 0;
          let r = this.FindTimelineAtOffset(e, t);
          return r
            ? 1e3 * r.timeline.metadata.date_recorded + r.nTimelineOffsetMS
            : 0;
        }
        InsertEntryIntoTimelineSorted(e, t) {
          s.DG(e.m_rgEntries, t, (e, t) => parseInt(e.time) - parseInt(t.time));
        }
        AddEventToTimeline(e, t, r, i, n, a, o, s) {
          if (!this.m_bInitialized)
            return (0, l.F0)("timeline loader not initialized, unexpected"), !1;
          const c = this.m_mapTimelineData.get(e);
          if (!c) return (0, l.F0)(`failed to find timeline ${e}`), !1;
          const u = t + this.GetTimelineStartBeforeGlobalZeroMS(e),
            d = {
              id: i,
              time: u + "",
              type: "event",
              icon: r,
              title: a,
              description: o,
              priority: n,
              duration: `${s}`,
              possible_clip: 2,
            };
          return (
            (0, l.Zb)(`adding timeline event marker at ${e} at ${u} MS`),
            this.InsertEntryIntoTimelineSorted(c, d),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        RemoveTimelineEvent(e, t) {
          if (!this.m_bInitialized)
            return (0, l.F0)("timeline loader not initialized, unexpected"), !1;
          const r = this.m_mapTimelineData.get(e);
          if (!r) return (0, l.F0)(`failed to find timeline ${e}`), !1;
          const i = r.m_rgEntries.findIndex((e) => e.id === t);
          return i < 0
            ? ((0, l.F0)(`failed to find entry by id: ${t}`), !1)
            : (r.m_rgEntries.splice(i, 1),
              this.FireEvent("OnInvalidate", e),
              !0);
        }
        AddUserMarker(e, t, r, i) {
          if (!this.m_bInitialized)
            return (0, l.F0)("timeline loader not initialized, unexpected"), !1;
          const n = this.m_mapTimelineData.get(e);
          if (!n) return (0, l.F0)(`failed to find timeline ${e}`), !1;
          const a = t + this.GetTimelineStartBeforeGlobalZeroMS(e),
            o = {
              id: i,
              time: a + "",
              type: "usermarker",
              icon: r,
              title: "",
              description: "",
              priority: 0,
            };
          return (
            (0, l.Zb)(`adding user marker at ${e} at ${a} MS`),
            this.InsertEntryIntoTimelineSorted(n, o),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        UpdateUserMarker(e, t, r) {
          if (!this.m_bInitialized)
            return (0, l.F0)("timeline loader not initialized, unexpected"), !1;
          const i = this.m_mapTimelineData.get(e);
          if (!i) return (0, l.F0)(`failed to find timeline ${e}`), !1;
          const n = i.m_rgEntries.findIndex((e) => e.id === t);
          if (n < 0) return (0, l.F0)(`failed to find entry by id: ${t}`), !1;
          const a = i.m_rgEntries[n],
            o = a.time;
          return (
            (a.icon = r.strIcon),
            (a.time = "" + r.nTimelineOffsetMS),
            (a.title = r.name),
            (a.description = r.description),
            o != a.time &&
              (i.m_rgEntries.splice(n, 1),
              this.InsertEntryIntoTimelineSorted(i, a)),
            this.FireEvent("OnInvalidate", e),
            !0
          );
        }
        RemoveUserMarker(e, t) {
          if (!this.m_bInitialized)
            return (0, l.F0)("timeline loader not initialized, unexpected"), !1;
          const r = this.m_mapTimelineData.get(e);
          if (!r) return (0, l.F0)(`failed to find timeline ${e}`), !1;
          const i = r.m_rgEntries.findIndex((e) => e.id === t);
          return i < 0
            ? ((0, l.F0)(`failed to find entry by id: ${t}`), !1)
            : (r.m_rgEntries.splice(i, 1),
              this.FireEvent("OnInvalidate", e),
              !0);
        }
        AddRunningTimeline(e, t, r) {
          if (
            this.m_rgTimelineMetadata.find((t) => t.metadata.timeline_id == e)
          )
            return;
          const i = {
              timeline_id: e,
              game_id: t,
              date_recorded: r,
              recordings: [],
            },
            n = this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1],
            a = n
              ? n.nGlobalOffsetMS.valMS + parseInt(n.metadata.duration_ms)
              : 0;
          s.DG(
            this.m_rgTimelineMetadata,
            { nGlobalOffsetMS: (0, f.Z6)(a), metadata: i },
            (e, t) => e.metadata.date_recorded - t.metadata.date_recorded,
          ),
            this.m_mapTimelineData.set(e, {
              m_strState: "loaded",
              m_rgGameModeChanges: [],
              m_rgStateDescriptions: [],
              m_rgEntries: [],
            });
          let o = {
            m_metadata: i,
            m_globalStartMS: a,
            m_perfCounterStart: performance.now(),
            m_nPerfCounterOffsetMS: 1e3 * Math.max(0, (0, u.QU)() - r),
            m_runningRecording: null,
          };
          this.m_mapRunningTimelines.set(e, o),
            this.m_schUpdateRunning.IsScheduled() ||
              this.m_schUpdateRunning.Schedule(S, this.UpdateRunningTimelines),
            this.FireEvent("OnInvalidate", e);
        }
        UpdateRunningTimelines() {
          let e;
          this.m_mapRunningTimelines.forEach((t) => {
            e = t.m_metadata.timeline_id;
            let r =
              performance.now() -
              t.m_perfCounterStart +
              t.m_nPerfCounterOffsetMS;
            r > (parseInt(t.m_metadata.duration_ms) || 0) &&
              (t.m_metadata.duration_ms = r.toString());
          }),
            this.m_mapRunningTimelines.size > 0 &&
              this.m_schUpdateRunning.Schedule(S, this.UpdateRunningTimelines),
            this.FireEvent("OnInvalidate", e);
        }
        RunningTimelineStopped(e, t) {
          let r = this.m_mapRunningTimelines.get(e);
          r &&
            ((r.m_metadata.duration_ms = t),
            this.m_mapRunningTimelines.delete(e),
            this.FireEvent("OnInvalidate", e));
        }
        AddRunningTimelineEntry(e) {
          let t = this.m_mapRunningTimelines.get(e.timeline_id),
            r = this.m_mapTimelineData.get(e.timeline_id);
          if (!t || !r) return;
          let i = (0, c.XD)(e);
          if (!i) return;
          (0, c.ED)(i)
            ? s.DG(
                r.m_rgGameModeChanges,
                i,
                (e, t) => parseInt(e.time) - parseInt(t.time),
              )
            : (0, c.PA)(i)
              ? s.DG(
                  r.m_rgStateDescriptions,
                  i,
                  (e, t) => parseInt(e.time) - parseInt(t.time),
                )
              : s.DG(
                  r.m_rgEntries,
                  i,
                  (e, t) => parseInt(e.time) - parseInt(t.time),
                );
          let n = parseInt(t.m_metadata.duration_ms) || 0,
            a = parseInt(e.time);
          n < a && (t.m_metadata.duration_ms = a.toString()),
            this.FireEvent("OnInvalidate", e.timeline_id);
        }
        TimelineDeleted(e) {
          const t = this.m_rgTimelineMetadata
            .filter((t) => t.metadata.timeline_id !== e)
            .map((e) => e.metadata);
          this.UpdateTimelineMetadata(t),
            this.m_mapTimelineData.delete(e),
            this.FireEvent("OnInvalidate", e);
        }
        RecordingSessionChanged(e) {
          let t = e.session_id,
            r = e.notification_type;
          if (1 == r) {
            const r = this.m_mapRunningTimelines.get(e.timeline_id);
            if (!r)
              return (
                this.FireEvent("OnInvalidateRecording", e.timeline_id, t),
                void (0, h.X)(
                  !1,
                  "Received recording started message before timeline info",
                )
              );
            const i = {
              recording_id: t,
              start_offset_ms: e.start_offset,
              recording_zero_timeline_offset_ms: e.start_offset,
              duration_ms: e.duration_ms,
              recording_type: e.recording_type,
            };
            r.m_metadata.recordings.push(i), (r.m_runningRecording = i);
          } else if (2 == r) {
            const r = this.GetRunningTimelineForRecording(e.timeline_id, t);
            if (!r) return;
            (r.m_runningRecording.duration_ms = e.duration_ms),
              (r.m_runningRecording = null),
              this.FireEvent("OnInvalidateRecording", e.timeline_id, t);
          } else if (4 == r) {
            const r = this.GetTimelineMetadata(e.timeline_id);
            if (r) {
              const i = r.metadata.recordings.find((e) => e.recording_id === t);
              i &&
                ((i.start_offset_ms = e.start_offset),
                (i.duration_ms = e.duration_ms));
            }
            this.GetRunningTimelineForRecording(e.timeline_id, t) ||
              this.FireEvent("OnInvalidateRecording", e.timeline_id, t);
          } else if (3 == r) {
            const r = this.GetTimelineMetadata(e.timeline_id);
            if (r) {
              const e = r.metadata.recordings.filter(
                (e) => e.recording_id !== t,
              );
              r.metadata.recordings = e;
            }
          }
          this.FireEvent("OnInvalidate", e.timeline_id);
        }
        GetGlobalTimelineEndMS() {
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (e) {
            const t = isNaN(parseInt(e.metadata.duration_ms))
              ? 0
              : parseInt(e.metadata.duration_ms);
            return (0, f.Z6)(e.nGlobalOffsetMS.valMS + t);
          }
          return (0, f.Z6)(0);
        }
        GetEndOfRecordingsMS() {
          const e =
            this.m_rgTimelineMetadata[this.m_rgTimelineMetadata.length - 1];
          if (e) {
            const t = e.metadata.recordings[e.metadata.recordings.length - 1];
            if (t) {
              const r = this.m_mapRunningTimelines.has(e.metadata.timeline_id),
                i = isNaN(parseInt(t.start_offset_ms))
                  ? 0
                  : parseInt(t.start_offset_ms),
                n = isNaN(parseInt(e.metadata.duration_ms))
                  ? 0
                  : parseInt(e.metadata.duration_ms);
              let a = 0;
              return (
                r
                  ? (a = Math.max(0, n - i))
                  : isNaN(parseInt(t.duration_ms)) ||
                    (a = parseInt(t.duration_ms)),
                (0, f.Z6)(e.nGlobalOffsetMS.valMS + i + a)
              );
            }
          }
          return null;
        }
        GetTotalRecordingDuration() {
          let e = 0;
          return (
            this.m_rgTimelineMetadata.forEach((t) => {
              t.metadata.recordings.forEach((t) => {
                isNaN(parseInt(t.duration_ms)) ||
                  (e += parseInt(t.duration_ms));
              });
            }),
            e
          );
        }
        GetTimelineStartBeforeGlobalZeroMS(e) {
          return e == this.m_rgTimelineMetadata[0].metadata.timeline_id
            ? this.m_ulFirstTimelineOffsetMS
            : 0;
        }
        async GenerateClipNameFromTimeline(e, t, r, i) {
          let n,
            a = !1;
          for (let o of this.m_rgTimelineMetadata) {
            let s = !1;
            if (!a) {
              if (o.metadata.timeline_id != e) continue;
              (s = !0), (a = !0);
            }
            const l = o.metadata.timeline_id == r;
            await this.LoadTimelineData(o.metadata.timeline_id);
            const c = this.m_mapTimelineData.get(o.metadata.timeline_id);
            for (let e of c.m_rgEntries) {
              const r = parseInt(e.time);
              if (s && r < t) continue;
              if (l && r > i) continue;
              const a = y(e);
              (!n || (a && a.rank > n.rank)) && (n = a);
            }
            if (l) break;
          }
          if (n?.strTitle) return n?.strTitle;
          const o = new g.N1(this.GetGameID()),
            s = b.Q8.GetAppInfo(o.GetAppID());
          if (s) {
            const e = new Date();
            return `${s.name} ${e.toLocaleString()}`;
          }
        }
      }
      function y(e) {
        switch (e.type) {
          case "event":
            const t = e;
            return { rank: 5e4 + e.priority, strTitle: t.title };
          case "usermarker":
            const r = e;
            return r.title || r.description
              ? { rank: 1e5 + e.priority, strTitle: e.title || e.description }
              : null;
          case "state_description":
            return { rank: 4e4, strTitle: e.title };
          case "achievement":
            return { rank: 9e4, strTitle: e.title };
        }
        return null;
      }
      (0, i.gn)([p.LO], v.prototype, "m_bInitialized", void 0),
        (0, i.gn)([m.a], v.prototype, "UpdateRunningTimelines", null);
    },
    13944: (e, t, r) => {
      "use strict";
      r.d(t, { tP: () => M, dF: () => D, we: () => O });
      var i,
        n = r(85556),
        a = r(47427),
        o = r(20417),
        s = r(54842),
        l = r(12015),
        c = r(42695),
        u = r(91707),
        d = r(93882),
        m = r(45651),
        f = r(40420),
        p = r(87225),
        g = r(12565),
        b = r(45492);
      !(function (e) {
        (e[(e.None = 0)] = "None"),
          (e[(e.DownloadFailed = 1)] = "DownloadFailed"),
          (e[(e.PlaybackError = 2)] = "PlaybackError");
      })(i || (i = {}));
      class h {
        m_elVideo = null;
        m_player = null;
        m_listeners = new b.G_();
        m_nDownloadFailureCount = 0;
        m_bInitailized = !1;
        m_bPaused = !1;
        m_bAtEnd = !1;
        m_ePlayerError = i.None;
        m_bUserInputNeeded = !1;
        m_bMuted = !1;
        m_bSeekReadyToPlay = !1;
        m_bVideoElementPlaying = !1;
        m_nPlaybackSpeed = 1;
        m_bIsWaiting = !0;
        m_bAutoPlay;
        m_bLoadedMetadata = !1;
        m_nPlaybackTime = 0;
        m_nVideoStartTime = 0;
        m_nVideoDuration = 0;
        m_nVolume = 1;
        m_eSeekType = g.tA.Absolute;
        constructor(e) {
          (0, s.rC)(this), (this.m_bAutoPlay = !!e);
        }
        IsPaused() {
          return this.m_bPaused;
        }
        IsAtEnd() {
          return this.m_bAtEnd;
        }
        BSeekReadyToPlay() {
          return this.m_bSeekReadyToPlay;
        }
        GetPlaybackError() {
          return this.m_ePlayerError;
        }
        GetUserInputNeeded() {
          return this.m_bUserInputNeeded;
        }
        GetPlaybackTime() {
          return this.m_eSeekType === g.tA.Absolute
            ? this.m_nPlaybackTime
            : this.m_nPlaybackTime - this.m_nVideoStartTime;
        }
        GetTimelineDuration() {
          return this.m_eSeekType === g.tA.Absolute
            ? this.m_nVideoDuration
            : this.m_nVideoDuration - this.m_nVideoStartTime;
        }
        GetVolume() {
          return this.m_nVolume;
        }
        GetMuted() {
          return this.m_bMuted;
        }
        GetMPDURL() {
          return this.m_player?.GetMPDURL();
        }
        GetVideoElementCurrentTime() {
          return this.m_elVideo?.currentTime;
        }
        BVideoElementPlaying() {
          return this.m_bVideoElementPlaying;
        }
        BVideoElementWaiting() {
          return this.m_bIsWaiting;
        }
        GetVideoHeight() {
          return this.m_elVideo?.clientHeight || 0;
        }
        GetVideoWidth() {
          return this.m_elVideo?.clientWidth || 0;
        }
        GetLoadedMetadata() {
          return this.m_bLoadedMetadata;
        }
        Start(e, t, r, i = g.tA.Absolute) {
          this.Stop(),
            (this.m_bAtEnd = !1),
            (this.m_elVideo = e),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userpausechange",
              this.OnUserPauseChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "playing",
              this.OnVideoPlaying,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "pause",
              this.OnVideoPause,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "timeupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "ended",
              this.OnVideoEnd,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-bufferupdate",
              this.OnVideoTimeUpdate,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-downloadfailed",
              this.OnDownloadFailed,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-playbackerror",
              this.OnPlaybackError,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "valve-userinputneeded",
              this.OnUserInputNeeded,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "waiting",
              this.OnVideoWaiting,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "volumechange",
              this.OnVolumeChange,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "canplay",
              this.OnCanPlay,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "seeking",
              this.OnSeeking,
            ),
            this.m_listeners.AddEventListener(
              this.m_elVideo,
              "loadedmetadata",
              this.OnLoadedMetadata,
            ),
            (this.m_player = new g.C2(this.m_elVideo, !1)),
            this.m_player.SetUserPlayChoice(this.m_bAutoPlay),
            this.m_player.PlayMPD(t, null, null),
            (this.m_bMuted = v("muted")),
            (this.m_nVolume = v("volume")),
            this.m_player.SetMuted(this.m_bMuted),
            this.m_player.SetVolume(this.m_nVolume),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_eSeekType = i);
          const n = `seeking_${t}_${r.toFixed(3)}`;
          (0, l.hB)(`CGameRecordingVideo:: perf mark ${n}`),
            performance.mark(n),
            this.m_player.Seek(r, this.m_eSeekType),
            (this.m_bPaused = this.m_player.IsPaused()),
            (this.m_bInitailized = !0);
        }
        Stop() {
          this.m_listeners.Unregister(),
            this.m_player && this.m_player.Close(),
            (this.m_elVideo = null),
            (this.m_player = null),
            (this.m_bInitailized = !1),
            (this.m_bPaused = !1),
            (this.m_bAtEnd = !1),
            (this.m_bSeekReadyToPlay = !1),
            (this.m_bVideoElementPlaying = !1),
            (this.m_ePlayerError = i.None),
            (this.m_bUserInputNeeded = !1),
            (this.m_nPlaybackTime = 0),
            (this.m_nVideoStartTime = 0),
            (this.m_nVideoDuration = 0),
            (this.m_bLoadedMetadata = !1),
            (this.m_bIsWaiting = !0);
        }
        async UpdateMPD() {
          await this.m_player?.UpdateMPD();
        }
        IsInitialized() {
          return this.m_bInitailized;
        }
        OnCanPlay() {
          (this.m_bSeekReadyToPlay = !0), (this.m_bAtEnd = !1);
        }
        OnUserPauseChange() {
          this.m_bPaused = this.m_player.IsPaused();
        }
        OnVideoPlaying() {
          (this.m_bVideoElementPlaying = !0),
            (this.m_bIsWaiting = !1),
            this.SetPlaybackSpeed(this.m_nPlaybackSpeed),
            (0, l.Zb)("video playing");
        }
        OnVideoPause() {
          (this.m_bVideoElementPlaying = !1), (0, l.Zb)("video paused");
        }
        OnVideoTimeUpdate() {
          (this.m_nVideoStartTime = this.m_player.GetAvailableVideoStartTime()),
            (this.m_nVideoDuration = this.m_player.GetBufferedLiveEdgeTime()),
            (this.m_nPlaybackTime = this.m_player.GetCurrentPlayTime()),
            this.m_nPlaybackTime >= this.m_nVideoDuration &&
              this.m_bVideoElementPlaying &&
              ((this.m_bVideoElementPlaying = !1), (this.m_bAtEnd = !0));
        }
        OnVideoEnd() {
          (this.m_bVideoElementPlaying = !1),
            (this.m_bAtEnd = !0),
            (0, l.Zb)("video ended");
        }
        OnSeeking() {
          (0, l.Zb)("video on seeking"),
            (this.m_bVideoElementPlaying = !1),
            this.m_nVideoDuration - this.m_nPlaybackTime < 1
              ? (this.m_bAtEnd = !0)
              : ((this.m_bIsWaiting = !0), (this.m_bAtEnd = !1));
        }
        OnLoadedMetadata() {
          this.m_bLoadedMetadata = !0;
        }
        async OnDownloadFailed() {
          (0, l.F0)("video download failed"),
            this.m_nDownloadFailureCount < 2
              ? (await this.m_player?.UpdateMPD(),
                this.m_nDownloadFailureCount++)
              : (this.m_ePlayerError = i.DownloadFailed);
        }
        OnPlaybackError() {
          (this.m_bVideoElementPlaying = !1),
            (0, l.F0)("video playback error"),
            (this.m_ePlayerError = i.PlaybackError);
        }
        OnUserInputNeeded() {
          (this.m_bUserInputNeeded = !0),
            !this.m_bMuted &&
              this.m_elVideo.autoplay &&
              ((0, l.Rv)("Failed to autoplay video. Muting and trying again."),
              this.SetMute(!0),
              this.Play());
        }
        OnVolumeChange() {
          (0, l.Zb)("volume change");
        }
        OnVideoWaiting() {
          (this.m_bIsWaiting = !0),
            (this.m_bVideoElementPlaying = !1),
            this.GetTimelineDuration() - this.GetPlaybackTime() < 1 &&
              (this.m_bAtEnd = !0);
        }
        UserInputReceived() {
          this.IsInitialized() &&
            ((this.m_bUserInputNeeded = !1), this.m_player.SeekAndPlay(0));
        }
        SetVolume(e) {
          (this.m_nVolume = e),
            y("volume", e),
            e > 0 ? this.SetMute(!1, !0) : this.SetMute(!0, !0),
            this.IsInitialized() && this.m_player.SetVolume(e);
        }
        SetMute(e, t) {
          this.IsInitialized() && this.m_player.SetMuted(e),
            (this.m_bMuted = e),
            t && y("muted", e);
        }
        TogglePlayPause() {
          this.IsInitialized() &&
            (this.m_player.IsPaused() ? this.Play() : this.Pause());
        }
        Play() {
          this.IsInitialized() && this.m_player.Play();
        }
        Pause() {
          this.IsInitialized() &&
            (this.m_player.Pause(), (this.m_bIsWaiting = !1));
        }
        SetPlaybackSpeed(e) {
          (this.m_nPlaybackSpeed = e),
            this.IsInitialized() && (this.m_elVideo.playbackRate = e);
        }
        GetPlaybackSpeed() {
          return this.m_nPlaybackSpeed;
        }
        Seek(e) {
          if (!this.IsInitialized()) return;
          const t = `seeking_${this.m_player.GetMPDURL()}_${e.toFixed(3)}`;
          (this.m_bAtEnd = !1),
            (this.m_bSeekReadyToPlay = !1),
            performance.mark(t),
            (0, l.hB)(`CGameRecordingVideo:: perf mark ${t}`),
            (0, l.hB)(`CGameRecordingVideo::Seek to ${e}`),
            (this.m_nPlaybackTime = e),
            this.m_player.Seek(e, this.m_eSeekType);
        }
      }
      let _;
      function S() {
        if (!_) {
          let e,
            t = window.localStorage.getItem("gameRecordingPlayer") || "{}";
          try {
            e = JSON.parse(t);
          } catch (t) {
            e = {};
          }
          _ = { muted: e.muted || !1, volume: e.volume || 1 };
        }
        return _;
      }
      function v(e) {
        return S()[e];
      }
      function y(e, t) {
        let r = S();
        r[e] = t;
        let i = JSON.stringify(r);
        window.localStorage.setItem("gameRecordingPlayer", i);
      }
      (0, n.gn)([s.LO], h.prototype, "m_bInitailized", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bPaused", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bAtEnd", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_ePlayerError", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bUserInputNeeded", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bMuted", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bSeekReadyToPlay", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bVideoElementPlaying", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_nPlaybackSpeed", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bIsWaiting", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_bLoadedMetadata", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_nPlaybackTime", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_nVideoStartTime", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_nVideoDuration", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_nVolume", void 0),
        (0, n.gn)([s.LO], h.prototype, "m_eSeekType", void 0),
        (0, n.gn)([s.aD], h.prototype, "Start", null),
        (0, n.gn)([s.aD], h.prototype, "Stop", null),
        (0, n.gn)([o.ak], h.prototype, "OnCanPlay", null),
        (0, n.gn)([o.ak], h.prototype, "OnUserPauseChange", null),
        (0, n.gn)([o.ak], h.prototype, "OnVideoPlaying", null),
        (0, n.gn)([o.ak], h.prototype, "OnVideoPause", null),
        (0, n.gn)([o.ak], h.prototype, "OnVideoTimeUpdate", null),
        (0, n.gn)([o.ak], h.prototype, "OnVideoEnd", null),
        (0, n.gn)([o.ak], h.prototype, "OnSeeking", null),
        (0, n.gn)([o.ak], h.prototype, "OnLoadedMetadata", null),
        (0, n.gn)([o.ak], h.prototype, "OnDownloadFailed", null),
        (0, n.gn)([o.ak], h.prototype, "OnPlaybackError", null),
        (0, n.gn)([o.ak], h.prototype, "OnUserInputNeeded", null),
        (0, n.gn)([o.ak], h.prototype, "OnVolumeChange", null),
        (0, n.gn)([o.ak], h.prototype, "OnVideoWaiting", null),
        (0, n.gn)([o.ak], h.prototype, "UserInputReceived", null);
      var M,
        T,
        B = r(7286),
        R = r(2253),
        E = r(50928);
      !(function (e) {
        (e.Overlay = "Overlay"),
          (e.Clips = "Clips"),
          (e.Background = "Background"),
          (e.CommunityClip = "Community"),
          (e.ChatClip = "Chat"),
          (e.Partner = "Partner");
      })(M || (M = {})),
        (function (e) {
          (e.Never = "Never"), (e.Always = "Always"), (e.Manual = "Manual");
        })(T || (T = {}));
      const w = 3 * d.Ms,
        C = d.Ms + 1e3,
        G = 1e3;
      class P {
        m_gameRecordingVideo = null;
        m_timelineLoader = null;
        m_fnUnregisterLoader = null;
        m_rgListeners = [];
        m_videoRef;
        m_bHidePlayer = !1;
        m_fnGetManifest;
        m_strRecordingID = null;
        m_nPendingSeekSec = -1;
        m_playbackDefinition = null;
        m_pendingStop = null;
        m_durationMS = (0, f.Z6)(null);
        m_lastRecordingGlobalMS = (0, f.Z6)(null);
        m_nGlobalTimelinePlaybackMS = null;
        m_nGlobalTimelinePlaybackSec = null;
        m_fnUnregisterAutorun = [];
        m_eGameRecordingMode;
        m_rgSeekPerf = [];
        m_eRecordingState = B.m8.NotRecording;
        m_eRecordingSetting = T.Never;
        m_bGamepadMode = !1;
        m_bControlsVisible = !0;
        m_fnRenderGlyph = void 0;
        m_previousHighlightEntry = null;
        m_nextHighlightEntry = null;
        m_displayHighlightEntry = null;
        m_rgClipOffsets = [];
        constructor(e, t, r, i, n, a, o, c) {
          (0, s.rC)(this),
            (this.m_fnGetManifest = t),
            (this.m_gameRecordingVideo = new h(!0)),
            (this.m_eGameRecordingMode = r),
            (this.m_bGamepadMode = n),
            (this.m_playbackDefinition = o),
            null != i && (this.m_bControlsVisible = i),
            "Overlay" === r && (this.m_bHidePlayer = !0),
            c && this.SetClipOffsets(c),
            (this.m_fnRenderGlyph = a),
            this.m_fnUnregisterAutorun.push(
              (0, s.U5)(
                () => ({
                  bIsAtEnd: this.m_gameRecordingVideo.IsAtEnd(),
                  bIsPaused: this.m_gameRecordingVideo.IsPaused(),
                }),
                (e) => {
                  e.bIsAtEnd &&
                    !e.bIsPaused &&
                    this.PlayNextTimelineRecording();
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, s.U5)(
                () => this.m_gameRecordingVideo.GetPlaybackTime(),
                (e) => {
                  if (
                    this.m_pendingStop &&
                    this.m_pendingStop.m_strRecordingID ==
                      this.m_strRecordingID &&
                    this.m_pendingStop.m_nOffsetMS <= 1e3 * e
                  ) {
                    if (this.m_playbackDefinition)
                      return void this.StartPlaybackForRange();
                    this.m_gameRecordingVideo.Pause(),
                      (this.m_pendingStop = null);
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, s.U5)(
                () => ({
                  playback: this.m_gameRecordingVideo.GetPlaybackTime(),
                  bVideoPlaying:
                    this.m_gameRecordingVideo.BVideoElementPlaying(),
                }),
                (e) => {
                  if (e.bVideoPlaying) {
                    const t =
                      this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                        this.m_strRecordingID,
                        1e3 * e.playback,
                        0,
                      );
                    if (t)
                      this.UpdateGlobalPlayTime(t.nGlobalOffsetMS),
                        t.nGlobalOffsetMS > this.GetLiveEdgeMS().valMS &&
                          "Overlay" === this.m_eGameRecordingMode &&
                          this.m_gameRecordingVideo.GetPlaybackSpeed() > 1 &&
                          (console.log(
                            " hitting live edge, slow down the playback ",
                          ),
                          this.m_gameRecordingVideo.SetPlaybackSpeed(1));
                    else {
                      const e = this.GetLiveEdgeMS();
                      isNaN(e.valMS) ||
                        (this.SetPlaytimeFromGlobalMS(e),
                        this.FocusGlobalMS(e));
                    }
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, s.U5)(
                () => ({
                  globalPlaybackMS: this.m_nGlobalTimelinePlaybackMS,
                  bVideoPaused: this.m_gameRecordingVideo.IsPaused(),
                  bHidePlayer: this.m_bHidePlayer,
                }),
                (e) => {
                  if (!this.m_timelineLoader?.BInitialized()) return;
                  if (e.bHidePlayer) return void this.SetEntriesForLiveEdge();
                  (!this.m_previousHighlightEntry ||
                    !this.m_nextHighlightEntry ||
                    (this.m_nextHighlightEntry?.globalMS &&
                      e.globalPlaybackMS >=
                        this.m_nextHighlightEntry.globalMS.valMS) ||
                    (this.m_previousHighlightEntry?.globalMS &&
                      e.globalPlaybackMS <=
                        this.m_previousHighlightEntry.globalMS.valMS) ||
                    (e.bVideoPaused &&
                      this.m_previousHighlightEntry?.globalMS &&
                      e.globalPlaybackMS >=
                        this.m_previousHighlightEntry.globalMS.valMS + G)) &&
                    (this.CalculatePreviousHighlightEntry(
                      e.globalPlaybackMS,
                      e.bVideoPaused,
                    ),
                    this.CalculateNextHighlightEntry(
                      e.globalPlaybackMS,
                      e.bVideoPaused,
                    ));
                },
                { fireImmediately: !0 },
              ),
            ),
            this.m_fnUnregisterAutorun.push(
              (0, s.U5)(
                () => this.m_gameRecordingVideo.BSeekReadyToPlay(),
                (e) => {
                  if (e) {
                    const e = `seeking_${this.GetManifestFromRecordingID(this.m_strRecordingID)}_${this.m_gameRecordingVideo.GetPlaybackTime().toFixed(3)}`;
                    try {
                      const t = `measure_${this.m_strRecordingID}_${this.m_gameRecordingVideo.GetPlaybackTime().toFixed(3)}`,
                        r = performance.measure(t, e);
                      (0, l.hB)(
                        `CGameRecordingVideo:: perf measure ${e} duration ${r.duration}`,
                      ),
                        r && this.m_rgSeekPerf.push(r.duration);
                    } catch (t) {
                      (0, l.hB)(
                        `CGameRecordingVideo:: cant measure ${e}, error: ${t}`,
                      );
                    }
                  }
                },
                { fireImmediately: !0 },
              ),
            ),
            this.SetLoader(e);
        }
        AddEventListener(e) {
          return this.m_rgListeners.push(e), () => p.Zf(this.m_rgListeners, e);
        }
        FireEvent(e, ...t) {
          for (let r of this.m_rgListeners) {
            let i = r[e];
            i instanceof Function && i.apply(r, t);
          }
        }
        dispose() {
          this.m_fnUnregisterAutorun.forEach((e) => e()),
            this.m_fnUnregisterLoader &&
              (this.m_fnUnregisterLoader(), (this.m_fnUnregisterLoader = null));
        }
        SetVideoElement(e) {
          if (e) {
            if (this.m_videoRef === e) return;
            if (((this.m_videoRef = e), this.m_strRecordingID)) {
              const e = this.m_nPendingSeekSec > 0 ? this.m_nPendingSeekSec : 0;
              (this.m_nPendingSeekSec = -1),
                this.ChangePlaybackRecording(this.m_strRecordingID, e);
            } else this.TryPlayInitialTimelineVideo();
          } else this.m_gameRecordingVideo.Stop(), (this.m_videoRef = null);
        }
        OnInvalidateRecording(e, t) {
          const r = this.m_fnGetManifest(t);
          this.m_gameRecordingVideo.GetMPDURL() == r &&
            ((0, l.hB)(`Recording invalidated for ${t}. Reloading MPD`),
            this.m_gameRecordingVideo.UpdateMPD());
        }
        OnLoaderInitialized() {
          (this.m_durationMS = this.m_timelineLoader.GetGlobalTimelineEndMS()),
            (this.m_lastRecordingGlobalMS =
              this.m_timelineLoader.GetEndOfRecordingsMS()),
            this.TryPlayInitialTimelineVideo();
          const e = (0, u.Ou)(this.m_timelineLoader.GetGameID());
          this.SetClipOffsets(e);
        }
        OnInvalidate(e) {
          if (
            ((this.m_durationMS =
              this.m_timelineLoader.GetGlobalTimelineEndMS()),
            (this.m_lastRecordingGlobalMS =
              this.m_timelineLoader.GetEndOfRecordingsMS()),
            this.m_bHidePlayer && this.m_timelineLoader.IsActiveTimeline(e))
          )
            this.SetEntriesForLiveEdge();
          else {
            if (this.m_previousHighlightEntry && this.m_nextHighlightEntry) {
              const t = this.m_timelineLoader.GetTimelineMetadataIndex(e),
                r = this.m_timelineLoader.GetTimelineMetadataIndex(
                  this.m_previousHighlightEntry.timelineID,
                ),
                i = this.m_timelineLoader.GetTimelineMetadataIndex(
                  this.m_nextHighlightEntry.timelineID,
                );
              if (t < r || t > i) return;
            }
            this.CalculatePreviousHighlightEntry(
              this.m_nGlobalTimelinePlaybackMS,
              this.GetGameRecordingVideo().IsPaused(),
            ),
              this.CalculateNextHighlightEntry(
                this.m_nGlobalTimelinePlaybackMS,
                this.GetGameRecordingVideo().IsPaused(),
              );
          }
        }
        OnTimelineLoaded(e) {
          this.m_previousHighlightEntry &&
            this.m_previousHighlightEntry.timelineID === e &&
            this.CalculatePreviousHighlightEntry(
              this.m_nGlobalTimelinePlaybackMS,
              this.GetGameRecordingVideo().IsPaused(),
            ),
            this.m_nextHighlightEntry &&
              this.m_nextHighlightEntry.timelineID === e &&
              this.CalculateNextHighlightEntry(
                this.m_nGlobalTimelinePlaybackMS,
                this.GetGameRecordingVideo().IsPaused(),
              );
        }
        SetEntriesForLiveEdge() {
          const e = this.GetLiveEdgeMS();
          this.CalculatePreviousHighlightEntry(e.valMS, !0),
            (this.m_nextHighlightEntry = null);
        }
        CalculatePreviousHighlightEntry(e, t) {
          const r = t ? 1 : G * this.m_gameRecordingVideo.GetPlaybackSpeed(),
            i = this.m_timelineLoader.GetClosestPreviousEntryInGlobalTimeline(
              e - r,
            );
          "loaded" !== i.timelineState || i.entry
            ? (this.m_previousHighlightEntry = i)
            : (this.m_previousHighlightEntry =
                this.m_timelineLoader.GetClosestPreviousEntryInGlobalTimeline(
                  e,
                ));
        }
        CalculateNextHighlightEntry(e, t) {
          const r =
            this.m_timelineLoader.GetClosestNextEntryInGlobalTimeline(e);
          if ("loaded" !== r.timelineState || r.entry)
            this.m_nextHighlightEntry = r;
          else {
            const r = t ? 1 : G * this.m_gameRecordingVideo.GetPlaybackSpeed();
            this.m_nextHighlightEntry =
              this.m_timelineLoader.GetClosestNextEntryInGlobalTimeline(e - r);
          }
        }
        GetPreviousHighlightEntry() {
          return this.m_previousHighlightEntry;
        }
        GetNextHighlightEntry() {
          return this.m_nextHighlightEntry;
        }
        GetDisplayHighlightEntry() {
          return this.m_displayHighlightEntry;
        }
        SetDisplayHighlightEntry(e, t) {
          this.m_displayHighlightEntry = { entry: e, duration: t };
        }
        GetClipOffsets() {
          return this.m_rgClipOffsets;
        }
        SetClipOffsets(e) {
          if (!this.m_timelineLoader?.BInitialized()) return;
          let t = [];
          e &&
            e.length &&
            e.forEach((e) => {
              const r = this.m_timelineLoader.GetGlobalOffsetDataForTimeline(
                e.start_timeline_id,
                0,
              );
              if (!r) return;
              const i = r.nGlobalOffsetMS + parseInt(e.start_offset_ms);
              t.push({
                strClipID: e.clip_id,
                nGlobalOffsetMS: i,
                nDurationMS: parseInt(e.duration_ms),
              });
            }),
            (this.m_rgClipOffsets = t);
        }
        GetTotalMS() {
          return this.m_durationMS;
        }
        GetIsActiveTimeline(e) {
          return this.m_timelineLoader.IsActiveTimeline(e);
        }
        BIsVideoElementPaused() {
          return this.m_gameRecordingVideo.IsPaused();
        }
        BInitialized() {
          return this.m_timelineLoader.BInitialized();
        }
        GetHidePlayer() {
          return this.m_bHidePlayer;
        }
        SetHidePlayer(e) {
          e && (this.m_strRecordingID = null), (this.m_bHidePlayer = e);
        }
        BPlayerInitialized() {
          return this.m_gameRecordingVideo.IsInitialized();
        }
        GetGameRecordingVideo() {
          return this.m_gameRecordingVideo;
        }
        GetGameID() {
          return this.m_timelineLoader.GetGameID();
        }
        GetClipID() {
          return this.m_timelineLoader.GetClipID();
        }
        GetRecordingState() {
          return this.m_eRecordingState;
        }
        SetRecordingState(e) {
          this.m_eRecordingState = e;
        }
        GetLoader() {
          return this.m_timelineLoader;
        }
        SetLoader(e) {
          this.m_timelineLoader != e &&
            (this.m_fnUnregisterLoader && this.m_fnUnregisterLoader(),
            (this.m_timelineLoader = e),
            (this.m_fnUnregisterLoader =
              this.m_timelineLoader.AddEventListener(this)),
            e.BInitialized() && this.OnLoaderInitialized());
        }
        SetGetManifest(e) {
          this.m_fnGetManifest = e;
        }
        GetRecordingID() {
          return this.m_strRecordingID;
        }
        GetRecordingSetting() {
          return this.m_eRecordingSetting;
        }
        SetRecordingSetting(e) {
          this.m_eRecordingSetting = e;
        }
        GetRecordingMode() {
          return this.m_eGameRecordingMode;
        }
        ShouldModeShowClipControls() {
          switch (this.m_eGameRecordingMode) {
            case M.Overlay:
            case M.Clips:
            case M.Background:
              return !0;
            default:
              return !1;
          }
        }
        CanModeAddMarker() {
          switch (this.m_eGameRecordingMode) {
            case M.Overlay:
            case M.Clips:
            case M.Background:
              return !0;
            default:
              return !1;
          }
        }
        GetPlaybackStats() {
          if (!this.m_rgSeekPerf.length) return null;
          const e = this.m_rgSeekPerf.length,
            t = this.m_rgSeekPerf.reduce((e, t) => e + t) / e,
            r = Math.sqrt(
              this.m_rgSeekPerf
                .map((e) => Math.pow(e - t, 2))
                .reduce((e, t) => e + t) / e,
            ),
            i = Math.max(...this.m_rgSeekPerf),
            n = Math.min(...this.m_rgSeekPerf);
          return {
            nMean: t,
            nStdDev: r,
            nMax: i,
            nMin: n,
            nLength: e,
            nLastVal: this.m_rgSeekPerf[e - 1],
          };
        }
        StartPlaybackForRange() {
          let e = this.m_timelineLoader.GetGlobalOffsetDataForTimeline(
              this.m_playbackDefinition.m_strTimelineID,
              0,
            ),
            t = e?.nGlobalOffsetMS || 0;
          t += this.m_playbackDefinition.m_nTimelineStartMS;
          let r =
            this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
              t,
            );
          if (r) {
            if (this.m_playbackDefinition.m_nDurationMS) {
              let e = t + this.m_playbackDefinition.m_nDurationMS,
                r =
                  this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
                    e,
                  );
              this.m_pendingStop = {
                m_strRecordingID: r.strRecordingID,
                m_nOffsetMS: r.nRecordingOffsetMS,
              };
            }
            this.UpdateGlobalPlayTime(t),
              this.ChangePlaybackRecording(
                r.strRecordingID,
                r.nRecordingOffsetMS / 1e3,
              );
          }
        }
        TryPlayInitialTimelineVideo() {
          if (this.m_timelineLoader.BInitialized() && !this.m_bHidePlayer)
            if (this.m_playbackDefinition) this.StartPlaybackForRange();
            else if (this.m_eGameRecordingMode === M.Overlay) {
              const e = this.GetLiveEdgeMS(),
                t =
                  this.m_timelineLoader.GetFirstRecordingOfLastTimelineSession(),
                r = this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
                  t,
                  0,
                  0,
                );
              r && e.valMS < r.nGlobalOffsetMS
                ? (this.UpdateGlobalPlayTime(r.nGlobalOffsetMS),
                  this.ChangePlaybackRecording(t, 0))
                : isNaN(e.valMS) || this.SetPlaytimeFromGlobalMS(e);
            } else if (this.m_eGameRecordingMode === M.Background) {
              const e =
                this.m_timelineLoader.GetFirstRecordingOfLastTimelineSession();
              this.SetPlaytimeFromRecordingOffset(e, 0);
            } else {
              const e = this.m_timelineLoader.GetFirstRecording();
              this.SetPlaytimeFromRecordingOffset(e, 0);
            }
        }
        GetTotalSeconds() {
          return Math.floor(
            this.m_timelineLoader.GetGlobalTimelineEndMS().valMS / 1e3,
          );
        }
        GetCurrentPlaybackGlobalMS(e = 0) {
          const t =
            Math.floor(1e3 * this.m_gameRecordingVideo.GetPlaybackTime()) + e;
          return this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
            this.m_strRecordingID,
            t,
            0,
          );
        }
        GetIsLiveEdge() {
          const e = this.GetGlobalMSPlaytime().valMS || 0;
          return "Overlay" === this.m_eGameRecordingMode
            ? !!this.m_lastRecordingGlobalMS &&
                this.m_lastRecordingGlobalMS.valMS - e < w
            : this.GetTotalMS().valMS - e < 1;
        }
        GetLiveEdgeBufferWindowStartMS() {
          if (
            "Overlay" === this.m_eGameRecordingMode &&
            this.m_lastRecordingGlobalMS
          ) {
            const e = Math.max(0, this.m_lastRecordingGlobalMS.valMS - w);
            return (0, f.Z6)(e);
          }
          return this.GetTotalMS();
        }
        GetLiveEdgeMS() {
          if (
            "Overlay" === this.m_eGameRecordingMode &&
            this.m_lastRecordingGlobalMS
          ) {
            const e = Math.max(0, this.m_lastRecordingGlobalMS.valMS - C);
            return (0, f.Z6)(e);
          }
          return (0, f.Z6)(Math.max(0, this.GetTotalMS().valMS - 1));
        }
        GetTimelineAndOffsetRelativeToCurrentPlayback(e = 0) {
          const t = this.GetCurrentPlaybackGlobalMS(e);
          return (
            t ||
            ((0, l.F0)(
              `failed to find offset for ${this.m_strRecordingID} at ${Math.floor(1e3 * this.m_gameRecordingVideo.GetPlaybackTime())} MS`,
            ),
            null)
          );
        }
        SeekDeltaMS(e) {
          const t = this.GetGlobalMSPlaytime();
          if (!this.m_strRecordingID) {
            const r =
              e > 0
                ? this.GetClosestNextRecordingForGlobalMS(t)
                : this.GetClosestPreviousRecordingForGlobalMS(t);
            if (r) {
              const t = e > 0 ? e : Math.max(parseInt(r.duration_ms) + e, 0);
              return void this.SetPlaytimeFromRecordingOffset(
                r.recording_id,
                t,
                e < 0,
              );
            }
          }
          const r =
              "Overlay" === this.m_eGameRecordingMode
                ? this.GetLiveEdgeMS().valMS
                : this.GetTotalMS().valMS,
            i = m.Lh(t.valMS + e, 0, r - 500);
          this.SetPlaytimeFromGlobalMS((0, f.Z6)(i));
        }
        ConvertGlobaOffsetToRecordingAndRelativeOffset(e) {
          return this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e,
          );
        }
        PlayNextTimelineRecording(e) {
          if (this.m_playbackDefinition)
            return void this.StartPlaybackForRange();
          let t;
          if (this.m_strRecordingID)
            t = this.m_timelineLoader.GetNextRecording(this.m_strRecordingID);
          else {
            const e =
              this.m_timelineLoader.GetClosestNextRecordingInGlobalTimeline(
                (0, f.Z6)(this.m_nGlobalTimelinePlaybackMS),
              );
            t = e?.recording_id;
          }
          t
            ? this.SetPlaytimeFromRecordingOffset(t, 0)
            : (this.m_gameRecordingVideo.Pause(),
              e && this.TryPlayInitialTimelineVideo());
        }
        GetClipsAtGlobalMS(e) {
          return (
            this.m_rgClipOffsets.filter(
              (t) =>
                t.nGlobalOffsetMS <= e.valMS &&
                t.nGlobalOffsetMS + t.nDurationMS >= e.valMS,
            ) || []
          );
        }
        GetClosestPreviousRecordingForGlobalMS(e) {
          return this.m_timelineLoader.GetClosestPreviousRecordingInGlobalTimeline(
            e,
          );
        }
        GetClosestNextRecordingForGlobalMS(e) {
          return this.m_timelineLoader.GetClosestNextRecordingInGlobalTimeline(
            e,
          );
        }
        SetPlaytimeFromRecordingOffset(e, t, r, i) {
          let n = t;
          r &&
            (n = this.m_timelineLoader.ConvertRecordingTimeMStoPreTrimTimeMS(
              e,
              t,
            ));
          const a = this.m_timelineLoader.ConvertRecordingOffsetToGlobalOffset(
            e,
            n,
            0,
          );
          a &&
            (this.UpdateGlobalPlayTime(a.nGlobalOffsetMS),
            this.ChangePlaybackRecording(e, n / 1e3, i));
        }
        GetManifestFromRecordingID(e) {
          return this.m_fnGetManifest(e);
        }
        ChangePlaybackRecording(e, t = 0, r) {
          this.m_bHidePlayer = !1;
          const i = this.m_gameRecordingVideo.IsPaused();
          if (
            this.m_strRecordingID === e &&
            this.m_gameRecordingVideo.IsInitialized()
          )
            return void this.m_gameRecordingVideo.Seek(t);
          if (
            (this.m_gameRecordingVideo.Stop(), (this.m_strRecordingID = e), !e)
          )
            return;
          if (!this.m_videoRef) return void (this.m_nPendingSeekSec = t);
          const n = this.GetManifestFromRecordingID(e),
            a = this.m_timelineLoader.BRecordingHasZeroOffset(e)
              ? g.tA.Absolute
              : g.tA.FromAvailableStart;
          this.m_gameRecordingVideo.Start(this.m_videoRef, n, t, a),
            (r || i) && this.m_gameRecordingVideo.Pause();
        }
        StopPlayback() {
          this.m_gameRecordingVideo.Stop();
        }
        TogglePlayPause() {
          this.m_gameRecordingVideo.IsPaused() ||
          !this.m_gameRecordingVideo.IsInitialized()
            ? (this.m_nGlobalTimelinePlaybackMS >
                this.m_lastRecordingGlobalMS.valMS &&
                this.TryPlayInitialTimelineVideo(),
              this.m_gameRecordingVideo.GetTimelineDuration() -
                this.m_gameRecordingVideo.GetPlaybackTime() <
              1
                ? this.PlayNextTimelineRecording(!0)
                : this.m_gameRecordingVideo.Play())
            : this.m_gameRecordingVideo.Pause();
        }
        GetGlobalMSPlaytime() {
          return (0, f.Z6)(this.m_nGlobalTimelinePlaybackMS);
        }
        GetGlobalPlaytimeSec() {
          return this.m_nGlobalTimelinePlaybackSec;
        }
        UpdateGlobalPlayTime(e) {
          (this.m_nGlobalTimelinePlaybackMS = e),
            (this.m_nGlobalTimelinePlaybackSec = Math.floor(e / 1e3));
        }
        SetPlaytimeFromGlobalMS(e, t) {
          (this.m_pendingStop = null), this.UpdateGlobalPlayTime(e.valMS);
          const r =
            this.m_timelineLoader.ConvertGlobaOffsetToRecordingAndRelativeOffset(
              e.valMS,
            );
          this.ChangePlaybackRecording(
            r?.strRecordingID,
            r?.nRecordingOffsetMS / 1e3,
            t,
          );
        }
        ConvertGlobalOffsetToTimelineRelativeOffset(e) {
          return this.m_timelineLoader.GetTimelineOffsetFromGlobal(e, 0);
        }
        GetTimelineDuration(e) {
          if (!this.m_timelineLoader.BInitialized()) return null;
          const t = this.m_timelineLoader.GetTimelineMetadata(e);
          return t ? parseInt(t.metadata.duration_ms) : null;
        }
        GetTimelineFirstRecordingOffset(e) {
          if (!this.m_timelineLoader.BInitialized()) return null;
          const t = this.m_timelineLoader.GetTimelineMetadata(e);
          if (!t) return null;
          const r = t.metadata.recordings;
          return r.length ? parseInt(r[0].start_offset_ms) : null;
        }
        async AddUserMarkerAtGlobalMS(e, t, r) {
          const i = this.m_timelineLoader.GetTimelineOffsetFromGlobal(
            e.valMS,
            0,
          );
          if (i) {
            const e = this.m_timelineLoader.GetGameID(),
              { fnCreateUserTimelineMarkers: n } = (0, u.Mo)(),
              a = this.m_timelineLoader.GetTimelineStartBeforeGlobalZeroMS(
                i.strTimelineID,
              );
            c.q.ReportTrackedAction(t);
            const o = "steam_marker",
              s = await n(e, this.GetClipID(), {
                timeline_id: i.strTimelineID,
                entry_id: "",
                time: "" + Math.floor(i.nTimelineOffsetMS.valMS + a),
                type: 5,
                marker_icon: o,
                marker_priority: 0,
              });
            1 == s.eResult &&
              (this.m_timelineLoader.AddUserMarker(
                i.strTimelineID,
                Math.floor(i.nTimelineOffsetMS.valMS),
                o,
                s.entry_id,
              ),
              r && r(s.entry_id, i.strTimelineID));
          }
        }
        async RemoveUserMarker(e, t) {
          const { fnRemoveUserTimelineMarker: r } = (0, u.Mo)(),
            i = this.m_timelineLoader.GetGameID();
          return 1 == (await r(i, this.GetClipID(), e, t))
            ? (this.m_timelineLoader.RemoveUserMarker(e, t), !0)
            : ((0, l.Zb)(
                `Failed to delete user marker for timeline ${e} entry ${t}`,
              ),
              !1);
        }
        async UpdateUserMarker(e, t, r, i) {
          const { fnUpdateUserTimelineMarkers: n } = (0, u.Mo)(),
            a = this.m_timelineLoader.GetGameID(),
            o = {
              timeline_id: e,
              entry_id: t.id,
              time: t.time,
              type: 5,
              marker_icon: t.icon,
              marker_priority: t.priority,
              marker_title: r,
              marker_description: i,
            };
          if (1 == (await n(a, this.GetClipID(), o))) {
            const n = {
              strIcon: t.icon,
              name: r,
              description: i,
              nTimelineOffsetMS: parseInt(t.time),
            };
            return this.m_timelineLoader.UpdateUserMarker(e, t.id, n), !0;
          }
          return !1;
        }
        FocusGlobalMS(e) {
          this.FireEvent("OnFocusGlobalMS", e);
        }
        SetPlaybackStop(e) {
          const t = this.ConvertGlobaOffsetToRecordingAndRelativeOffset(
            e.valMS,
          );
          t &&
            (this.m_pendingStop = {
              m_strRecordingID: t.strRecordingID,
              m_nOffsetMS: t.nRecordingOffsetMS,
            });
        }
        ClearPlaybackStop() {
          this.m_pendingStop = null;
        }
        GenerateClipNameFromTimeline(e, t, r, i) {
          return this.m_timelineLoader.GenerateClipNameFromTimeline(e, t, r, i);
        }
        GetRenderGlyph() {
          return this.m_bGamepadMode ? this.m_fnRenderGlyph : void 0;
        }
        SetRenderGlyph(e) {
          this.m_fnRenderGlyph = e;
        }
        GetGamepadMode() {
          return this.m_bGamepadMode;
        }
        SetGamepadMode(e) {
          this.m_bGamepadMode = e;
        }
        GetControlsVisible() {
          return this.m_bControlsVisible;
        }
        SetControlsVisible(e) {
          null != e && (this.m_bControlsVisible = e);
        }
      }
      (0, n.gn)([s.LO], P.prototype, "m_bHidePlayer", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_strRecordingID", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_durationMS", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_lastRecordingGlobalMS", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_nGlobalTimelinePlaybackMS", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_nGlobalTimelinePlaybackSec", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_rgSeekPerf", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_eRecordingState", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_eRecordingSetting", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_bGamepadMode", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_bControlsVisible", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_fnRenderGlyph", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_previousHighlightEntry", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_nextHighlightEntry", void 0),
        (0, n.gn)([s.LO], P.prototype, "m_displayHighlightEntry", void 0),
        (0, n.gn)([s.LO.ref], P.prototype, "m_rgClipOffsets", void 0),
        (0, n.gn)([o.ak], P.prototype, "SetVideoElement", null),
        (0, n.gn)([o.ak], P.prototype, "OnInvalidateRecording", null),
        (0, n.gn)([s.aD], P.prototype, "OnLoaderInitialized", null),
        (0, n.gn)([o.ak], P.prototype, "OnInvalidate", null),
        (0, n.gn)([o.ak], P.prototype, "OnTimelineLoaded", null),
        (0, n.gn)([o.ak], P.prototype, "GetLiveEdgeMS", null),
        (0, n.gn)([o.ak], P.prototype, "StopPlayback", null),
        (0, n.gn)([o.ak], P.prototype, "TogglePlayPause", null),
        (0, n.gn)([s.aD], P.prototype, "UpdateGlobalPlayTime", null);
      const I = a.createContext({ timelinePlaybackCoordinator: null });
      function D(e) {
        const {
            children: t,
            mode: r,
            fnGetManifest: i,
            loader: n,
            recordingState: o,
            controlsVisible: s,
            gamepadMode: l,
            renderGlyph: c,
            markerStore: u,
            recordingSetting: d,
            playbackDefinition: m,
            clipSummaries: f,
          } = e,
          [p] = a.useState(() => new P(n, i, r, s, l, c, m, f));
        (0, a.useEffect)(() => {
          (0, R.p)(u ?? E.CGameTimelineMarkerStore.Get());
        }, [u]),
          (0, a.useEffect)(() => {
            p.SetLoader(n);
          }, [p, n]),
          (0, a.useEffect)(() => {
            p.SetRecordingState(o);
          }, [p, o]),
          (0, a.useEffect)(() => {
            p.SetRecordingSetting(d);
          }, [p, d]),
          (0, a.useEffect)(() => {
            p.SetGetManifest(i);
          }, [p, i]),
          (0, a.useEffect)(() => {
            p.SetControlsVisible(s);
          }, [p, s]),
          (0, a.useEffect)(() => {
            p.SetGamepadMode(l);
          }, [p, l]),
          (0, a.useEffect)(() => {
            p.SetRenderGlyph(c);
          }, [p, c]),
          (0, a.useEffect)(() => {
            p.SetClipOffsets(f);
          }, [p, f]),
          (0, a.useEffect)(() => () => p.dispose(), [p]);
        const g = a.useMemo(() => ({ timelinePlaybackCoordinator: p }), [p]);
        return a.createElement(I.Provider, { value: g }, t);
      }
      function O() {
        return (0, a.useContext)(I).timelinePlaybackCoordinator;
      }
    },
    20020: (e, t, r) => {
      "use strict";
      function i(e, t, ...r) {
        console.assert
          ? 0 == r.length
            ? console.assert(!!e, t)
            : console.assert(!!e, t, ...r)
          : e || console.warn(t, ...r);
      }
      function n(e, t, ...r) {
        i(!1, t, ...r);
      }
      r.d(t, { X: () => i, Z: () => n });
    },
    88235: (e, t, r) => {
      "use strict";
      r.d(t, {
        P5: () => B,
        dn: () => s,
        n4: () => u,
        nq: () => m,
        tS: () => l,
        uI: () => b,
        v6: () => _,
      });
      var i = r(10059),
        n = r(39087),
        a = r(79545);
      const o = i.Message;
      class s extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            s.prototype.appid || n.aR(s.M()),
            o.initialize(this, e, 0, -1, [5], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            s.sm_m ||
              (s.sm_m = {
                proto: s,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                  name: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                  desc: { n: 4, br: n.FE.readString, bw: n.Xc.writeString },
                  branches: {
                    n: 5,
                    r: !0,
                    q: !0,
                    br: n.FE.readString,
                    bw: n.Xc.writeRepeatedString,
                  },
                  last_update_rtime: {
                    n: 6,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  priority: { n: 7, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  last_publish_rtime: {
                    n: 8,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                },
              }),
            s.sm_m
          );
        }
        static MBF() {
          return s.sm_mbf || (s.sm_mbf = n.Bh(s.M())), s.sm_mbf;
        }
        toObject(e = !1) {
          return s.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(s.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(s.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new s();
          return s.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(s.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return s.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(s.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return s.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSet";
        }
      }
      class l extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            l.prototype.appid || n.aR(l.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            l.sm_m ||
              (l.sm_m = {
                proto: l,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset: { n: 2, c: s },
                },
              }),
            l.sm_m
          );
        }
        static MBF() {
          return l.sm_mbf || (l.sm_mbf = n.Bh(l.M())), l.sm_mbf;
        }
        toObject(e = !1) {
          return l.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(l.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(l.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new l();
          return l.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(l.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return l.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(l.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return l.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_CreateAssetSet_Request";
        }
      }
      class c extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            c.prototype.assetset || n.aR(c.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            c.sm_m ||
              (c.sm_m = { proto: c, fields: { assetset: { n: 1, c: s } } }),
            c.sm_m
          );
        }
        static MBF() {
          return c.sm_mbf || (c.sm_mbf = n.Bh(c.M())), c.sm_mbf;
        }
        toObject(e = !1) {
          return c.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(c.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(c.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new c();
          return c.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(c.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(c.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_CreateAssetSet_Response";
        }
      }
      class u extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            u.prototype.appid || n.aR(u.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            u.sm_m ||
              (u.sm_m = {
                proto: u,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                },
              }),
            u.sm_m
          );
        }
        static MBF() {
          return u.sm_mbf || (u.sm_mbf = n.Bh(u.M())), u.sm_mbf;
        }
        toObject(e = !1) {
          return u.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(u.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(u.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new u();
          return u.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(u.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(u.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_DeleteAssetSet_Request";
        }
      }
      class d extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), o.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return d.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new d();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new d();
          return d.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return d.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return d.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_DeleteAssetSet_Response";
        }
      }
      class m extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            m.prototype.appid || n.aR(m.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            m.sm_m ||
              (m.sm_m = {
                proto: m,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset: { n: 2, c: s },
                },
              }),
            m.sm_m
          );
        }
        static MBF() {
          return m.sm_mbf || (m.sm_mbf = n.Bh(m.M())), m.sm_mbf;
        }
        toObject(e = !1) {
          return m.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(m.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(m.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new m();
          return m.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(m.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(m.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdateAssetSet_Request";
        }
      }
      class f extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), o.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return f.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new f();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new f();
          return f.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdateAssetSet_Response";
        }
      }
      class p extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            p.prototype.appid || n.aR(p.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            p.sm_m ||
              (p.sm_m = {
                proto: p,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                },
              }),
            p.sm_m
          );
        }
        static MBF() {
          return p.sm_mbf || (p.sm_mbf = n.Bh(p.M())), p.sm_mbf;
        }
        toObject(e = !1) {
          return p.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(p.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(p.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new p();
          return p.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(p.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(p.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_GetAllAssetSets_Request";
        }
      }
      class g extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            g.prototype.assetset || n.aR(g.M()),
            o.initialize(this, e, 0, -1, [2], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            g.sm_m ||
              (g.sm_m = {
                proto: g,
                fields: { assetset: { n: 2, c: s, r: !0, q: !0 } },
              }),
            g.sm_m
          );
        }
        static MBF() {
          return g.sm_mbf || (g.sm_mbf = n.Bh(g.M())), g.sm_mbf;
        }
        toObject(e = !1) {
          return g.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(g.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(g.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new g();
          return g.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(g.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(g.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_GetAllAssetSets_Response";
        }
      }
      class b extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            b.prototype.appid || n.aR(b.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            b.sm_m ||
              (b.sm_m = {
                proto: b,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                  branch: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            b.sm_m
          );
        }
        static MBF() {
          return b.sm_mbf || (b.sm_mbf = n.Bh(b.M())), b.sm_mbf;
        }
        toObject(e = !1) {
          return b.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(b.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(b.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new b();
          return b.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(b.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(b.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_AddBranchToAssetSet_Request";
        }
      }
      class h extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            h.prototype.updated || n.aR(h.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            h.sm_m ||
              (h.sm_m = { proto: h, fields: { updated: { n: 1, c: s } } }),
            h.sm_m
          );
        }
        static MBF() {
          return h.sm_mbf || (h.sm_mbf = n.Bh(h.M())), h.sm_mbf;
        }
        toObject(e = !1) {
          return h.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(h.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(h.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new h();
          return h.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(h.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return h.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(h.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return h.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_AddBranchToAssetSet_Response";
        }
      }
      class _ extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            _.prototype.appid || n.aR(_.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            _.sm_m ||
              (_.sm_m = {
                proto: _,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                  branch: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            _.sm_m
          );
        }
        static MBF() {
          return _.sm_mbf || (_.sm_mbf = n.Bh(_.M())), _.sm_mbf;
        }
        toObject(e = !1) {
          return _.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(_.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(_.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new _();
          return _.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(_.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(_.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_RemoveBranchFromAssetSet_Request";
        }
      }
      class S extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            S.prototype.updated || n.aR(S.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            S.sm_m ||
              (S.sm_m = { proto: S, fields: { updated: { n: 1, c: s } } }),
            S.sm_m
          );
        }
        static MBF() {
          return S.sm_mbf || (S.sm_mbf = n.Bh(S.M())), S.sm_mbf;
        }
        toObject(e = !1) {
          return S.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(S.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(S.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new S();
          return S.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(S.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(S.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_RemoseBranchFromAssetSet_Response";
        }
      }
      class v extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            v.prototype.appid || n.aR(v.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            v.sm_m ||
              (v.sm_m = {
                proto: v,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  first_assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                  second_assetset_id: {
                    n: 3,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                },
              }),
            v.sm_m
          );
        }
        static MBF() {
          return v.sm_mbf || (v.sm_mbf = n.Bh(v.M())), v.sm_mbf;
        }
        toObject(e = !1) {
          return v.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(v.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(v.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new v();
          return v.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(v.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(v.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_SwapAssetSetPriority_Request";
        }
      }
      class y extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            y.prototype.updated_first || n.aR(y.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            y.sm_m ||
              (y.sm_m = {
                proto: y,
                fields: {
                  updated_first: { n: 1, c: s },
                  updated_second: { n: 2, c: s },
                },
              }),
            y.sm_m
          );
        }
        static MBF() {
          return y.sm_mbf || (y.sm_mbf = n.Bh(y.M())), y.sm_mbf;
        }
        toObject(e = !1) {
          return y.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(y.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(y.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new y();
          return y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(y.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(y.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_SwapAssetSetPriority_Response";
        }
      }
      class M extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            M.prototype.appid || n.aR(M.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            M.sm_m ||
              (M.sm_m = {
                proto: M,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  assetset_id: {
                    n: 2,
                    br: n.FE.readFixed64String,
                    bw: n.Xc.writeFixed64String,
                  },
                },
              }),
            M.sm_m
          );
        }
        static MBF() {
          return M.sm_mbf || (M.sm_mbf = n.Bh(M.M())), M.sm_mbf;
        }
        toObject(e = !1) {
          return M.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(M.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(M.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new M();
          return M.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(M.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(M.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdatePublishTime_Request";
        }
      }
      class T extends o {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            T.prototype.updated || n.aR(T.M()),
            o.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            T.sm_m ||
              (T.sm_m = { proto: T, fields: { updated: { n: 1, c: s } } }),
            T.sm_m
          );
        }
        static MBF() {
          return T.sm_mbf || (T.sm_mbf = n.Bh(T.M())), T.sm_mbf;
        }
        toObject(e = !1) {
          return T.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(T.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(T.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new T();
          return T.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(T.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(T.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CAssetSetPublishing_UpdatePublishTime_Response";
        }
      }
      var B;
      !(function (e) {
        (e.CreateAssetSet = function (e, t) {
          return e.SendMsg(
            "AssetSetPublishing.CreateAssetSet#1",
            (0, a.MD)(l, t),
            c,
            { ePrivilege: 7 },
          );
        }),
          (e.DeleteAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.DeleteAssetSet#1",
              (0, a.MD)(u, t),
              d,
              { ePrivilege: 7 },
            );
          }),
          (e.UpdateAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.UpdateAssetSet#1",
              (0, a.MD)(m, t),
              f,
              { ePrivilege: 7 },
            );
          }),
          (e.GetAllAssetSets = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.GetAllAssetSets#1",
              (0, a.MD)(p, t),
              g,
              { bConstMethod: !0, ePrivilege: 7 },
            );
          }),
          (e.AddBranchToAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.AddBranchToAssetSet#1",
              (0, a.MD)(b, t),
              h,
              { ePrivilege: 7 },
            );
          }),
          (e.RemoveBranchFromAssetSet = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.RemoveBranchFromAssetSet#1",
              (0, a.MD)(_, t),
              S,
              { ePrivilege: 7 },
            );
          }),
          (e.SwapAssetSetPriority = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.SwapAssetSetPriority#1",
              (0, a.MD)(v, t),
              y,
              { ePrivilege: 7 },
            );
          }),
          (e.UpdatePublishTime = function (e, t) {
            return e.SendMsg(
              "AssetSetPublishing.UpdatePublishTime#1",
              (0, a.MD)(M, t),
              T,
              { ePrivilege: 7 },
            );
          });
      })(B || (B = {}));
    },
    77185: (e, t, r) => {
      "use strict";
      r.d(t, { Up: () => Ie });
      var i = r(10059),
        n = r(39087),
        a = r(79545),
        o = r(2260);
      const s = i.Message;
      class l extends s {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            l.prototype.timeline_id || n.aR(l.M()),
            s.initialize(this, e, 0, -1, [5], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            l.sm_m ||
              (l.sm_m = {
                proto: l,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  game_id: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  date_recorded: {
                    n: 3,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  duration_ms: {
                    n: 4,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  recordings: { n: 5, c, r: !0, q: !0 },
                },
              }),
            l.sm_m
          );
        }
        static MBF() {
          return l.sm_mbf || (l.sm_mbf = n.Bh(l.M())), l.sm_mbf;
        }
        toObject(e = !1) {
          return l.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(l.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(l.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new l();
          return l.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(l.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return l.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(l.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return l.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineMetadata";
        }
      }
      class c extends s {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            c.prototype.recording_id || n.aR(c.M()),
            s.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            c.sm_m ||
              (c.sm_m = {
                proto: c,
                fields: {
                  recording_id: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  start_offset_ms: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  duration_ms: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  recording_type: {
                    n: 4,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                  delete_on_cleanup: {
                    n: 5,
                    br: n.FE.readBool,
                    bw: n.Xc.writeBool,
                  },
                  video_manager_clip_id: {
                    n: 6,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  video_manager_video_id: {
                    n: 7,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  cdn_manifest_url: {
                    n: 8,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  file_size: {
                    n: 9,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  recording_zero_timeline_offset_ms: {
                    n: 10,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            c.sm_m
          );
        }
        static MBF() {
          return c.sm_mbf || (c.sm_mbf = n.Bh(c.M())), c.sm_mbf;
        }
        toObject(e = !1) {
          return c.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(c.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(c.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new c();
          return c.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(c.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(c.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return c.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineMetadata_Recording";
        }
      }
      class u extends s {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            u.prototype.game_id || n.aR(u.M()),
            s.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            u.sm_m ||
              (u.sm_m = {
                proto: u,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  rt_created: {
                    n: 2,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  possible_clip: {
                    n: 3,
                    br: n.FE.readInt32,
                    bw: n.Xc.writeInt32,
                  },
                  timeline_id: {
                    n: 4,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  entry_id: {
                    n: 5,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  timeline_offset_ms: {
                    n: 6,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  duration_ms: {
                    n: 7,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  marker_icon: {
                    n: 8,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  marker_title: {
                    n: 9,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  user_marker: { n: 10, br: n.FE.readBool, bw: n.Xc.writeBool },
                },
              }),
            u.sm_m
          );
        }
        static MBF() {
          return u.sm_mbf || (u.sm_mbf = n.Bh(u.M())), u.sm_mbf;
        }
        toObject(e = !1) {
          return u.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(u.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(u.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new u();
          return u.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(u.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(u.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return u.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingTimelineEvent";
        }
      }
      const d = i.Message;
      class m extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return m.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new m();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new m();
          return m.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return m.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetActiveTimelineApps_Request";
        }
      }
      class f extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            f.prototype.apps || n.aR(f.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            f.sm_m ||
              (f.sm_m = {
                proto: f,
                fields: { apps: { n: 1, c: p, r: !0, q: !0 } },
              }),
            f.sm_m
          );
        }
        static MBF() {
          return f.sm_mbf || (f.sm_mbf = n.Bh(f.M())), f.sm_mbf;
        }
        toObject(e = !1) {
          return f.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(f.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(f.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new f();
          return f.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(f.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(f.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return f.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetActiveTimelineApps_Response";
        }
      }
      class p extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            p.prototype.game_id || n.aR(p.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            p.sm_m ||
              (p.sm_m = {
                proto: p,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  most_recent_start_time: {
                    n: 2,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  recording_type: {
                    n: 3,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                  video_duration_seconds: {
                    n: 4,
                    br: n.FE.readDouble,
                    bw: n.Xc.writeDouble,
                  },
                  timeline_duration_seconds: {
                    n: 5,
                    br: n.FE.readDouble,
                    bw: n.Xc.writeDouble,
                  },
                  is_active: { n: 6, br: n.FE.readBool, bw: n.Xc.writeBool },
                  file_size: {
                    n: 7,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            p.sm_m
          );
        }
        static MBF() {
          return p.sm_mbf || (p.sm_mbf = n.Bh(p.M())), p.sm_mbf;
        }
        toObject(e = !1) {
          return p.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(p.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(p.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new p();
          return p.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(p.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(p.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return p.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetActiveTimelineApps_Response_App";
        }
      }
      class g extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            g.prototype.game_id || n.aR(g.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            g.sm_m ||
              (g.sm_m = {
                proto: g,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            g.sm_m
          );
        }
        static MBF() {
          return g.sm_mbf || (g.sm_mbf = n.Bh(g.M())), g.sm_mbf;
        }
        toObject(e = !1) {
          return g.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(g.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(g.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new g();
          return g.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(g.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(g.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return g.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForApp_Request";
        }
      }
      class b extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            b.prototype.timelines || n.aR(b.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            b.sm_m ||
              (b.sm_m = {
                proto: b,
                fields: { timelines: { n: 1, c: l, r: !0, q: !0 } },
              }),
            b.sm_m
          );
        }
        static MBF() {
          return b.sm_mbf || (b.sm_mbf = n.Bh(b.M())), b.sm_mbf;
        }
        toObject(e = !1) {
          return b.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(b.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(b.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new b();
          return b.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(b.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(b.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return b.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForApp_Response";
        }
      }
      class h extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            h.prototype.clip_id || n.aR(h.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            h.sm_m ||
              (h.sm_m = {
                proto: h,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            h.sm_m
          );
        }
        static MBF() {
          return h.sm_mbf || (h.sm_mbf = n.Bh(h.M())), h.sm_mbf;
        }
        toObject(e = !1) {
          return h.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(h.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(h.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new h();
          return h.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(h.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return h.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(h.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return h.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForClip_Request";
        }
      }
      class _ extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            _.prototype.game_id || n.aR(_.M()),
            d.initialize(this, e, 0, -1, [2], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            _.sm_m ||
              (_.sm_m = {
                proto: _,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  timelines: { n: 2, c: l, r: !0, q: !0 },
                  first_timeline_start_offset_ms: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            _.sm_m
          );
        }
        static MBF() {
          return _.sm_mbf || (_.sm_mbf = n.Bh(_.M())), _.sm_mbf;
        }
        toObject(e = !1) {
          return _.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(_.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(_.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new _();
          return _.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(_.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(_.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return _.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTimelinesForClip_Response";
        }
      }
      class S extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return S.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new S();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new S();
          return S.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return S.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetEnoughDiskSpace_Request";
        }
      }
      class v extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            v.prototype.enough_space || n.aR(v.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            v.sm_m ||
              (v.sm_m = {
                proto: v,
                fields: {
                  enough_space: { n: 1, br: n.FE.readBool, bw: n.Xc.writeBool },
                },
              }),
            v.sm_m
          );
        }
        static MBF() {
          return v.sm_mbf || (v.sm_mbf = n.Bh(v.M())), v.sm_mbf;
        }
        toObject(e = !1) {
          return v.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(v.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(v.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new v();
          return v.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(v.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(v.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return v.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetEnoughDiskSpace_Response";
        }
      }
      class y extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return y.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new y();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new y();
          return y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAvailableDiskSpace_Request";
        }
      }
      class M extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            M.prototype.size || n.aR(M.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            M.sm_m ||
              (M.sm_m = {
                proto: M,
                fields: {
                  size: { n: 1, br: n.FE.readDouble, bw: n.Xc.writeDouble },
                },
              }),
            M.sm_m
          );
        }
        static MBF() {
          return M.sm_mbf || (M.sm_mbf = n.Bh(M.M())), M.sm_mbf;
        }
        toObject(e = !1) {
          return M.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(M.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(M.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new M();
          return M.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(M.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(M.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return M.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAvailableDiskSpace_Response";
        }
      }
      class T extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            T.prototype.notification_type || n.aR(T.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            T.sm_m ||
              (T.sm_m = {
                proto: T,
                fields: {
                  notification_type: {
                    n: 1,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                  timeline_id: {
                    n: 2,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  game_id: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  start_time: {
                    n: 4,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  duration_ms: {
                    n: 5,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            T.sm_m
          );
        }
        static MBF() {
          return T.sm_mbf || (T.sm_mbf = n.Bh(T.M())), T.sm_mbf;
        }
        toObject(e = !1) {
          return T.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(T.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(T.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new T();
          return T.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(T.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(T.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return T.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TimelineChanged_Notification";
        }
      }
      class B extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            B.prototype.notification_type || n.aR(B.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            B.sm_m ||
              (B.sm_m = {
                proto: B,
                fields: {
                  notification_type: {
                    n: 1,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                  timeline_id: {
                    n: 2,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  game_id: {
                    n: 4,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  session_id: {
                    n: 5,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  start_offset: {
                    n: 6,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  duration_ms: {
                    n: 7,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  recording_type: {
                    n: 8,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                },
              }),
            B.sm_m
          );
        }
        static MBF() {
          return B.sm_mbf || (B.sm_mbf = n.Bh(B.M())), B.sm_mbf;
        }
        toObject(e = !1) {
          return B.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(B.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(B.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new B();
          return B.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(B.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return B.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(B.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return B.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_RecordingSessionChanged_Notification";
        }
      }
      class R extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            R.prototype.timeline_id || n.aR(R.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            R.sm_m ||
              (R.sm_m = {
                proto: R,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  entry_id: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  time: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  type: { n: 4, br: n.FE.readEnum, bw: n.Xc.writeEnum },
                  game_mode: { n: 5, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                  range_id: { n: 6, br: n.FE.readString, bw: n.Xc.writeString },
                  range_title: {
                    n: 7,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  range_duration: {
                    n: 8,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  range_possible_clip: {
                    n: 9,
                    br: n.FE.readInt32,
                    bw: n.Xc.writeInt32,
                  },
                  timestamp_title: {
                    n: 10,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  marker_icon: {
                    n: 11,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  marker_title: {
                    n: 12,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  marker_description: {
                    n: 13,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  marker_priority: {
                    n: 14,
                    br: n.FE.readInt32,
                    bw: n.Xc.writeInt32,
                  },
                  screenshot_handle: {
                    n: 15,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  achievement_name: {
                    n: 16,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                },
              }),
            R.sm_m
          );
        }
        static MBF() {
          return R.sm_mbf || (R.sm_mbf = n.Bh(R.M())), R.sm_mbf;
        }
        toObject(e = !1) {
          return R.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(R.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(R.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new R();
          return R.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(R.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return R.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(R.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return R.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CTimelineEntry";
        }
      }
      class E extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            E.prototype.entry || n.aR(E.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            E.sm_m ||
              (E.sm_m = { proto: E, fields: { entry: { n: 1, c: R } } }),
            E.sm_m
          );
        }
        static MBF() {
          return E.sm_mbf || (E.sm_mbf = n.Bh(E.M())), E.sm_mbf;
        }
        toObject(e = !1) {
          return E.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(E.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(E.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new E();
          return E.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(E.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return E.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(E.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return E.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_TimelineEntryChanged_Notification";
        }
      }
      class w extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return w.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new w();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new w();
          return w.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return w.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return w.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_LowDiskSpace_Notification";
        }
      }
      class C extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            C.prototype.game_id || n.aR(C.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            C.sm_m ||
              (C.sm_m = {
                proto: C,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            C.sm_m
          );
        }
        static MBF() {
          return C.sm_mbf || (C.sm_mbf = n.Bh(C.M())), C.sm_mbf;
        }
        toObject(e = !1) {
          return C.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(C.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(C.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new C();
          return C.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(C.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return C.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(C.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return C.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_PostGameHighlightsChanged_Notification";
        }
      }
      class G extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            G.prototype.clip_id || n.aR(G.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            G.sm_m ||
              (G.sm_m = {
                proto: G,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                  game_id: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  duration_ms: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  date_recorded: {
                    n: 4,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  start_timeline_id: {
                    n: 5,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  start_offset_ms: {
                    n: 6,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  published_file_id: {
                    n: 7,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  file_size: {
                    n: 8,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  name: { n: 9, br: n.FE.readString, bw: n.Xc.writeString },
                  date_clipped: {
                    n: 10,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  temporary: { n: 11, br: n.FE.readBool, bw: n.Xc.writeBool },
                  original_device: {
                    n: 12,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  original_gaming_device_type: {
                    n: 13,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  date_downloaded: {
                    n: 14,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  thumbnail_url: {
                    n: 15,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  thumbnail_width: {
                    n: 16,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  thumbnail_height: {
                    n: 17,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                },
              }),
            G.sm_m
          );
        }
        static MBF() {
          return G.sm_mbf || (G.sm_mbf = n.Bh(G.M())), G.sm_mbf;
        }
        toObject(e = !1) {
          return G.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(G.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(G.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new G();
          return G.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(G.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return G.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(G.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return G.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipSummary";
        }
      }
      class P extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            P.prototype.game_id || n.aR(P.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            P.sm_m ||
              (P.sm_m = {
                proto: P,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  start: { n: 2, c: I },
                  end: { n: 3, c: I },
                  name: { n: 4, br: n.FE.readString, bw: n.Xc.writeString },
                  src_clip_id: {
                    n: 5,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  temporary: { n: 6, br: n.FE.readBool, bw: n.Xc.writeBool },
                },
              }),
            P.sm_m
          );
        }
        static MBF() {
          return P.sm_mbf || (P.sm_mbf = n.Bh(P.M())), P.sm_mbf;
        }
        toObject(e = !1) {
          return P.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(P.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(P.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new P();
          return P.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(P.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return P.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(P.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return P.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Request";
        }
      }
      class I extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            I.prototype.timeline_id || n.aR(I.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            I.sm_m ||
              (I.sm_m = {
                proto: I,
                fields: {
                  timeline_id: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  offset_ms: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            I.sm_m
          );
        }
        static MBF() {
          return I.sm_mbf || (I.sm_mbf = n.Bh(I.M())), I.sm_mbf;
        }
        toObject(e = !1) {
          return I.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(I.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(I.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new I();
          return I.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(I.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return I.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(I.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return I.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Request_Position";
        }
      }
      class D extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            D.prototype.summary || n.aR(D.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            D.sm_m ||
              (D.sm_m = { proto: D, fields: { summary: { n: 1, c: G } } }),
            D.sm_m
          );
        }
        static MBF() {
          return D.sm_mbf || (D.sm_mbf = n.Bh(D.M())), D.sm_mbf;
        }
        toObject(e = !1) {
          return D.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(D.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(D.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new D();
          return D.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(D.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return D.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(D.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return D.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SaveClip_Response";
        }
      }
      class O extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            O.prototype.clip_id || n.aR(O.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            O.sm_m ||
              (O.sm_m = {
                proto: O,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            O.sm_m
          );
        }
        static MBF() {
          return O.sm_mbf || (O.sm_mbf = n.Bh(O.M())), O.sm_mbf;
        }
        toObject(e = !1) {
          return O.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(O.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(O.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new O();
          return O.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(O.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return O.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(O.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return O.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteClip_Request";
        }
      }
      class F extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return F.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new F();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new F();
          return F.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return F.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return F.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_DeleteClip_Response";
        }
      }
      class z extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            z.prototype.bitrate_kbps || n.aR(z.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            z.sm_m ||
              (z.sm_m = {
                proto: z,
                fields: {
                  bitrate_kbps: {
                    n: 1,
                    br: n.FE.readInt32,
                    bw: n.Xc.writeInt32,
                  },
                  width: { n: 2, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                  height: { n: 3, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                  frames_per_second: {
                    n: 4,
                    br: n.FE.readInt32,
                    bw: n.Xc.writeInt32,
                  },
                },
              }),
            z.sm_m
          );
        }
        static MBF() {
          return z.sm_mbf || (z.sm_mbf = n.Bh(z.M())), z.sm_mbf;
        }
        toObject(e = !1) {
          return z.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(z.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(z.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new z();
          return z.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(z.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return z.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(z.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return z.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Settings";
        }
      }
      class x extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            x.prototype.clip_id || n.aR(x.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            x.sm_m ||
              (x.sm_m = {
                proto: x,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                  export_mp4_path: {
                    n: 2,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  settings: { n: 3, c: z },
                },
              }),
            x.sm_m
          );
        }
        static MBF() {
          return x.sm_mbf || (x.sm_mbf = n.Bh(x.M())), x.sm_mbf;
        }
        toObject(e = !1) {
          return x.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(x.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(x.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new x();
          return x.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(x.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return x.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(x.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return x.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Request";
        }
      }
      class A extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return A.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new A();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new A();
          return A.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return A.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return A.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportClip_Response";
        }
      }
      class W extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            W.prototype.clip_id || n.aR(W.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            W.sm_m ||
              (W.sm_m = {
                proto: W,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                  title: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                  desc: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                  visibility: { n: 4, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                },
              }),
            W.sm_m
          );
        }
        static MBF() {
          return W.sm_mbf || (W.sm_mbf = n.Bh(W.M())), W.sm_mbf;
        }
        toObject(e = !1) {
          return W.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(W.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(W.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new W();
          return W.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(W.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return W.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(W.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return W.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadClipToSteam_Request";
        }
      }
      class k extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            k.prototype.summary || n.aR(k.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            k.sm_m ||
              (k.sm_m = { proto: k, fields: { summary: { n: 1, c: G } } }),
            k.sm_m
          );
        }
        static MBF() {
          return k.sm_mbf || (k.sm_mbf = n.Bh(k.M())), k.sm_mbf;
        }
        toObject(e = !1) {
          return k.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(k.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(k.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new k();
          return k.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(k.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return k.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(k.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return k.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadClipToSteam_Response";
        }
      }
      class N extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            N.prototype.clip_id || n.aR(N.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            N.sm_m ||
              (N.sm_m = {
                proto: N,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            N.sm_m
          );
        }
        static MBF() {
          return N.sm_mbf || (N.sm_mbf = n.Bh(N.M())), N.sm_mbf;
        }
        toObject(e = !1) {
          return N.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(N.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(N.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new N();
          return N.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(N.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return N.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(N.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return N.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ZipClip_Request";
        }
      }
      class L extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            L.prototype.zip_path || n.aR(L.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            L.sm_m ||
              (L.sm_m = {
                proto: L,
                fields: {
                  zip_path: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            L.sm_m
          );
        }
        static MBF() {
          return L.sm_mbf || (L.sm_mbf = n.Bh(L.M())), L.sm_mbf;
        }
        toObject(e = !1) {
          return L.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(L.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(L.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new L();
          return L.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(L.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return L.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(L.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return L.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ZipClip_Response";
        }
      }
      class X extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            X.prototype.game_id || n.aR(X.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            X.sm_m ||
              (X.sm_m = {
                proto: X,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  created_after: {
                    n: 2,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  include_temporary: {
                    n: 3,
                    br: n.FE.readBool,
                    bw: n.Xc.writeBool,
                  },
                },
              }),
            X.sm_m
          );
        }
        static MBF() {
          return X.sm_mbf || (X.sm_mbf = n.Bh(X.M())), X.sm_mbf;
        }
        toObject(e = !1) {
          return X.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(X.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(X.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new X();
          return X.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(X.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return X.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(X.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return X.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetClips_Request";
        }
      }
      class U extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            U.prototype.clip || n.aR(U.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            U.sm_m ||
              (U.sm_m = {
                proto: U,
                fields: { clip: { n: 1, c: G, r: !0, q: !0 } },
              }),
            U.sm_m
          );
        }
        static MBF() {
          return U.sm_mbf || (U.sm_mbf = n.Bh(U.M())), U.sm_mbf;
        }
        toObject(e = !1) {
          return U.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(U.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(U.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new U();
          return U.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(U.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return U.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(U.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return U.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetClips_Response";
        }
      }
      class j extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            j.prototype.game_id || n.aR(j.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            j.sm_m ||
              (j.sm_m = {
                proto: j,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  created_after: {
                    n: 2,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                },
              }),
            j.sm_m
          );
        }
        static MBF() {
          return j.sm_mbf || (j.sm_mbf = n.Bh(j.M())), j.sm_mbf;
        }
        toObject(e = !1) {
          return j.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(j.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(j.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new j();
          return j.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(j.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return j.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(j.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return j.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAndTrimPostGameHighlights_Request";
        }
      }
      class H extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            H.prototype.events || n.aR(H.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            H.sm_m ||
              (H.sm_m = {
                proto: H,
                fields: { events: { n: 1, c: u, r: !0, q: !0 } },
              }),
            H.sm_m
          );
        }
        static MBF() {
          return H.sm_mbf || (H.sm_mbf = n.Bh(H.M())), H.sm_mbf;
        }
        toObject(e = !1) {
          return H.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(H.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(H.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new H();
          return H.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(H.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return H.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(H.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return H.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetAndTrimPostGameHighlights_Response";
        }
      }
      class V extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            V.prototype.game_id || n.aR(V.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            V.sm_m ||
              (V.sm_m = {
                proto: V,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  entry: { n: 2, c: R },
                  clip_id: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            V.sm_m
          );
        }
        static MBF() {
          return V.sm_mbf || (V.sm_mbf = n.Bh(V.M())), V.sm_mbf;
        }
        toObject(e = !1) {
          return V.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(V.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(V.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new V();
          return V.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(V.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return V.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(V.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return V.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserAddTimelineEntry_Request";
        }
      }
      class q extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            q.prototype.entry_id || n.aR(q.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            q.sm_m ||
              (q.sm_m = {
                proto: q,
                fields: {
                  entry_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            q.sm_m
          );
        }
        static MBF() {
          return q.sm_mbf || (q.sm_mbf = n.Bh(q.M())), q.sm_mbf;
        }
        toObject(e = !1) {
          return q.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(q.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(q.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new q();
          return q.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(q.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return q.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(q.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return q.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserAddTimelineEntry_Response";
        }
      }
      class Z extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Z.prototype.game_id || n.aR(Z.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Z.sm_m ||
              (Z.sm_m = {
                proto: Z,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  entry: { n: 2, c: R },
                  clip_id: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            Z.sm_m
          );
        }
        static MBF() {
          return Z.sm_mbf || (Z.sm_mbf = n.Bh(Z.M())), Z.sm_mbf;
        }
        toObject(e = !1) {
          return Z.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Z.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Z.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Z();
          return Z.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Z.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Z.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Z.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Z.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserUpdateTimelineEntry_Request";
        }
      }
      class Y extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Y.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Y();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Y();
          return Y.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Y.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Y.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserUpdateTimelineEntry_Response";
        }
      }
      class J extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            J.prototype.game_id || n.aR(J.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            J.sm_m ||
              (J.sm_m = {
                proto: J,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  timeline_id: {
                    n: 2,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  entry_id: {
                    n: 3,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                  clip_id: { n: 4, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            J.sm_m
          );
        }
        static MBF() {
          return J.sm_mbf || (J.sm_mbf = n.Bh(J.M())), J.sm_mbf;
        }
        toObject(e = !1) {
          return J.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(J.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(J.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new J();
          return J.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(J.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return J.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(J.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return J.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserRemoveTimelineEntry_Request";
        }
      }
      class K extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return K.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new K();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new K();
          return K.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return K.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return K.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UserRemoveTimelineEntry_Response";
        }
      }
      class Q extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Q.prototype.game_ids || n.aR(Q.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Q.sm_m ||
              (Q.sm_m = {
                proto: Q,
                fields: {
                  game_ids: {
                    n: 1,
                    r: !0,
                    q: !0,
                    br: n.FE.readUint64String,
                    pbr: n.FE.readPackedUint64String,
                    bw: n.Xc.writeRepeatedUint64String,
                  },
                },
              }),
            Q.sm_m
          );
        }
        static MBF() {
          return Q.sm_mbf || (Q.sm_mbf = n.Bh(Q.M())), Q.sm_mbf;
        }
        toObject(e = !1) {
          return Q.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Q.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Q.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Q();
          return Q.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Q.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Q.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Q.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Q.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ManuallyDeleteRecordingsForApps_Request";
        }
      }
      class $ extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return $.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new $();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new $();
          return $.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return $.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return $.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ManuallyDeleteRecordingsForApps_Response";
        }
      }
      class ee extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ee.prototype.folder_path || n.aR(ee.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ee.sm_m ||
              (ee.sm_m = {
                proto: ee,
                fields: {
                  folder_path: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  type: { n: 2, br: n.FE.readEnum, bw: n.Xc.writeEnum },
                },
              }),
            ee.sm_m
          );
        }
        static MBF() {
          return ee.sm_mbf || (ee.sm_mbf = n.Bh(ee.M())), ee.sm_mbf;
        }
        toObject(e = !1) {
          return ee.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ee.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ee.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ee();
          return ee.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ee.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ee.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ee.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ee.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTotalDiskSpaceUsage_Request";
        }
      }
      class te extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            te.prototype.size || n.aR(te.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            te.sm_m ||
              (te.sm_m = {
                proto: te,
                fields: {
                  size: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            te.sm_m
          );
        }
        static MBF() {
          return te.sm_mbf || (te.sm_mbf = n.Bh(te.M())), te.sm_mbf;
        }
        toObject(e = !1) {
          return te.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(te.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(te.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new te();
          return te.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(te.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return te.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(te.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return te.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetTotalDiskSpaceUsage_Response";
        }
      }
      class re extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            re.prototype.recording_id || n.aR(re.M()),
            d.initialize(this, e, 0, -1, [4], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            re.sm_m ||
              (re.sm_m = {
                proto: re,
                fields: {
                  recording_id: {
                    n: 1,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  clip_id: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                  timeline_id: {
                    n: 7,
                    br: n.FE.readString,
                    bw: n.Xc.writeString,
                  },
                  start_offset_us: {
                    n: 4,
                    r: !0,
                    q: !0,
                    br: n.FE.readInt64String,
                    pbr: n.FE.readPackedInt64String,
                    bw: n.Xc.writeRepeatedInt64String,
                  },
                  major_axis: {
                    n: 5,
                    d: 512,
                    br: n.FE.readUint32,
                    bw: n.Xc.writeUint32,
                  },
                  time_precision: {
                    n: 6,
                    d: 0,
                    br: n.FE.readEnum,
                    bw: n.Xc.writeEnum,
                  },
                },
              }),
            re.sm_m
          );
        }
        static MBF() {
          return re.sm_mbf || (re.sm_mbf = n.Bh(re.M())), re.sm_mbf;
        }
        toObject(e = !1) {
          return re.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(re.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(re.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new re();
          return re.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(re.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return re.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(re.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return re.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Request";
        }
      }
      class ie extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ie.prototype.thumbnails || n.aR(ie.M()),
            d.initialize(this, e, 0, -1, [1], null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ie.sm_m ||
              (ie.sm_m = {
                proto: ie,
                fields: { thumbnails: { n: 1, c: ne, r: !0, q: !0 } },
              }),
            ie.sm_m
          );
        }
        static MBF() {
          return ie.sm_mbf || (ie.sm_mbf = n.Bh(ie.M())), ie.sm_mbf;
        }
        toObject(e = !1) {
          return ie.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ie.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ie.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ie();
          return ie.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ie.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ie.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ie.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ie.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Response";
        }
      }
      class ne extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ne.prototype.image_data || n.aR(ne.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ne.sm_m ||
              (ne.sm_m = {
                proto: ne,
                fields: {
                  image_data: { n: 1, br: n.FE.readBytes, bw: n.Xc.writeBytes },
                  width: { n: 2, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  height: { n: 3, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                },
              }),
            ne.sm_m
          );
        }
        static MBF() {
          return ne.sm_mbf || (ne.sm_mbf = n.Bh(ne.M())), ne.sm_mbf;
        }
        toObject(e = !1) {
          return ne.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ne.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ne.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ne();
          return ne.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ne.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ne.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ne.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ne.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetThumbnails_Response_Thumbnail";
        }
      }
      class ae extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ae.prototype.game_id || n.aR(ae.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ae.sm_m ||
              (ae.sm_m = {
                proto: ae,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            ae.sm_m
          );
        }
        static MBF() {
          return ae.sm_mbf || (ae.sm_mbf = n.Bh(ae.M())), ae.sm_mbf;
        }
        toObject(e = !1) {
          return ae.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ae.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ae.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ae();
          return ae.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ae.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ae.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ae.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ae.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StartRecording_Request";
        }
      }
      class oe extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return oe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new oe();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new oe();
          return oe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return oe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return oe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StartRecording_Response";
        }
      }
      class se extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            se.prototype.game_id || n.aR(se.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            se.sm_m ||
              (se.sm_m = {
                proto: se,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            se.sm_m
          );
        }
        static MBF() {
          return se.sm_mbf || (se.sm_mbf = n.Bh(se.M())), se.sm_mbf;
        }
        toObject(e = !1) {
          return se.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(se.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(se.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new se();
          return se.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(se.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return se.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(se.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return se.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StopRecording_Request";
        }
      }
      class le extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            le.prototype.summary || n.aR(le.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            le.sm_m ||
              (le.sm_m = { proto: le, fields: { summary: { n: 1, c: G } } }),
            le.sm_m
          );
        }
        static MBF() {
          return le.sm_mbf || (le.sm_mbf = n.Bh(le.M())), le.sm_mbf;
        }
        toObject(e = !1) {
          return le.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(le.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(le.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new le();
          return le.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(le.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return le.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(le.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return le.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_StopRecording_Response";
        }
      }
      class ce extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ce.prototype.game_id || n.aR(ce.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ce.sm_m ||
              (ce.sm_m = {
                proto: ce,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            ce.sm_m
          );
        }
        static MBF() {
          return ce.sm_mbf || (ce.sm_mbf = n.Bh(ce.M())), ce.sm_mbf;
        }
        toObject(e = !1) {
          return ce.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ce.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ce.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ce();
          return ce.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ce.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ce.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ce.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ce.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetRecordingSize_Request";
        }
      }
      class ue extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ue.prototype.file_size || n.aR(ue.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ue.sm_m ||
              (ue.sm_m = {
                proto: ue,
                fields: {
                  file_size: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            ue.sm_m
          );
        }
        static MBF() {
          return ue.sm_mbf || (ue.sm_mbf = n.Bh(ue.M())), ue.sm_mbf;
        }
        toObject(e = !1) {
          return ue.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ue.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ue.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ue();
          return ue.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ue.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ue.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ue.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ue.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetRecordingSize_Response";
        }
      }
      class de extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return de.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new de();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new de();
          return de.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return de.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return de.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CleanupBackgroundRecordings_Request";
        }
      }
      class me extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return me.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new me();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new me();
          return me.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return me.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return me.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_CleanupBackgroundRecordings_Response";
        }
      }
      class fe extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return fe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new fe();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new fe();
          return fe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return fe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return fe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPlatformCapabilities_Request";
        }
      }
      class pe extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            pe.prototype.per_process_audio_capture || n.aR(pe.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            pe.sm_m ||
              (pe.sm_m = {
                proto: pe,
                fields: {
                  per_process_audio_capture: {
                    n: 1,
                    br: n.FE.readBool,
                    bw: n.Xc.writeBool,
                  },
                },
              }),
            pe.sm_m
          );
        }
        static MBF() {
          return pe.sm_mbf || (pe.sm_mbf = n.Bh(pe.M())), pe.sm_mbf;
        }
        toObject(e = !1) {
          return pe.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(pe.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(pe.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new pe();
          return pe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(pe.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return pe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(pe.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return pe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_GetPlatformCapabilities_Response";
        }
      }
      class ge extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ge.prototype.summary || n.aR(ge.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ge.sm_m ||
              (ge.sm_m = { proto: ge, fields: { summary: { n: 1, c: G } } }),
            ge.sm_m
          );
        }
        static MBF() {
          return ge.sm_mbf || (ge.sm_mbf = n.Bh(ge.M())), ge.sm_mbf;
        }
        toObject(e = !1) {
          return ge.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ge.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ge.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ge();
          return ge.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ge.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ge.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ge.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ge.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipCreated_Notification";
        }
      }
      class be extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            be.prototype.clip_id || n.aR(be.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            be.sm_m ||
              (be.sm_m = {
                proto: be,
                fields: {
                  clip_id: { n: 1, br: n.FE.readString, bw: n.Xc.writeString },
                  game_id: {
                    n: 2,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            be.sm_m
          );
        }
        static MBF() {
          return be.sm_mbf || (be.sm_mbf = n.Bh(be.M())), be.sm_mbf;
        }
        toObject(e = !1) {
          return be.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(be.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(be.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new be();
          return be.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(be.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return be.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(be.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return be.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ClipDeleted_Notification";
        }
      }
      class he extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            he.prototype.progress || n.aR(he.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            he.sm_m ||
              (he.sm_m = {
                proto: he,
                fields: {
                  progress: { n: 1, br: n.FE.readFloat, bw: n.Xc.writeFloat },
                  clip_id: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                  eresult: { n: 3, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                },
              }),
            he.sm_m
          );
        }
        static MBF() {
          return he.sm_mbf || (he.sm_mbf = n.Bh(he.M())), he.sm_mbf;
        }
        toObject(e = !1) {
          return he.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(he.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(he.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new he();
          return he.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(he.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return he.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(he.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return he.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_ExportProgress_Notification";
        }
      }
      class _e extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            _e.prototype.progress || n.aR(_e.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            _e.sm_m ||
              (_e.sm_m = {
                proto: _e,
                fields: {
                  progress: { n: 1, br: n.FE.readFloat, bw: n.Xc.writeFloat },
                  clip_id: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                  eresult: { n: 3, br: n.FE.readInt32, bw: n.Xc.writeInt32 },
                },
              }),
            _e.sm_m
          );
        }
        static MBF() {
          return _e.sm_mbf || (_e.sm_mbf = n.Bh(_e.M())), _e.sm_mbf;
        }
        toObject(e = !1) {
          return _e.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(_e.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(_e.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new _e();
          return _e.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(_e.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return _e.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(_e.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return _e.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_UploadProgress_Notification";
        }
      }
      class Se extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Se.prototype.game_id || n.aR(Se.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Se.sm_m ||
              (Se.sm_m = {
                proto: Se,
                fields: {
                  game_id: {
                    n: 1,
                    br: n.FE.readUint64String,
                    bw: n.Xc.writeUint64String,
                  },
                },
              }),
            Se.sm_m
          );
        }
        static MBF() {
          return Se.sm_mbf || (Se.sm_mbf = n.Bh(Se.M())), Se.sm_mbf;
        }
        toObject(e = !1) {
          return Se.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Se.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Se.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Se();
          return Se.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Se.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Se.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Se.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Se.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SwitchBackgroundRecordingGame_Request";
        }
      }
      class ve extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return ve.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new ve();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ve();
          return ve.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ve.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ve.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecording_SwitchBackgroundRecordingGame_Response";
        }
      }
      class ye extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            ye.prototype.appid || n.aR(ye.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            ye.sm_m ||
              (ye.sm_m = {
                proto: ye,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  icon: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                  title: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                  desc: { n: 4, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            ye.sm_m
          );
        }
        static MBF() {
          return ye.sm_mbf || (ye.sm_mbf = n.Bh(ye.M())), ye.sm_mbf;
        }
        toObject(e = !1) {
          return ye.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(ye.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(ye.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new ye();
          return ye.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(ye.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return ye.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(ye.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return ye.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineHighlightMarker_Request";
        }
      }
      class Me extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Me.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Me();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Me();
          return Me.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Me.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Me.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineHighlightMarker_Response";
        }
      }
      class Te extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Te.prototype.appid || n.aR(Te.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Te.sm_m ||
              (Te.sm_m = {
                proto: Te,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  title: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            Te.sm_m
          );
        }
        static MBF() {
          return Te.sm_mbf || (Te.sm_mbf = n.Bh(Te.M())), Te.sm_mbf;
        }
        toObject(e = !1) {
          return Te.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Te.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Te.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Te();
          return Te.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Te.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Te.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Te.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Te.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineTimestamp_Request";
        }
      }
      class Be extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Be.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Be();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Be();
          return Be.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Be.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Be.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineTimestamp_Response";
        }
      }
      class Re extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Re.prototype.appid || n.aR(Re.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Re.sm_m ||
              (Re.sm_m = {
                proto: Re,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  id: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                  title: { n: 3, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            Re.sm_m
          );
        }
        static MBF() {
          return Re.sm_mbf || (Re.sm_mbf = n.Bh(Re.M())), Re.sm_mbf;
        }
        toObject(e = !1) {
          return Re.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Re.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Re.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Re();
          return Re.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Re.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Re.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Re.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Re.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineRangeStart_Request";
        }
      }
      class Ee extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Ee.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Ee();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Ee();
          return Ee.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Ee.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Ee.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineRangeStart_Response";
        }
      }
      class we extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            we.prototype.appid || n.aR(we.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            we.sm_m ||
              (we.sm_m = {
                proto: we,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  id: { n: 2, br: n.FE.readString, bw: n.Xc.writeString },
                },
              }),
            we.sm_m
          );
        }
        static MBF() {
          return we.sm_mbf || (we.sm_mbf = n.Bh(we.M())), we.sm_mbf;
        }
        toObject(e = !1) {
          return we.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(we.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(we.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new we();
          return we.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(we.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return we.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(we.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return we.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineRangeEnd_Request";
        }
      }
      class Ce extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Ce.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Ce();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Ce();
          return Ce.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Ce.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Ce.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_AddTimelineRangeEnd_Response";
        }
      }
      class Ge extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(),
            Ge.prototype.appid || n.aR(Ge.M()),
            d.initialize(this, e, 0, -1, void 0, null);
        }
        static sm_m;
        static sm_mbf;
        static M() {
          return (
            Ge.sm_m ||
              (Ge.sm_m = {
                proto: Ge,
                fields: {
                  appid: { n: 1, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                  mode: { n: 2, br: n.FE.readUint32, bw: n.Xc.writeUint32 },
                },
              }),
            Ge.sm_m
          );
        }
        static MBF() {
          return Ge.sm_mbf || (Ge.sm_mbf = n.Bh(Ge.M())), Ge.sm_mbf;
        }
        toObject(e = !1) {
          return Ge.toObject(e, this);
        }
        static toObject(e, t) {
          return n.TA(Ge.M(), e, t);
        }
        static fromObject(e) {
          return n.aD(Ge.M(), e);
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Ge();
          return Ge.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return n.F(Ge.MBF(), e, t);
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Ge.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {
          n.l2(Ge.M(), e, t);
        }
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Ge.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_SetTimelineGameMode_Request";
        }
      }
      class Pe extends d {
        static ImplementsStaticInterface() {}
        constructor(e = null) {
          super(), d.initialize(this, e, 0, -1, void 0, null);
        }
        toObject(e = !1) {
          return Pe.toObject(e, this);
        }
        static toObject(e, t) {
          return e ? { $jspbMessageInstance: t } : {};
        }
        static fromObject(e) {
          return new Pe();
        }
        static deserializeBinary(e) {
          let t = new i.BinaryReader(e),
            r = new Pe();
          return Pe.deserializeBinaryFromReader(r, t);
        }
        static deserializeBinaryFromReader(e, t) {
          return e;
        }
        serializeBinary() {
          var e = new i.BinaryWriter();
          return Pe.serializeBinaryToWriter(this, e), e.getResultBuffer();
        }
        static serializeBinaryToWriter(e, t) {}
        serializeBase64String() {
          var e = new i.BinaryWriter();
          return Pe.serializeBinaryToWriter(this, e), e.getResultBase64String();
        }
        getClassName() {
          return "CGameRecordingDebug_SetTimelineGameMode_Response";
        }
      }
      var Ie, De;
      !(function (e) {
        (e.GetActiveTimelineAppsHandler = {
          name: "GameRecording.GetActiveTimelineApps#1",
          request: m,
          response: f,
        }),
          (e.GetActiveTimelineApps = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetActiveTimelineApps#1",
                  (0, a.MD)(m, e),
                  f,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetActiveTimelineApps = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetActiveTimelineApps#1",
                  (0, a.MD)(m, e),
                  f,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTimelinesForAppHandler = {
            name: "GameRecording.GetTimelinesForApp#1",
            request: g,
            response: b,
          }),
          (e.GetTimelinesForApp = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForApp#1",
                  (0, a.MD)(g, e),
                  b,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTimelinesForApp = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForApp#1",
                  (0, a.MD)(g, e),
                  b,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTimelinesForClipHandler = {
            name: "GameRecording.GetTimelinesForClip#1",
            request: h,
            response: _,
          }),
          (e.GetTimelinesForClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForClip#1",
                  (0, a.MD)(h, e),
                  _,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTimelinesForClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTimelinesForClip#1",
                  (0, a.MD)(h, e),
                  _,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetEnoughDiskSpaceHandler = {
            name: "GameRecording.GetEnoughDiskSpace#1",
            request: S,
            response: v,
          }),
          (e.GetEnoughDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetEnoughDiskSpace#1",
                  (0, a.MD)(S, e),
                  v,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetEnoughDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetEnoughDiskSpace#1",
                  (0, a.MD)(S, e),
                  v,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetAvailableDiskSpaceHandler = {
            name: "GameRecording.GetAvailableDiskSpace#1",
            request: y,
            response: M,
          }),
          (e.GetAvailableDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAvailableDiskSpace#1",
                  (0, a.MD)(y, e),
                  M,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetAvailableDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAvailableDiskSpace#1",
                  (0, a.MD)(y, e),
                  M,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SaveClipHandler = {
            name: "GameRecording.SaveClip#1",
            request: P,
            response: D,
          }),
          (e.SaveClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.SaveClip#1", (0, a.MD)(P, e), D, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgSaveClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.SaveClip#1", (0, a.MD)(P, e), D, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.DeleteClipHandler = {
            name: "GameRecording.DeleteClip#1",
            request: O,
            response: F,
          }),
          (e.DeleteClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.DeleteClip#1", (0, a.MD)(O, e), F, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgDeleteClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.DeleteClip#1", (0, a.MD)(O, e), F, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.GetClipsHandler = {
            name: "GameRecording.GetClips#1",
            request: X,
            response: U,
          }),
          (e.GetClips = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetClips#1", (0, a.MD)(X, e), U, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgGetClips = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.GetClips#1", (0, a.MD)(X, e), U, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.UploadClipToSteamHandler = {
            name: "GameRecording.UploadClipToSteam#1",
            request: W,
            response: k,
          }),
          (e.UploadClipToSteam = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UploadClipToSteam#1",
                  (0, a.MD)(W, e),
                  k,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUploadClipToSteam = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UploadClipToSteam#1",
                  (0, a.MD)(W, e),
                  k,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.ExportClipHandler = {
            name: "GameRecording.ExportClip#1",
            request: x,
            response: A,
          }),
          (e.ExportClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ExportClip#1", (0, a.MD)(x, e), A, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgExportClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ExportClip#1", (0, a.MD)(x, e), A, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.ZipClipHandler = {
            name: "GameRecording.ZipClip#1",
            request: N,
            response: L,
          }),
          (e.ZipClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ZipClip#1", (0, a.MD)(N, e), L, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.SendMsgZipClip = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg("GameRecording.ZipClip#1", (0, a.MD)(N, e), L, {
                  ePrivilege: 1,
                  eClientExecutionSite: 1,
                });
          }),
          (e.StartRecordingHandler = {
            name: "GameRecording.StartRecording#1",
            request: ae,
            response: oe,
          }),
          (e.StartRecording = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StartRecording#1",
                  (0, a.MD)(ae, e),
                  oe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgStartRecording = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StartRecording#1",
                  (0, a.MD)(ae, e),
                  oe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.StopRecordingHandler = {
            name: "GameRecording.StopRecording#1",
            request: se,
            response: le,
          }),
          (e.StopRecording = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StopRecording#1",
                  (0, a.MD)(se, e),
                  le,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgStopRecording = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.StopRecording#1",
                  (0, a.MD)(se, e),
                  le,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetBackgroundRecordingFileSizeHandler = {
            name: "GameRecording.GetBackgroundRecordingFileSize#1",
            request: ce,
            response: ue,
          }),
          (e.GetBackgroundRecordingFileSize = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetBackgroundRecordingFileSize#1",
                  (0, a.MD)(ce, e),
                  ue,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetBackgroundRecordingFileSize = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetBackgroundRecordingFileSize#1",
                  (0, a.MD)(ce, e),
                  ue,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.CleanupBackgroundRecordingsHandler = {
            name: "GameRecording.CleanupBackgroundRecordings#1",
            request: de,
            response: me,
          }),
          (e.CleanupBackgroundRecordings = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.CleanupBackgroundRecordings#1",
                  (0, a.MD)(de, e),
                  me,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgCleanupBackgroundRecordings = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.CleanupBackgroundRecordings#1",
                  (0, a.MD)(de, e),
                  me,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetAndTrimPostGameHighlightsHandler = {
            name: "GameRecording.GetAndTrimPostGameHighlights#1",
            request: j,
            response: H,
          }),
          (e.GetAndTrimPostGameHighlights = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAndTrimPostGameHighlights#1",
                  (0, a.MD)(j, e),
                  H,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetAndTrimPostGameHighlights = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetAndTrimPostGameHighlights#1",
                  (0, a.MD)(j, e),
                  H,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetThumbnailsHandler = {
            name: "GameRecording.GetThumbnails#1",
            request: re,
            response: ie,
          }),
          (e.GetThumbnails = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetThumbnails#1",
                  (0, a.MD)(re, e),
                  ie,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetThumbnails = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetThumbnails#1",
                  (0, a.MD)(re, e),
                  ie,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetPlatformCapabilitiesHandler = {
            name: "GameRecording.GetPlatformCapabilities#1",
            request: fe,
            response: pe,
          }),
          (e.GetPlatformCapabilities = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPlatformCapabilities#1",
                  (0, a.MD)(fe, e),
                  pe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetPlatformCapabilities = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetPlatformCapabilities#1",
                  (0, a.MD)(fe, e),
                  pe,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyTimelineChangedHandler = {
            name: "GameRecording.NotifyTimelineChanged#1",
            request: T,
          }),
          (e.RegisterForNotifyTimelineChanged = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyTimelineChangedHandler,
                  t,
                );
          }),
          (e.NotifyTimelineChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineChanged#1",
                  (0, a.MD)(T, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyTimelineChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineChanged#1",
                  (0, a.MD)(T, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyRecordingSessionChangedHandler = {
            name: "GameRecording.NotifyRecordingSessionChanged#1",
            request: B,
          }),
          (e.RegisterForNotifyRecordingSessionChanged = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyRecordingSessionChangedHandler,
                  t,
                );
          }),
          (e.NotifyRecordingSessionChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyRecordingSessionChanged#1",
                  (0, a.MD)(B, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyRecordingSessionChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyRecordingSessionChanged#1",
                  (0, a.MD)(B, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyTimelineEntryChangedHandler = {
            name: "GameRecording.NotifyTimelineEntryChanged#1",
            request: E,
          }),
          (e.RegisterForNotifyTimelineEntryChanged = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyTimelineEntryChangedHandler,
                  t,
                );
          }),
          (e.NotifyTimelineEntryChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryChanged#1",
                  (0, a.MD)(E, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyTimelineEntryChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyTimelineEntryChanged#1",
                  (0, a.MD)(E, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyClipCreatedHandler = {
            name: "GameRecording.NotifyClipCreated#1",
            request: ge,
          }),
          (e.RegisterForNotifyClipCreated = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyClipCreatedHandler,
                  t,
                );
          }),
          (e.NotifyClipCreated = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipCreated#1",
                  (0, a.MD)(ge, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyClipCreated = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipCreated#1",
                  (0, a.MD)(ge, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyClipDeletedHandler = {
            name: "GameRecording.NotifyClipDeleted#1",
            request: be,
          }),
          (e.RegisterForNotifyClipDeleted = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyClipDeletedHandler,
                  t,
                );
          }),
          (e.NotifyClipDeleted = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipDeleted#1",
                  (0, a.MD)(be, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyClipDeleted = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyClipDeleted#1",
                  (0, a.MD)(be, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyExportProgressHandler = {
            name: "GameRecording.NotifyExportProgress#1",
            request: he,
          }),
          (e.RegisterForNotifyExportProgress = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyExportProgressHandler,
                  t,
                );
          }),
          (e.NotifyExportProgress = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyExportProgress#1",
                  (0, a.MD)(he, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyExportProgress = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyExportProgress#1",
                  (0, a.MD)(he, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyUploadProgressHandler = {
            name: "GameRecording.NotifyUploadProgress#1",
            request: _e,
          }),
          (e.RegisterForNotifyUploadProgress = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyUploadProgressHandler,
                  t,
                );
          }),
          (e.NotifyUploadProgress = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyUploadProgress#1",
                  (0, a.MD)(_e, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyUploadProgress = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyUploadProgress#1",
                  (0, a.MD)(_e, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyLowDiskSpaceHandler = {
            name: "GameRecording.NotifyLowDiskSpace#1",
            request: w,
          }),
          (e.RegisterForNotifyLowDiskSpace = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyLowDiskSpaceHandler,
                  t,
                );
          }),
          (e.NotifyLowDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyLowDiskSpace#1",
                  (0, a.MD)(w, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyLowDiskSpace = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyLowDiskSpace#1",
                  (0, a.MD)(w, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.NotifyPostGameHighlightsChangedHandler = {
            name: "GameRecording.NotifyPostGameHighlightsChanged#1",
            request: C,
          }),
          (e.RegisterForNotifyPostGameHighlightsChanged = function (t, r) {
            return null == (r = r || (0, o.SM)().GetDefaultHandlerRegistry())
              ? (console.error(
                  "Transport Error: no default registry is available for request",
                ),
                null)
              : r.RegisterServiceNotificationHandler(
                  e.NotifyPostGameHighlightsChangedHandler,
                  t,
                );
          }),
          (e.NotifyPostGameHighlightsChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPostGameHighlightsChanged#1",
                  (0, a.MD)(C, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgNotifyPostGameHighlightsChanged = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? (console.error(
                  "Transport Error: no transport is available for request",
                ),
                !1)
              : t.SendNotification(
                  "GameRecording.NotifyPostGameHighlightsChanged#1",
                  (0, a.MD)(C, e),
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserAddTimelineEntryHandler = {
            name: "GameRecording.UserAddTimelineEntry#1",
            request: V,
            response: q,
          }),
          (e.UserAddTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserAddTimelineEntry#1",
                  (0, a.MD)(V, e),
                  q,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserAddTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserAddTimelineEntry#1",
                  (0, a.MD)(V, e),
                  q,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserUpdateTimelineEntryHandler = {
            name: "GameRecording.UserUpdateTimelineEntry#1",
            request: Z,
            response: Y,
          }),
          (e.UserUpdateTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserUpdateTimelineEntry#1",
                  (0, a.MD)(Z, e),
                  Y,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserUpdateTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserUpdateTimelineEntry#1",
                  (0, a.MD)(Z, e),
                  Y,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.UserRemoveTimelineEntryHandler = {
            name: "GameRecording.UserRemoveTimelineEntry#1",
            request: J,
            response: K,
          }),
          (e.UserRemoveTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserRemoveTimelineEntry#1",
                  (0, a.MD)(J, e),
                  K,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgUserRemoveTimelineEntry = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.UserRemoveTimelineEntry#1",
                  (0, a.MD)(J, e),
                  K,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.ManuallyDeleteRecordingsForAppsHandler = {
            name: "GameRecording.ManuallyDeleteRecordingsForApps#1",
            request: Q,
            response: $,
          }),
          (e.ManuallyDeleteRecordingsForApps = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ManuallyDeleteRecordingsForApps#1",
                  (0, a.MD)(Q, e),
                  $,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgManuallyDeleteRecordingsForApps = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.ManuallyDeleteRecordingsForApps#1",
                  (0, a.MD)(Q, e),
                  $,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.GetTotalDiskSpaceUsageHandler = {
            name: "GameRecording.GetTotalDiskSpaceUsage#1",
            request: ee,
            response: te,
          }),
          (e.GetTotalDiskSpaceUsage = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTotalDiskSpaceUsage#1",
                  (0, a.MD)(ee, e),
                  te,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgGetTotalDiskSpaceUsage = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.GetTotalDiskSpaceUsage#1",
                  (0, a.MD)(ee, e),
                  te,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SwitchBackgroundRecordingGameHandler = {
            name: "GameRecording.SwitchBackgroundRecordingGame#1",
            request: Se,
            response: ve,
          }),
          (e.SwitchBackgroundRecordingGame = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SwitchBackgroundRecordingGame#1",
                  (0, a.MD)(Se, e),
                  ve,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          }),
          (e.SendMsgSwitchBackgroundRecordingGame = function (e, t) {
            return null == (t = t || (0, o.SM)().GetDefaultTransport())
              ? new Promise((e, t) => {
                  console.error(
                    "Transport Error: no transport is available for request",
                  ),
                    t("Transport Error: no transport is available for request");
                })
              : t.SendMsg(
                  "GameRecording.SwitchBackgroundRecordingGame#1",
                  (0, a.MD)(Se, e),
                  ve,
                  { ePrivilege: 1, eClientExecutionSite: 1 },
                );
          });
      })(Ie || (Ie = {})),
        (function (e) {
          (e.AddTimelineHighlightMarkerHandler = {
            name: "GameRecordingDebug.AddTimelineHighlightMarker#1",
            request: ye,
            response: Me,
          }),
            (e.AddTimelineHighlightMarker = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineHighlightMarker#1",
                    (0, a.MD)(ye, e),
                    Me,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SendMsgAddTimelineHighlightMarker = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineHighlightMarker#1",
                    (0, a.MD)(ye, e),
                    Me,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.AddTimelineTimestampHandler = {
              name: "GameRecordingDebug.AddTimelineTimestamp#1",
              request: Te,
              response: Be,
            }),
            (e.AddTimelineTimestamp = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineTimestamp#1",
                    (0, a.MD)(Te, e),
                    Be,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SendMsgAddTimelineTimestamp = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineTimestamp#1",
                    (0, a.MD)(Te, e),
                    Be,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.AddTimelineRangeStartHandler = {
              name: "GameRecordingDebug.AddTimelineRangeStart#1",
              request: Re,
              response: Ee,
            }),
            (e.AddTimelineRangeStart = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineRangeStart#1",
                    (0, a.MD)(Re, e),
                    Ee,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SendMsgAddTimelineRangeStart = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineRangeStart#1",
                    (0, a.MD)(Re, e),
                    Ee,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.AddTimelineRangeEndHandler = {
              name: "GameRecordingDebug.AddTimelineRangeEnd#1",
              request: we,
              response: Ce,
            }),
            (e.AddTimelineRangeEnd = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineRangeEnd#1",
                    (0, a.MD)(we, e),
                    Ce,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SendMsgAddTimelineRangeEnd = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.AddTimelineRangeEnd#1",
                    (0, a.MD)(we, e),
                    Ce,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SetTimelineGameModeHandler = {
              name: "GameRecordingDebug.SetTimelineGameMode#1",
              request: Ge,
              response: Pe,
            }),
            (e.SetTimelineGameMode = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.SetTimelineGameMode#1",
                    (0, a.MD)(Ge, e),
                    Pe,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            }),
            (e.SendMsgSetTimelineGameMode = function (e, t) {
              return null == (t = t || (0, o.SM)().GetDefaultTransport())
                ? new Promise((e, t) => {
                    console.error(
                      "Transport Error: no transport is available for request",
                    ),
                      t(
                        "Transport Error: no transport is available for request",
                      );
                  })
                : t.SendMsg(
                    "GameRecordingDebug.SetTimelineGameMode#1",
                    (0, a.MD)(Ge, e),
                    Pe,
                    { ePrivilege: 1, eClientExecutionSite: 1 },
                  );
            });
        })(De || (De = {}));
    },
    14039: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var i = r(30805);
      function n(e, t, r) {
        return (
          (t = (0, i.Z)(t)) in e
            ? Object.defineProperty(e, t, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = r),
          e
        );
      }
    },
    25630: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => a });
      var i = r(14039);
      function n(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(e);
          t &&
            (i = i.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            r.push.apply(r, i);
        }
        return r;
      }
      function a(e) {
        for (var t = 1; t < arguments.length; t++) {
          var r = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? n(Object(r), !0).forEach(function (t) {
                (0, i.Z)(e, t, r[t]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
              : n(Object(r)).forEach(function (t) {
                  Object.defineProperty(
                    e,
                    t,
                    Object.getOwnPropertyDescriptor(r, t),
                  );
                });
        }
        return e;
      }
    },
    30805: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var i = r(26082);
      function n(e) {
        var t = (function (e, t) {
          if ("object" != (0, i.Z)(e) || !e) return e;
          var r = e[Symbol.toPrimitive];
          if (void 0 !== r) {
            var n = r.call(e, t || "default");
            if ("object" != (0, i.Z)(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t ? String : Number)(e);
        })(e, "string");
        return "symbol" == (0, i.Z)(t) ? t : String(t);
      }
    },
    26082: (e, t, r) => {
      "use strict";
      function i(e) {
        return (
          (i =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          i(e)
        );
      }
      r.d(t, { Z: () => i });
    },
    46086: (e) => {
      "use strict";
      e.exports = JSON.parse(
        '{"daterecorded":1713552945,"starttime":0,"entries":[{"id":"1","time":"1000","type":"gamemode","mode":3},{"id":"2","time":"7000","type":"event","title":"bolt","description":"steam_bolt","icon":"steam_bolt","priority":2,"duration":"0","possible_clip":2},{"id":"3","time":"8500","type":"event","title":"gem","description":"steam_gem","icon":"steam_gem","priority":1,"duration":"0","possible_clip":2},{"id":"4","time":"11000","type":"event","title":"star","description":"steam_star","icon":"steam_star","priority":4,"duration":"0","possible_clip":2},{"id":"6","time":"13000","type":"event","title":"heart","description":"steam_heart","icon":"steam_heart","priority":2,"duration":"0","possible_clip":2},{"id":"7","time":"15500","type":"event","title":"checkmark","description":"steam_checkmark","icon":"steam_checkmark","priority":3,"duration":"0","possible_clip":2},{"id":"8","time":"18000","type":"gamemode","mode":1},{"id":"9","time":"25000","type":"event","title":"crown","description":"steam_crown","icon":"steam_crown","priority":10,"duration":"0","possible_clip":2},{"id":"10","time":"27000","type":"event","title":"ribbon","description":"steam_ribbon","icon":"steam_ribbon","priority":9,"duration":"0","possible_clip":2},{"id":"11","time":"32000","type":"event","title":"chest","description":"steam_chest","icon":"steam_chest","priority":8,"duration":"0","possible_clip":2},{"id":"13","time":"34500","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":8,"duration":"0","possible_clip":2},{"id":"14","time":"36000","type":"event","title":"timer","description":"steam_timer","icon":"steam_timer","priority":10,"duration":"0","possible_clip":2},{"id":"15","time":"46000","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":10,"duration":"0","possible_clip":2},{"id":"17","time":"50000","type":"usermarker","icon":"steam_marker","priority":0},{"id":"18","time":"51500","type":"event","title":"defend","description":"steam_defend","icon":"steam_defend","priority":10,"duration":"0","possible_clip":2},{"id":"19","time":"52500","type":"event","title":"explosion","description":"steam_explosion","icon":"steam_explosion","priority":10,"duration":"0","possible_clip":2}],"endtime":60000}',
      );
    },
  },
]);
